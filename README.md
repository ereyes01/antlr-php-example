## Memory Leak in ANTLR4 Go Target + PHP Grammar 

This repo contains a grammar and code that reproduces issue [antlr/antlr4#2088](https://github.com/antlr/antlr4/issues/2088), which I've opened against the antlr4 repository. In here we have:

- `./parser`
    - PHP from grammars-v4, which I ported for the Go target 
        - Depends on [PR 2269](https://github.com/antlr/antlr4/pull/2269), which exports some fields for the grammar actions.
    - The parser code generated by antlr using the latest master + PR 2269.
- `main.go`
    - Pass in `-help` for usage info
    - Accepts a filename of a PHP file
    - Prints the text of every rule encountered in the file
    - Enables the Go profiler over HTTP port 6060
        - [Useful profiler operations](https://golang.org/pkg/net/http/pprof/)
- `deepConcatanation.php`
    - PHP code that causes apparently unbounded memory growth in the parser (I stopped it at 8GB)
    - Taken from the [examples](https://github.com/antlr/grammars-v4/blob/master/php/examples/deepConcatanation.php) for the PHP grammar in grammars-v4
- `profile001.svg`
    - Graphical heap profile taken when resident mem was ~8GB
    - To take your own heap snapshot, run the following while the test is running:
        - `go tool pprof http://localhost:6060/debug/pprof/heap`
        - In the pprof console, run `svg` to generate a new graphic, or run `top` to see it in text form (svg is more comprehensive)

# Steps to Reproduce

- Set up your `GOPATH` and Workspace:

```
export GOPATH=./php-memleak
```

- Clone with antlr4 dependency:

```
git clone --recursive https://github.com/ereyes01/antlr-php-example.git $GOPATH/src/github.com/ereyes01/antlr-php-example
```

- Build the binary:

```
cd $GOPATH/src/github.com/ereyes01/antlr-php-example
go build
```

- Run the command with the test PHP file:

```
./antlr-php-example -file deepConcatanation.php
```

*WARNING: This will fill up your RAM after a few minutes, watch the memory usage carefully and kill it before it grows too big. I ran on a 16GB system and killed it when it grew to 8GB, as reported by the `top` command.*

If you prefer not risking your system going down due to insufficient RAM, you can also just take a look at the `profile001.svg`, which combines a stack trace and the amount of memory allocated per function.

If you want to reproduce and generate your own memory profile image, see the `go tool pprof ...` instructions above.
