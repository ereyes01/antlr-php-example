// Code generated from PhpParser.g4 by ANTLR 4.7.1. DO NOT EDIT.

package parser // PhpParser

import (
	"fmt"
	"reflect"
	"strconv"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = reflect.Copy
var _ = strconv.Itoa

var parserATN = []uint16{
	3, 24715, 42794, 33075, 47597, 16764, 15335, 30598, 22884, 3, 233, 1624,
	4, 2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7, 9, 7,
	4, 8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 4, 11, 9, 11, 4, 12, 9, 12, 4, 13,
	9, 13, 4, 14, 9, 14, 4, 15, 9, 15, 4, 16, 9, 16, 4, 17, 9, 17, 4, 18, 9,
	18, 4, 19, 9, 19, 4, 20, 9, 20, 4, 21, 9, 21, 4, 22, 9, 22, 4, 23, 9, 23,
	4, 24, 9, 24, 4, 25, 9, 25, 4, 26, 9, 26, 4, 27, 9, 27, 4, 28, 9, 28, 4,
	29, 9, 29, 4, 30, 9, 30, 4, 31, 9, 31, 4, 32, 9, 32, 4, 33, 9, 33, 4, 34,
	9, 34, 4, 35, 9, 35, 4, 36, 9, 36, 4, 37, 9, 37, 4, 38, 9, 38, 4, 39, 9,
	39, 4, 40, 9, 40, 4, 41, 9, 41, 4, 42, 9, 42, 4, 43, 9, 43, 4, 44, 9, 44,
	4, 45, 9, 45, 4, 46, 9, 46, 4, 47, 9, 47, 4, 48, 9, 48, 4, 49, 9, 49, 4,
	50, 9, 50, 4, 51, 9, 51, 4, 52, 9, 52, 4, 53, 9, 53, 4, 54, 9, 54, 4, 55,
	9, 55, 4, 56, 9, 56, 4, 57, 9, 57, 4, 58, 9, 58, 4, 59, 9, 59, 4, 60, 9,
	60, 4, 61, 9, 61, 4, 62, 9, 62, 4, 63, 9, 63, 4, 64, 9, 64, 4, 65, 9, 65,
	4, 66, 9, 66, 4, 67, 9, 67, 4, 68, 9, 68, 4, 69, 9, 69, 4, 70, 9, 70, 4,
	71, 9, 71, 4, 72, 9, 72, 4, 73, 9, 73, 4, 74, 9, 74, 4, 75, 9, 75, 4, 76,
	9, 76, 4, 77, 9, 77, 4, 78, 9, 78, 4, 79, 9, 79, 4, 80, 9, 80, 4, 81, 9,
	81, 4, 82, 9, 82, 4, 83, 9, 83, 4, 84, 9, 84, 4, 85, 9, 85, 4, 86, 9, 86,
	4, 87, 9, 87, 4, 88, 9, 88, 4, 89, 9, 89, 4, 90, 9, 90, 4, 91, 9, 91, 4,
	92, 9, 92, 4, 93, 9, 93, 4, 94, 9, 94, 4, 95, 9, 95, 4, 96, 9, 96, 4, 97,
	9, 97, 4, 98, 9, 98, 4, 99, 9, 99, 4, 100, 9, 100, 4, 101, 9, 101, 4, 102,
	9, 102, 4, 103, 9, 103, 4, 104, 9, 104, 4, 105, 9, 105, 4, 106, 9, 106,
	4, 107, 9, 107, 4, 108, 9, 108, 4, 109, 9, 109, 4, 110, 9, 110, 4, 111,
	9, 111, 4, 112, 9, 112, 4, 113, 9, 113, 4, 114, 9, 114, 4, 115, 9, 115,
	4, 116, 9, 116, 4, 117, 9, 117, 4, 118, 9, 118, 4, 119, 9, 119, 4, 120,
	9, 120, 4, 121, 9, 121, 4, 122, 9, 122, 4, 123, 9, 123, 4, 124, 9, 124,
	4, 125, 9, 125, 4, 126, 9, 126, 4, 127, 9, 127, 4, 128, 9, 128, 4, 129,
	9, 129, 4, 130, 9, 130, 3, 2, 5, 2, 262, 10, 2, 3, 2, 7, 2, 265, 10, 2,
	12, 2, 14, 2, 268, 11, 2, 3, 2, 3, 2, 3, 3, 3, 3, 3, 3, 5, 3, 275, 10,
	3, 3, 4, 6, 4, 278, 10, 4, 13, 4, 14, 4, 279, 3, 5, 3, 5, 3, 5, 3, 5, 3,
	5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3,
	5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 7, 5, 304, 10, 5, 12, 5, 14, 5, 307, 11,
	5, 3, 5, 5, 5, 310, 10, 5, 3, 6, 6, 6, 313, 10, 6, 13, 6, 14, 6, 314, 3,
	7, 7, 7, 318, 10, 7, 12, 7, 14, 7, 321, 11, 7, 3, 7, 6, 7, 324, 10, 7,
	13, 7, 14, 7, 325, 3, 8, 3, 8, 3, 8, 3, 8, 3, 8, 3, 9, 3, 9, 3, 9, 3, 9,
	3, 9, 3, 9, 5, 9, 339, 10, 9, 3, 10, 3, 10, 5, 10, 343, 10, 10, 3, 10,
	3, 10, 3, 10, 3, 11, 5, 11, 349, 10, 11, 3, 11, 3, 11, 3, 11, 5, 11, 354,
	10, 11, 3, 11, 7, 11, 357, 10, 11, 12, 11, 14, 11, 360, 11, 11, 3, 12,
	3, 12, 3, 12, 5, 12, 365, 10, 12, 3, 13, 3, 13, 5, 13, 369, 10, 13, 3,
	13, 3, 13, 7, 13, 373, 10, 13, 12, 13, 14, 13, 376, 11, 13, 3, 13, 3, 13,
	3, 13, 3, 13, 5, 13, 382, 10, 13, 3, 14, 3, 14, 3, 14, 3, 14, 3, 14, 5,
	14, 389, 10, 14, 3, 15, 3, 15, 3, 15, 5, 15, 394, 10, 15, 3, 15, 3, 15,
	5, 15, 398, 10, 15, 3, 15, 3, 15, 3, 15, 3, 15, 3, 15, 3, 16, 3, 16, 5,
	16, 407, 10, 16, 3, 16, 5, 16, 410, 10, 16, 3, 16, 5, 16, 413, 10, 16,
	3, 16, 3, 16, 3, 16, 5, 16, 418, 10, 16, 3, 16, 3, 16, 5, 16, 422, 10,
	16, 3, 16, 3, 16, 5, 16, 426, 10, 16, 3, 16, 3, 16, 3, 16, 5, 16, 431,
	10, 16, 3, 16, 3, 16, 5, 16, 435, 10, 16, 5, 16, 437, 10, 16, 3, 16, 3,
	16, 7, 16, 441, 10, 16, 12, 16, 14, 16, 444, 11, 16, 3, 16, 3, 16, 3, 17,
	3, 17, 3, 18, 3, 18, 3, 18, 7, 18, 453, 10, 18, 12, 18, 14, 18, 456, 11,
	18, 3, 19, 3, 19, 3, 19, 3, 19, 3, 19, 3, 19, 3, 19, 3, 19, 3, 19, 3, 19,
	3, 19, 3, 19, 3, 19, 3, 19, 5, 19, 472, 10, 19, 3, 20, 3, 20, 3, 20, 7,
	20, 477, 10, 20, 12, 20, 14, 20, 480, 11, 20, 3, 21, 3, 21, 3, 21, 7, 21,
	485, 10, 21, 12, 21, 14, 21, 488, 11, 21, 3, 22, 3, 22, 3, 22, 3, 23, 3,
	23, 3, 23, 3, 23, 3, 23, 5, 23, 498, 10, 23, 3, 24, 3, 24, 3, 24, 3, 24,
	7, 24, 504, 10, 24, 12, 24, 14, 24, 507, 11, 24, 3, 24, 3, 24, 3, 25, 7,
	25, 512, 10, 25, 12, 25, 14, 25, 515, 11, 25, 3, 26, 3, 26, 3, 26, 3, 26,
	5, 26, 521, 10, 26, 3, 26, 3, 26, 3, 26, 7, 26, 526, 10, 26, 12, 26, 14,
	26, 529, 11, 26, 3, 26, 3, 26, 3, 27, 3, 27, 3, 27, 3, 27, 3, 27, 3, 27,
	3, 27, 3, 27, 3, 27, 3, 27, 3, 27, 3, 27, 3, 27, 3, 27, 3, 27, 3, 27, 3,
	27, 3, 27, 5, 27, 551, 10, 27, 3, 28, 3, 28, 3, 28, 7, 28, 556, 10, 28,
	12, 28, 14, 28, 559, 11, 28, 3, 29, 3, 29, 3, 29, 7, 29, 564, 10, 29, 12,
	29, 14, 29, 567, 11, 29, 3, 30, 3, 30, 3, 30, 3, 30, 3, 31, 7, 31, 574,
	10, 31, 12, 31, 14, 31, 577, 11, 31, 3, 32, 3, 32, 3, 32, 5, 32, 582, 10,
	32, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33,
	3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3,
	33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 5, 33, 611, 10, 33, 3, 34,
	3, 34, 3, 35, 3, 35, 3, 35, 3, 35, 3, 36, 3, 36, 3, 36, 3, 36, 7, 36, 623,
	10, 36, 12, 36, 14, 36, 626, 11, 36, 3, 36, 5, 36, 629, 10, 36, 3, 36,
	3, 36, 3, 36, 3, 36, 3, 36, 7, 36, 636, 10, 36, 12, 36, 14, 36, 639, 11,
	36, 3, 36, 5, 36, 642, 10, 36, 3, 36, 3, 36, 3, 36, 5, 36, 647, 10, 36,
	3, 37, 3, 37, 3, 37, 3, 37, 3, 38, 3, 38, 3, 38, 3, 38, 3, 38, 3, 39, 3,
	39, 3, 39, 3, 40, 3, 40, 3, 40, 3, 40, 3, 41, 3, 41, 3, 41, 3, 41, 3, 41,
	3, 41, 3, 41, 3, 41, 5, 41, 673, 10, 41, 3, 42, 3, 42, 3, 42, 3, 42, 3,
	42, 3, 42, 3, 43, 3, 43, 3, 43, 5, 43, 684, 10, 43, 3, 43, 3, 43, 5, 43,
	688, 10, 43, 3, 43, 3, 43, 5, 43, 692, 10, 43, 3, 43, 3, 43, 3, 43, 3,
	43, 3, 43, 3, 43, 3, 43, 5, 43, 701, 10, 43, 3, 44, 3, 44, 3, 45, 3, 45,
	3, 46, 3, 46, 3, 46, 3, 46, 5, 46, 711, 10, 46, 3, 46, 7, 46, 714, 10,
	46, 12, 46, 14, 46, 717, 11, 46, 3, 46, 3, 46, 3, 46, 5, 46, 722, 10, 46,
	3, 46, 7, 46, 725, 10, 46, 12, 46, 14, 46, 728, 11, 46, 3, 46, 3, 46, 5,
	46, 732, 10, 46, 3, 47, 3, 47, 3, 47, 5, 47, 737, 10, 47, 3, 47, 6, 47,
	740, 10, 47, 13, 47, 14, 47, 741, 3, 47, 3, 47, 3, 48, 3, 48, 5, 48, 748,
	10, 48, 3, 48, 3, 48, 3, 49, 3, 49, 5, 49, 754, 10, 49, 3, 49, 3, 49, 3,
	50, 3, 50, 5, 50, 760, 10, 50, 3, 50, 3, 50, 3, 51, 3, 51, 3, 51, 3, 52,
	3, 52, 3, 52, 3, 52, 3, 52, 3, 52, 3, 53, 3, 53, 3, 53, 3, 53, 3, 53, 5,
	53, 778, 10, 53, 3, 53, 3, 53, 3, 53, 5, 53, 783, 10, 53, 3, 53, 5, 53,
	786, 10, 53, 3, 53, 3, 53, 3, 53, 3, 53, 3, 53, 3, 53, 3, 53, 3, 53, 5,
	53, 796, 10, 53, 3, 53, 5, 53, 799, 10, 53, 3, 53, 3, 53, 3, 53, 3, 53,
	3, 53, 3, 53, 3, 53, 3, 53, 3, 53, 3, 53, 3, 53, 5, 53, 812, 10, 53, 3,
	53, 3, 53, 3, 53, 3, 53, 3, 53, 3, 53, 5, 53, 820, 10, 53, 3, 54, 3, 54,
	3, 54, 6, 54, 825, 10, 54, 13, 54, 14, 54, 826, 3, 54, 5, 54, 830, 10,
	54, 3, 54, 7, 54, 833, 10, 54, 12, 54, 14, 54, 836, 11, 54, 3, 54, 5, 54,
	839, 10, 54, 3, 55, 3, 55, 3, 55, 3, 55, 3, 55, 3, 55, 3, 55, 3, 56, 3,
	56, 3, 56, 3, 57, 3, 57, 3, 57, 3, 57, 3, 58, 3, 58, 3, 58, 3, 58, 3, 59,
	3, 59, 3, 59, 3, 59, 3, 59, 3, 59, 3, 59, 3, 59, 3, 59, 3, 59, 5, 59, 869,
	10, 59, 3, 60, 6, 60, 872, 10, 60, 13, 60, 14, 60, 873, 3, 61, 3, 61, 5,
	61, 878, 10, 61, 3, 62, 3, 62, 3, 62, 7, 62, 883, 10, 62, 12, 62, 14, 62,
	886, 11, 62, 3, 63, 5, 63, 889, 10, 63, 3, 63, 3, 63, 7, 63, 893, 10, 63,
	12, 63, 14, 63, 896, 11, 63, 3, 64, 3, 64, 5, 64, 900, 10, 64, 3, 64, 5,
	64, 903, 10, 64, 3, 64, 5, 64, 906, 10, 64, 3, 64, 3, 64, 3, 65, 3, 65,
	3, 65, 5, 65, 913, 10, 65, 3, 66, 3, 66, 3, 66, 3, 66, 7, 66, 919, 10,
	66, 12, 66, 14, 66, 922, 11, 66, 3, 66, 3, 66, 3, 67, 3, 67, 3, 67, 3,
	67, 3, 67, 3, 67, 3, 67, 3, 67, 5, 67, 934, 10, 67, 3, 68, 3, 68, 3, 68,
	3, 68, 3, 69, 3, 69, 3, 69, 3, 69, 7, 69, 944, 10, 69, 12, 69, 14, 69,
	947, 11, 69, 3, 69, 3, 69, 3, 70, 3, 70, 3, 70, 3, 70, 3, 70, 7, 70, 956,
	10, 70, 12, 70, 14, 70, 959, 11, 70, 3, 70, 3, 70, 3, 70, 3, 70, 3, 70,
	3, 70, 3, 70, 7, 70, 968, 10, 70, 12, 70, 14, 70, 971, 11, 70, 3, 70, 3,
	70, 3, 70, 3, 70, 5, 70, 977, 10, 70, 3, 70, 3, 70, 5, 70, 981, 10, 70,
	3, 70, 3, 70, 5, 70, 985, 10, 70, 3, 70, 3, 70, 3, 70, 3, 70, 5, 70, 991,
	10, 70, 3, 70, 3, 70, 3, 70, 3, 70, 3, 70, 3, 70, 5, 70, 999, 10, 70, 3,
	71, 3, 71, 3, 71, 7, 71, 1004, 10, 71, 12, 71, 14, 71, 1007, 11, 71, 3,
	71, 5, 71, 1010, 10, 71, 3, 72, 3, 72, 5, 72, 1014, 10, 72, 3, 73, 3, 73,
	3, 73, 3, 73, 3, 73, 3, 73, 3, 73, 3, 74, 3, 74, 3, 74, 3, 74, 5, 74, 1027,
	10, 74, 3, 74, 5, 74, 1030, 10, 74, 3, 74, 3, 74, 3, 75, 3, 75, 3, 75,
	5, 75, 1037, 10, 75, 3, 75, 3, 75, 3, 76, 3, 76, 3, 76, 3, 76, 3, 77, 3,
	77, 5, 77, 1047, 10, 77, 3, 78, 3, 78, 5, 78, 1051, 10, 78, 3, 79, 6, 79,
	1054, 10, 79, 13, 79, 14, 79, 1055, 3, 80, 3, 80, 3, 80, 5, 80, 1061, 10,
	80, 3, 81, 3, 81, 3, 81, 3, 81, 3, 82, 3, 82, 3, 82, 3, 82, 3, 82, 7, 82,
	1072, 10, 82, 12, 82, 14, 82, 1075, 11, 82, 3, 82, 3, 82, 3, 83, 3, 83,
	3, 83, 7, 83, 1082, 10, 83, 12, 83, 14, 83, 1085, 11, 83, 3, 84, 3, 84,
	3, 84, 5, 84, 1090, 10, 84, 3, 84, 3, 84, 3, 85, 3, 85, 3, 85, 3, 85, 3,
	85, 3, 85, 3, 85, 3, 85, 3, 85, 3, 85, 3, 85, 3, 85, 3, 85, 3, 85, 3, 85,
	3, 85, 3, 85, 3, 85, 3, 85, 3, 85, 3, 85, 3, 85, 3, 85, 3, 85, 3, 85, 3,
	85, 3, 85, 3, 85, 3, 85, 3, 85, 3, 85, 3, 85, 3, 85, 3, 85, 5, 85, 1128,
	10, 85, 3, 85, 3, 85, 3, 85, 5, 85, 1133, 10, 85, 3, 85, 5, 85, 1136, 10,
	85, 3, 85, 3, 85, 3, 85, 3, 85, 5, 85, 1142, 10, 85, 3, 85, 3, 85, 3, 85,
	3, 85, 3, 85, 3, 85, 3, 85, 3, 85, 3, 85, 3, 85, 3, 85, 3, 85, 3, 85, 3,
	85, 3, 85, 3, 85, 3, 85, 3, 85, 3, 85, 3, 85, 3, 85, 3, 85, 3, 85, 3, 85,
	3, 85, 3, 85, 3, 85, 5, 85, 1171, 10, 85, 3, 85, 3, 85, 3, 85, 3, 85, 3,
	85, 5, 85, 1178, 10, 85, 3, 85, 3, 85, 5, 85, 1182, 10, 85, 3, 85, 3, 85,
	3, 85, 3, 85, 5, 85, 1188, 10, 85, 3, 85, 3, 85, 3, 85, 3, 85, 3, 85, 3,
	85, 3, 85, 3, 85, 3, 85, 3, 85, 3, 85, 5, 85, 1201, 10, 85, 5, 85, 1203,
	10, 85, 3, 85, 3, 85, 3, 85, 3, 85, 3, 85, 3, 85, 3, 85, 3, 85, 3, 85,
	3, 85, 3, 85, 3, 85, 3, 85, 3, 85, 3, 85, 3, 85, 3, 85, 3, 85, 3, 85, 3,
	85, 3, 85, 3, 85, 3, 85, 3, 85, 3, 85, 3, 85, 3, 85, 3, 85, 3, 85, 3, 85,
	3, 85, 3, 85, 3, 85, 3, 85, 3, 85, 3, 85, 5, 85, 1241, 10, 85, 3, 85, 3,
	85, 3, 85, 3, 85, 3, 85, 3, 85, 3, 85, 3, 85, 3, 85, 3, 85, 3, 85, 3, 85,
	3, 85, 3, 85, 7, 85, 1257, 10, 85, 12, 85, 14, 85, 1260, 11, 85, 3, 86,
	3, 86, 3, 86, 5, 86, 1265, 10, 86, 3, 87, 3, 87, 3, 88, 3, 88, 3, 88, 3,
	88, 5, 88, 1273, 10, 88, 3, 89, 3, 89, 3, 89, 7, 89, 1278, 10, 89, 12,
	89, 14, 89, 1281, 11, 89, 3, 89, 5, 89, 1284, 10, 89, 3, 90, 3, 90, 3,
	90, 5, 90, 1289, 10, 90, 3, 90, 3, 90, 3, 90, 5, 90, 1294, 10, 90, 3, 90,
	3, 90, 5, 90, 1298, 10, 90, 3, 91, 3, 91, 3, 91, 3, 91, 3, 91, 7, 91, 1305,
	10, 91, 12, 91, 14, 91, 1308, 11, 91, 3, 91, 3, 91, 3, 92, 5, 92, 1313,
	10, 92, 3, 92, 3, 92, 3, 93, 3, 93, 5, 93, 1319, 10, 93, 3, 93, 5, 93,
	1322, 10, 93, 3, 94, 3, 94, 5, 94, 1326, 10, 94, 3, 94, 5, 94, 1329, 10,
	94, 3, 94, 3, 94, 5, 94, 1333, 10, 94, 3, 95, 3, 95, 3, 95, 7, 95, 1338,
	10, 95, 12, 95, 14, 95, 1341, 11, 95, 3, 96, 5, 96, 1344, 10, 96, 3, 96,
	5, 96, 1347, 10, 96, 3, 96, 3, 96, 3, 97, 3, 97, 3, 97, 7, 97, 1354, 10,
	97, 12, 97, 14, 97, 1357, 11, 97, 3, 98, 3, 98, 3, 98, 7, 98, 1362, 10,
	98, 12, 98, 14, 98, 1365, 11, 98, 3, 99, 3, 99, 3, 99, 3, 99, 7, 99, 1371,
	10, 99, 12, 99, 14, 99, 1374, 11, 99, 3, 99, 5, 99, 1377, 10, 99, 3, 99,
	3, 99, 3, 100, 5, 100, 1382, 10, 100, 3, 100, 3, 100, 3, 100, 5, 100, 1387,
	10, 100, 3, 101, 3, 101, 3, 101, 3, 101, 3, 101, 3, 101, 5, 101, 1395,
	10, 101, 5, 101, 1397, 10, 101, 3, 101, 3, 101, 3, 101, 3, 101, 5, 101,
	1403, 10, 101, 5, 101, 1405, 10, 101, 3, 101, 3, 101, 3, 101, 5, 101, 1410,
	10, 101, 3, 102, 3, 102, 3, 102, 7, 102, 1415, 10, 102, 12, 102, 14, 102,
	1418, 11, 102, 3, 103, 3, 103, 3, 103, 5, 103, 1423, 10, 103, 3, 104, 3,
	104, 3, 104, 3, 104, 3, 104, 5, 104, 1430, 10, 104, 3, 105, 3, 105, 3,
	105, 3, 105, 5, 105, 1436, 10, 105, 3, 106, 3, 106, 3, 107, 3, 107, 3,
	107, 3, 107, 3, 107, 3, 107, 5, 107, 1446, 10, 107, 3, 107, 3, 107, 5,
	107, 1450, 10, 107, 3, 107, 3, 107, 3, 107, 5, 107, 1455, 10, 107, 3, 108,
	3, 108, 3, 109, 3, 109, 6, 109, 1461, 10, 109, 13, 109, 14, 109, 1462,
	3, 109, 3, 109, 6, 109, 1467, 10, 109, 13, 109, 14, 109, 1468, 3, 109,
	3, 109, 3, 109, 7, 109, 1474, 10, 109, 12, 109, 14, 109, 1477, 11, 109,
	3, 109, 5, 109, 1480, 10, 109, 3, 110, 3, 110, 5, 110, 1484, 10, 110, 3,
	111, 3, 111, 3, 111, 7, 111, 1489, 10, 111, 12, 111, 14, 111, 1492, 11,
	111, 3, 112, 3, 112, 3, 112, 3, 112, 3, 112, 3, 112, 5, 112, 1500, 10,
	112, 3, 112, 7, 112, 1503, 10, 112, 12, 112, 14, 112, 1506, 11, 112, 3,
	113, 3, 113, 3, 113, 5, 113, 1511, 10, 113, 3, 114, 3, 114, 3, 114, 3,
	115, 3, 115, 3, 115, 5, 115, 1519, 10, 115, 3, 116, 5, 116, 1522, 10, 116,
	3, 116, 3, 116, 7, 116, 1526, 10, 116, 12, 116, 14, 116, 1529, 11, 116,
	3, 117, 3, 117, 3, 117, 5, 117, 1534, 10, 117, 3, 117, 3, 117, 3, 117,
	3, 117, 5, 117, 1540, 10, 117, 3, 118, 3, 118, 5, 118, 1544, 10, 118, 3,
	119, 3, 119, 3, 119, 3, 119, 3, 119, 5, 119, 1551, 10, 119, 3, 119, 7,
	119, 1554, 10, 119, 12, 119, 14, 119, 1557, 11, 119, 3, 120, 7, 120, 1560,
	10, 120, 12, 120, 14, 120, 1563, 11, 120, 3, 120, 3, 120, 3, 120, 3, 120,
	3, 120, 3, 120, 5, 120, 1571, 10, 120, 3, 120, 7, 120, 1574, 10, 120, 12,
	120, 14, 120, 1577, 11, 120, 3, 121, 3, 121, 5, 121, 1581, 10, 121, 3,
	121, 3, 121, 3, 121, 3, 121, 3, 121, 5, 121, 1588, 10, 121, 3, 122, 5,
	122, 1591, 10, 122, 3, 122, 3, 122, 5, 122, 1595, 10, 122, 7, 122, 1597,
	10, 122, 12, 122, 14, 122, 1600, 11, 122, 3, 123, 3, 123, 3, 123, 3, 123,
	3, 123, 3, 123, 5, 123, 1608, 10, 123, 3, 124, 3, 124, 3, 125, 3, 125,
	3, 126, 3, 126, 3, 127, 3, 127, 3, 128, 3, 128, 3, 129, 3, 129, 3, 130,
	3, 130, 3, 130, 2, 3, 168, 131, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22,
	24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58,
	60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94,
	96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124,
	126, 128, 130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 150, 152, 154,
	156, 158, 160, 162, 164, 166, 168, 170, 172, 174, 176, 178, 180, 182, 184,
	186, 188, 190, 192, 194, 196, 198, 200, 202, 204, 206, 208, 210, 212, 214,
	216, 218, 220, 222, 224, 226, 228, 230, 232, 234, 236, 238, 240, 242, 244,
	246, 248, 250, 252, 254, 256, 258, 2, 26, 4, 2, 57, 57, 82, 82, 4, 2, 55,
	55, 120, 120, 3, 2, 209, 210, 3, 2, 197, 198, 4, 2, 190, 190, 192, 193,
	3, 2, 157, 158, 3, 2, 88, 89, 3, 2, 112, 113, 3, 2, 194, 196, 4, 2, 192,
	193, 200, 200, 3, 2, 180, 181, 4, 2, 163, 164, 186, 187, 3, 2, 159, 162,
	5, 2, 165, 167, 169, 177, 211, 211, 3, 2, 192, 193, 4, 2, 216, 217, 219,
	220, 4, 2, 55, 55, 106, 106, 4, 2, 45, 45, 77, 77, 4, 2, 45, 153, 215,
	215, 6, 2, 45, 45, 77, 77, 109, 111, 116, 116, 3, 2, 146, 153, 3, 2, 130,
	145, 9, 2, 46, 46, 49, 49, 63, 63, 94, 95, 105, 105, 114, 114, 117, 117,
	11, 2, 46, 46, 48, 49, 62, 63, 79, 79, 92, 95, 105, 105, 114, 114, 117,
	117, 123, 125, 2, 1791, 2, 261, 3, 2, 2, 2, 4, 274, 3, 2, 2, 2, 6, 277,
	3, 2, 2, 2, 8, 309, 3, 2, 2, 2, 10, 312, 3, 2, 2, 2, 12, 319, 3, 2, 2,
	2, 14, 327, 3, 2, 2, 2, 16, 338, 3, 2, 2, 2, 18, 340, 3, 2, 2, 2, 20, 348,
	3, 2, 2, 2, 22, 361, 3, 2, 2, 2, 24, 366, 3, 2, 2, 2, 26, 388, 3, 2, 2,
	2, 28, 390, 3, 2, 2, 2, 30, 404, 3, 2, 2, 2, 32, 447, 3, 2, 2, 2, 34, 449,
	3, 2, 2, 2, 36, 471, 3, 2, 2, 2, 38, 473, 3, 2, 2, 2, 40, 481, 3, 2, 2,
	2, 42, 489, 3, 2, 2, 2, 44, 492, 3, 2, 2, 2, 46, 499, 3, 2, 2, 2, 48, 513,
	3, 2, 2, 2, 50, 516, 3, 2, 2, 2, 52, 550, 3, 2, 2, 2, 54, 552, 3, 2, 2,
	2, 56, 560, 3, 2, 2, 2, 58, 568, 3, 2, 2, 2, 60, 575, 3, 2, 2, 2, 62, 581,
	3, 2, 2, 2, 64, 610, 3, 2, 2, 2, 66, 612, 3, 2, 2, 2, 68, 614, 3, 2, 2,
	2, 70, 646, 3, 2, 2, 2, 72, 648, 3, 2, 2, 2, 74, 652, 3, 2, 2, 2, 76, 657,
	3, 2, 2, 2, 78, 660, 3, 2, 2, 2, 80, 664, 3, 2, 2, 2, 82, 674, 3, 2, 2,
	2, 84, 680, 3, 2, 2, 2, 86, 702, 3, 2, 2, 2, 88, 704, 3, 2, 2, 2, 90, 706,
	3, 2, 2, 2, 92, 739, 3, 2, 2, 2, 94, 745, 3, 2, 2, 2, 96, 751, 3, 2, 2,
	2, 98, 757, 3, 2, 2, 2, 100, 763, 3, 2, 2, 2, 102, 766, 3, 2, 2, 2, 104,
	772, 3, 2, 2, 2, 106, 821, 3, 2, 2, 2, 108, 840, 3, 2, 2, 2, 110, 847,
	3, 2, 2, 2, 112, 850, 3, 2, 2, 2, 114, 854, 3, 2, 2, 2, 116, 858, 3, 2,
	2, 2, 118, 871, 3, 2, 2, 2, 120, 877, 3, 2, 2, 2, 122, 879, 3, 2, 2, 2,
	124, 888, 3, 2, 2, 2, 126, 897, 3, 2, 2, 2, 128, 912, 3, 2, 2, 2, 130,
	914, 3, 2, 2, 2, 132, 933, 3, 2, 2, 2, 134, 935, 3, 2, 2, 2, 136, 939,
	3, 2, 2, 2, 138, 998, 3, 2, 2, 2, 140, 1009, 3, 2, 2, 2, 142, 1013, 3,
	2, 2, 2, 144, 1015, 3, 2, 2, 2, 146, 1022, 3, 2, 2, 2, 148, 1036, 3, 2,
	2, 2, 150, 1040, 3, 2, 2, 2, 152, 1046, 3, 2, 2, 2, 154, 1050, 3, 2, 2,
	2, 156, 1053, 3, 2, 2, 2, 158, 1057, 3, 2, 2, 2, 160, 1062, 3, 2, 2, 2,
	162, 1066, 3, 2, 2, 2, 164, 1078, 3, 2, 2, 2, 166, 1086, 3, 2, 2, 2, 168,
	1202, 3, 2, 2, 2, 170, 1261, 3, 2, 2, 2, 172, 1266, 3, 2, 2, 2, 174, 1268,
	3, 2, 2, 2, 176, 1274, 3, 2, 2, 2, 178, 1297, 3, 2, 2, 2, 180, 1299, 3,
	2, 2, 2, 182, 1312, 3, 2, 2, 2, 184, 1321, 3, 2, 2, 2, 186, 1332, 3, 2,
	2, 2, 188, 1334, 3, 2, 2, 2, 190, 1343, 3, 2, 2, 2, 192, 1350, 3, 2, 2,
	2, 194, 1358, 3, 2, 2, 2, 196, 1366, 3, 2, 2, 2, 198, 1386, 3, 2, 2, 2,
	200, 1409, 3, 2, 2, 2, 202, 1411, 3, 2, 2, 2, 204, 1419, 3, 2, 2, 2, 206,
	1429, 3, 2, 2, 2, 208, 1435, 3, 2, 2, 2, 210, 1437, 3, 2, 2, 2, 212, 1454,
	3, 2, 2, 2, 214, 1456, 3, 2, 2, 2, 216, 1479, 3, 2, 2, 2, 218, 1483, 3,
	2, 2, 2, 220, 1485, 3, 2, 2, 2, 222, 1499, 3, 2, 2, 2, 224, 1507, 3, 2,
	2, 2, 226, 1512, 3, 2, 2, 2, 228, 1518, 3, 2, 2, 2, 230, 1521, 3, 2, 2,
	2, 232, 1539, 3, 2, 2, 2, 234, 1543, 3, 2, 2, 2, 236, 1550, 3, 2, 2, 2,
	238, 1561, 3, 2, 2, 2, 240, 1587, 3, 2, 2, 2, 242, 1590, 3, 2, 2, 2, 244,
	1607, 3, 2, 2, 2, 246, 1609, 3, 2, 2, 2, 248, 1611, 3, 2, 2, 2, 250, 1613,
	3, 2, 2, 2, 252, 1615, 3, 2, 2, 2, 254, 1617, 3, 2, 2, 2, 256, 1619, 3,
	2, 2, 2, 258, 1621, 3, 2, 2, 2, 260, 262, 7, 12, 2, 2, 261, 260, 3, 2,
	2, 2, 261, 262, 3, 2, 2, 2, 262, 266, 3, 2, 2, 2, 263, 265, 5, 4, 3, 2,
	264, 263, 3, 2, 2, 2, 265, 268, 3, 2, 2, 2, 266, 264, 3, 2, 2, 2, 266,
	267, 3, 2, 2, 2, 267, 269, 3, 2, 2, 2, 268, 266, 3, 2, 2, 2, 269, 270,
	7, 2, 2, 3, 270, 3, 3, 2, 2, 2, 271, 275, 5, 6, 4, 2, 272, 275, 5, 12,
	7, 2, 273, 275, 5, 10, 6, 2, 274, 271, 3, 2, 2, 2, 274, 272, 3, 2, 2, 2,
	274, 273, 3, 2, 2, 2, 275, 5, 3, 2, 2, 2, 276, 278, 5, 8, 5, 2, 277, 276,
	3, 2, 2, 2, 278, 279, 3, 2, 2, 2, 279, 277, 3, 2, 2, 2, 279, 280, 3, 2,
	2, 2, 280, 7, 3, 2, 2, 2, 281, 310, 7, 10, 2, 2, 282, 310, 7, 7, 2, 2,
	283, 310, 7, 17, 2, 2, 284, 310, 7, 8, 2, 2, 285, 310, 7, 11, 2, 2, 286,
	310, 7, 26, 2, 2, 287, 310, 7, 18, 2, 2, 288, 310, 7, 19, 2, 2, 289, 310,
	7, 4, 2, 2, 290, 310, 7, 20, 2, 2, 291, 310, 7, 21, 2, 2, 292, 310, 7,
	29, 2, 2, 293, 310, 7, 22, 2, 2, 294, 310, 7, 33, 2, 2, 295, 310, 7, 23,
	2, 2, 296, 310, 7, 24, 2, 2, 297, 310, 7, 30, 2, 2, 298, 310, 7, 34, 2,
	2, 299, 310, 7, 39, 2, 2, 300, 310, 7, 37, 2, 2, 301, 305, 7, 5, 2, 2,
	302, 304, 7, 14, 2, 2, 303, 302, 3, 2, 2, 2, 304, 307, 3, 2, 2, 2, 305,
	303, 3, 2, 2, 2, 305, 306, 3, 2, 2, 2, 306, 308, 3, 2, 2, 2, 307, 305,
	3, 2, 2, 2, 308, 310, 7, 15, 2, 2, 309, 281, 3, 2, 2, 2, 309, 282, 3, 2,
	2, 2, 309, 283, 3, 2, 2, 2, 309, 284, 3, 2, 2, 2, 309, 285, 3, 2, 2, 2,
	309, 286, 3, 2, 2, 2, 309, 287, 3, 2, 2, 2, 309, 288, 3, 2, 2, 2, 309,
	289, 3, 2, 2, 2, 309, 290, 3, 2, 2, 2, 309, 291, 3, 2, 2, 2, 309, 292,
	3, 2, 2, 2, 309, 293, 3, 2, 2, 2, 309, 294, 3, 2, 2, 2, 309, 295, 3, 2,
	2, 2, 309, 296, 3, 2, 2, 2, 309, 297, 3, 2, 2, 2, 309, 298, 3, 2, 2, 2,
	309, 299, 3, 2, 2, 2, 309, 300, 3, 2, 2, 2, 309, 301, 3, 2, 2, 2, 310,
	9, 3, 2, 2, 2, 311, 313, 7, 36, 2, 2, 312, 311, 3, 2, 2, 2, 313, 314, 3,
	2, 2, 2, 314, 312, 3, 2, 2, 2, 314, 315, 3, 2, 2, 2, 315, 11, 3, 2, 2,
	2, 316, 318, 5, 14, 8, 2, 317, 316, 3, 2, 2, 2, 318, 321, 3, 2, 2, 2, 319,
	317, 3, 2, 2, 2, 319, 320, 3, 2, 2, 2, 320, 323, 3, 2, 2, 2, 321, 319,
	3, 2, 2, 2, 322, 324, 5, 16, 9, 2, 323, 322, 3, 2, 2, 2, 324, 325, 3, 2,
	2, 2, 325, 323, 3, 2, 2, 2, 325, 326, 3, 2, 2, 2, 326, 13, 3, 2, 2, 2,
	327, 328, 7, 87, 2, 2, 328, 329, 7, 102, 2, 2, 329, 330, 5, 192, 97, 2,
	330, 331, 7, 210, 2, 2, 331, 15, 3, 2, 2, 2, 332, 339, 5, 64, 33, 2, 333,
	339, 5, 18, 10, 2, 334, 339, 5, 24, 13, 2, 335, 339, 5, 28, 15, 2, 336,
	339, 5, 30, 16, 2, 337, 339, 5, 162, 82, 2, 338, 332, 3, 2, 2, 2, 338,
	333, 3, 2, 2, 2, 338, 334, 3, 2, 2, 2, 338, 335, 3, 2, 2, 2, 338, 336,
	3, 2, 2, 2, 338, 337, 3, 2, 2, 2, 339, 17, 3, 2, 2, 2, 340, 342, 7, 126,
	2, 2, 341, 343, 9, 2, 2, 2, 342, 341, 3, 2, 2, 2, 342, 343, 3, 2, 2, 2,
	343, 344, 3, 2, 2, 2, 344, 345, 5, 20, 11, 2, 345, 346, 7, 210, 2, 2, 346,
	19, 3, 2, 2, 2, 347, 349, 7, 184, 2, 2, 348, 347, 3, 2, 2, 2, 348, 349,
	3, 2, 2, 2, 349, 350, 3, 2, 2, 2, 350, 358, 5, 22, 12, 2, 351, 353, 7,
	208, 2, 2, 352, 354, 7, 184, 2, 2, 353, 352, 3, 2, 2, 2, 353, 354, 3, 2,
	2, 2, 354, 355, 3, 2, 2, 2, 355, 357, 5, 22, 12, 2, 356, 351, 3, 2, 2,
	2, 357, 360, 3, 2, 2, 2, 358, 356, 3, 2, 2, 2, 358, 359, 3, 2, 2, 2, 359,
	21, 3, 2, 2, 2, 360, 358, 3, 2, 2, 2, 361, 364, 5, 192, 97, 2, 362, 363,
	7, 47, 2, 2, 363, 365, 5, 248, 125, 2, 364, 362, 3, 2, 2, 2, 364, 365,
	3, 2, 2, 2, 365, 23, 3, 2, 2, 2, 366, 381, 7, 102, 2, 2, 367, 369, 5, 192,
	97, 2, 368, 367, 3, 2, 2, 2, 368, 369, 3, 2, 2, 2, 369, 370, 3, 2, 2, 2,
	370, 374, 7, 206, 2, 2, 371, 373, 5, 26, 14, 2, 372, 371, 3, 2, 2, 2, 373,
	376, 3, 2, 2, 2, 374, 372, 3, 2, 2, 2, 374, 375, 3, 2, 2, 2, 375, 377,
	3, 2, 2, 2, 376, 374, 3, 2, 2, 2, 377, 382, 7, 207, 2, 2, 378, 379, 5,
	192, 97, 2, 379, 380, 7, 210, 2, 2, 380, 382, 3, 2, 2, 2, 381, 368, 3,
	2, 2, 2, 381, 378, 3, 2, 2, 2, 382, 25, 3, 2, 2, 2, 383, 389, 5, 64, 33,
	2, 384, 389, 5, 18, 10, 2, 385, 389, 5, 28, 15, 2, 386, 389, 5, 30, 16,
	2, 387, 389, 5, 162, 82, 2, 388, 383, 3, 2, 2, 2, 388, 384, 3, 2, 2, 2,
	388, 385, 3, 2, 2, 2, 388, 386, 3, 2, 2, 2, 388, 387, 3, 2, 2, 2, 389,
	27, 3, 2, 2, 2, 390, 391, 5, 48, 25, 2, 391, 393, 7, 82, 2, 2, 392, 394,
	7, 188, 2, 2, 393, 392, 3, 2, 2, 2, 393, 394, 3, 2, 2, 2, 394, 395, 3,
	2, 2, 2, 395, 397, 5, 248, 125, 2, 396, 398, 5, 36, 19, 2, 397, 396, 3,
	2, 2, 2, 397, 398, 3, 2, 2, 2, 398, 399, 3, 2, 2, 2, 399, 400, 7, 202,
	2, 2, 400, 401, 5, 124, 63, 2, 401, 402, 7, 203, 2, 2, 402, 403, 5, 68,
	35, 2, 403, 29, 3, 2, 2, 2, 404, 406, 5, 48, 25, 2, 405, 407, 7, 109, 2,
	2, 406, 405, 3, 2, 2, 2, 406, 407, 3, 2, 2, 2, 407, 409, 3, 2, 2, 2, 408,
	410, 5, 246, 124, 2, 409, 408, 3, 2, 2, 2, 409, 410, 3, 2, 2, 2, 410, 412,
	3, 2, 2, 2, 411, 413, 7, 107, 2, 2, 412, 411, 3, 2, 2, 2, 412, 413, 3,
	2, 2, 2, 413, 436, 3, 2, 2, 2, 414, 415, 5, 32, 17, 2, 415, 417, 5, 248,
	125, 2, 416, 418, 5, 36, 19, 2, 417, 416, 3, 2, 2, 2, 417, 418, 3, 2, 2,
	2, 418, 421, 3, 2, 2, 2, 419, 420, 7, 76, 2, 2, 420, 422, 5, 184, 93, 2,
	421, 419, 3, 2, 2, 2, 421, 422, 3, 2, 2, 2, 422, 425, 3, 2, 2, 2, 423,
	424, 7, 86, 2, 2, 424, 426, 5, 34, 18, 2, 425, 423, 3, 2, 2, 2, 425, 426,
	3, 2, 2, 2, 426, 437, 3, 2, 2, 2, 427, 428, 7, 96, 2, 2, 428, 430, 5, 248,
	125, 2, 429, 431, 5, 36, 19, 2, 430, 429, 3, 2, 2, 2, 430, 431, 3, 2, 2,
	2, 431, 434, 3, 2, 2, 2, 432, 433, 7, 76, 2, 2, 433, 435, 5, 34, 18, 2,
	434, 432, 3, 2, 2, 2, 434, 435, 3, 2, 2, 2, 435, 437, 3, 2, 2, 2, 436,
	414, 3, 2, 2, 2, 436, 427, 3, 2, 2, 2, 437, 438, 3, 2, 2, 2, 438, 442,
	7, 206, 2, 2, 439, 441, 5, 138, 70, 2, 440, 439, 3, 2, 2, 2, 441, 444,
	3, 2, 2, 2, 442, 440, 3, 2, 2, 2, 442, 443, 3, 2, 2, 2, 443, 445, 3, 2,
	2, 2, 444, 442, 3, 2, 2, 2, 445, 446, 7, 207, 2, 2, 446, 31, 3, 2, 2, 2,
	447, 448, 9, 3, 2, 2, 448, 33, 3, 2, 2, 2, 449, 454, 5, 184, 93, 2, 450,
	451, 7, 208, 2, 2, 451, 453, 5, 184, 93, 2, 452, 450, 3, 2, 2, 2, 453,
	456, 3, 2, 2, 2, 454, 452, 3, 2, 2, 2, 454, 455, 3, 2, 2, 2, 455, 35, 3,
	2, 2, 2, 456, 454, 3, 2, 2, 2, 457, 458, 7, 154, 2, 2, 458, 459, 5, 38,
	20, 2, 459, 460, 7, 155, 2, 2, 460, 472, 3, 2, 2, 2, 461, 462, 7, 154,
	2, 2, 462, 463, 5, 40, 21, 2, 463, 464, 7, 155, 2, 2, 464, 472, 3, 2, 2,
	2, 465, 466, 7, 154, 2, 2, 466, 467, 5, 38, 20, 2, 467, 468, 7, 208, 2,
	2, 468, 469, 5, 40, 21, 2, 469, 470, 7, 155, 2, 2, 470, 472, 3, 2, 2, 2,
	471, 457, 3, 2, 2, 2, 471, 461, 3, 2, 2, 2, 471, 465, 3, 2, 2, 2, 472,
	37, 3, 2, 2, 2, 473, 478, 5, 42, 22, 2, 474, 475, 7, 208, 2, 2, 475, 477,
	5, 42, 22, 2, 476, 474, 3, 2, 2, 2, 477, 480, 3, 2, 2, 2, 478, 476, 3,
	2, 2, 2, 478, 479, 3, 2, 2, 2, 479, 39, 3, 2, 2, 2, 480, 478, 3, 2, 2,
	2, 481, 486, 5, 44, 23, 2, 482, 483, 7, 208, 2, 2, 483, 485, 5, 44, 23,
	2, 484, 482, 3, 2, 2, 2, 485, 488, 3, 2, 2, 2, 486, 484, 3, 2, 2, 2, 486,
	487, 3, 2, 2, 2, 487, 41, 3, 2, 2, 2, 488, 486, 3, 2, 2, 2, 489, 490, 5,
	48, 25, 2, 490, 491, 5, 248, 125, 2, 491, 43, 3, 2, 2, 2, 492, 493, 5,
	48, 25, 2, 493, 494, 5, 248, 125, 2, 494, 497, 7, 211, 2, 2, 495, 498,
	5, 184, 93, 2, 496, 498, 5, 256, 129, 2, 497, 495, 3, 2, 2, 2, 497, 496,
	3, 2, 2, 2, 498, 45, 3, 2, 2, 2, 499, 500, 7, 154, 2, 2, 500, 505, 5, 186,
	94, 2, 501, 502, 7, 208, 2, 2, 502, 504, 5, 186, 94, 2, 503, 501, 3, 2,
	2, 2, 504, 507, 3, 2, 2, 2, 505, 503, 3, 2, 2, 2, 505, 506, 3, 2, 2, 2,
	506, 508, 3, 2, 2, 2, 507, 505, 3, 2, 2, 2, 508, 509, 7, 155, 2, 2, 509,
	47, 3, 2, 2, 2, 510, 512, 5, 50, 26, 2, 511, 510, 3, 2, 2, 2, 512, 515,
	3, 2, 2, 2, 513, 511, 3, 2, 2, 2, 513, 514, 3, 2, 2, 2, 514, 49, 3, 2,
	2, 2, 515, 513, 3, 2, 2, 2, 516, 520, 7, 204, 2, 2, 517, 518, 5, 248, 125,
	2, 518, 519, 7, 209, 2, 2, 519, 521, 3, 2, 2, 2, 520, 517, 3, 2, 2, 2,
	520, 521, 3, 2, 2, 2, 521, 522, 3, 2, 2, 2, 522, 527, 5, 52, 27, 2, 523,
	524, 7, 208, 2, 2, 524, 526, 5, 52, 27, 2, 525, 523, 3, 2, 2, 2, 526, 529,
	3, 2, 2, 2, 527, 525, 3, 2, 2, 2, 527, 528, 3, 2, 2, 2, 528, 530, 3, 2,
	2, 2, 529, 527, 3, 2, 2, 2, 530, 531, 7, 205, 2, 2, 531, 51, 3, 2, 2, 2,
	532, 551, 5, 190, 96, 2, 533, 534, 5, 190, 96, 2, 534, 535, 7, 202, 2,
	2, 535, 536, 5, 54, 28, 2, 536, 537, 7, 203, 2, 2, 537, 551, 3, 2, 2, 2,
	538, 539, 5, 190, 96, 2, 539, 540, 7, 202, 2, 2, 540, 541, 5, 56, 29, 2,
	541, 542, 7, 203, 2, 2, 542, 551, 3, 2, 2, 2, 543, 544, 5, 190, 96, 2,
	544, 545, 7, 202, 2, 2, 545, 546, 5, 54, 28, 2, 546, 547, 7, 208, 2, 2,
	547, 548, 5, 56, 29, 2, 548, 549, 7, 203, 2, 2, 549, 551, 3, 2, 2, 2, 550,
	532, 3, 2, 2, 2, 550, 533, 3, 2, 2, 2, 550, 538, 3, 2, 2, 2, 550, 543,
	3, 2, 2, 2, 551, 53, 3, 2, 2, 2, 552, 557, 5, 168, 85, 2, 553, 554, 7,
	208, 2, 2, 554, 556, 5, 168, 85, 2, 555, 553, 3, 2, 2, 2, 556, 559, 3,
	2, 2, 2, 557, 555, 3, 2, 2, 2, 557, 558, 3, 2, 2, 2, 558, 55, 3, 2, 2,
	2, 559, 557, 3, 2, 2, 2, 560, 565, 5, 58, 30, 2, 561, 562, 7, 208, 2, 2,
	562, 564, 5, 58, 30, 2, 563, 561, 3, 2, 2, 2, 564, 567, 3, 2, 2, 2, 565,
	563, 3, 2, 2, 2, 565, 566, 3, 2, 2, 2, 566, 57, 3, 2, 2, 2, 567, 565, 3,
	2, 2, 2, 568, 569, 7, 214, 2, 2, 569, 570, 7, 156, 2, 2, 570, 571, 5, 168,
	85, 2, 571, 59, 3, 2, 2, 2, 572, 574, 5, 62, 32, 2, 573, 572, 3, 2, 2,
	2, 574, 577, 3, 2, 2, 2, 575, 573, 3, 2, 2, 2, 575, 576, 3, 2, 2, 2, 576,
	61, 3, 2, 2, 2, 577, 575, 3, 2, 2, 2, 578, 582, 5, 64, 33, 2, 579, 582,
	5, 28, 15, 2, 580, 582, 5, 30, 16, 2, 581, 578, 3, 2, 2, 2, 581, 579, 3,
	2, 2, 2, 581, 580, 3, 2, 2, 2, 582, 63, 3, 2, 2, 2, 583, 584, 5, 248, 125,
	2, 584, 585, 7, 209, 2, 2, 585, 611, 3, 2, 2, 2, 586, 611, 5, 68, 35, 2,
	587, 611, 5, 70, 36, 2, 588, 611, 5, 80, 41, 2, 589, 611, 5, 82, 42, 2,
	590, 611, 5, 84, 43, 2, 591, 611, 5, 90, 46, 2, 592, 611, 5, 94, 48, 2,
	593, 611, 5, 96, 49, 2, 594, 611, 5, 98, 50, 2, 595, 596, 5, 174, 88, 2,
	596, 597, 7, 210, 2, 2, 597, 611, 3, 2, 2, 2, 598, 611, 5, 130, 66, 2,
	599, 611, 5, 136, 69, 2, 600, 611, 5, 134, 68, 2, 601, 611, 5, 100, 51,
	2, 602, 611, 5, 102, 52, 2, 603, 611, 5, 104, 53, 2, 604, 611, 5, 106,
	54, 2, 605, 611, 5, 112, 57, 2, 606, 611, 5, 114, 58, 2, 607, 611, 5, 116,
	59, 2, 608, 611, 5, 66, 34, 2, 609, 611, 5, 118, 60, 2, 610, 583, 3, 2,
	2, 2, 610, 586, 3, 2, 2, 2, 610, 587, 3, 2, 2, 2, 610, 588, 3, 2, 2, 2,
	610, 589, 3, 2, 2, 2, 610, 590, 3, 2, 2, 2, 610, 591, 3, 2, 2, 2, 610,
	592, 3, 2, 2, 2, 610, 593, 3, 2, 2, 2, 610, 594, 3, 2, 2, 2, 610, 595,
	3, 2, 2, 2, 610, 598, 3, 2, 2, 2, 610, 599, 3, 2, 2, 2, 610, 600, 3, 2,
	2, 2, 610, 601, 3, 2, 2, 2, 610, 602, 3, 2, 2, 2, 610, 603, 3, 2, 2, 2,
	610, 604, 3, 2, 2, 2, 610, 605, 3, 2, 2, 2, 610, 606, 3, 2, 2, 2, 610,
	607, 3, 2, 2, 2, 610, 608, 3, 2, 2, 2, 610, 609, 3, 2, 2, 2, 611, 65, 3,
	2, 2, 2, 612, 613, 7, 210, 2, 2, 613, 67, 3, 2, 2, 2, 614, 615, 7, 206,
	2, 2, 615, 616, 5, 60, 31, 2, 616, 617, 7, 207, 2, 2, 617, 69, 3, 2, 2,
	2, 618, 619, 7, 85, 2, 2, 619, 620, 5, 166, 84, 2, 620, 624, 5, 64, 33,
	2, 621, 623, 5, 72, 37, 2, 622, 621, 3, 2, 2, 2, 623, 626, 3, 2, 2, 2,
	624, 622, 3, 2, 2, 2, 624, 625, 3, 2, 2, 2, 625, 628, 3, 2, 2, 2, 626,
	624, 3, 2, 2, 2, 627, 629, 5, 76, 39, 2, 628, 627, 3, 2, 2, 2, 628, 629,
	3, 2, 2, 2, 629, 647, 3, 2, 2, 2, 630, 631, 7, 85, 2, 2, 631, 632, 5, 166,
	84, 2, 632, 633, 7, 209, 2, 2, 633, 637, 5, 60, 31, 2, 634, 636, 5, 74,
	38, 2, 635, 634, 3, 2, 2, 2, 636, 639, 3, 2, 2, 2, 637, 635, 3, 2, 2, 2,
	637, 638, 3, 2, 2, 2, 638, 641, 3, 2, 2, 2, 639, 637, 3, 2, 2, 2, 640,
	642, 5, 78, 40, 2, 641, 640, 3, 2, 2, 2, 641, 642, 3, 2, 2, 2, 642, 643,
	3, 2, 2, 2, 643, 644, 7, 71, 2, 2, 644, 645, 7, 210, 2, 2, 645, 647, 3,
	2, 2, 2, 646, 618, 3, 2, 2, 2, 646, 630, 3, 2, 2, 2, 647, 71, 3, 2, 2,
	2, 648, 649, 7, 66, 2, 2, 649, 650, 5, 166, 84, 2, 650, 651, 5, 64, 33,
	2, 651, 73, 3, 2, 2, 2, 652, 653, 7, 66, 2, 2, 653, 654, 5, 166, 84, 2,
	654, 655, 7, 209, 2, 2, 655, 656, 5, 60, 31, 2, 656, 75, 3, 2, 2, 2, 657,
	658, 7, 65, 2, 2, 658, 659, 5, 64, 33, 2, 659, 77, 3, 2, 2, 2, 660, 661,
	7, 65, 2, 2, 661, 662, 7, 209, 2, 2, 662, 663, 5, 60, 31, 2, 663, 79, 3,
	2, 2, 2, 664, 665, 7, 128, 2, 2, 665, 672, 5, 166, 84, 2, 666, 673, 5,
	64, 33, 2, 667, 668, 7, 209, 2, 2, 668, 669, 5, 60, 31, 2, 669, 670, 7,
	73, 2, 2, 670, 671, 7, 210, 2, 2, 671, 673, 3, 2, 2, 2, 672, 666, 3, 2,
	2, 2, 672, 667, 3, 2, 2, 2, 673, 81, 3, 2, 2, 2, 674, 675, 7, 61, 2, 2,
	675, 676, 5, 64, 33, 2, 676, 677, 7, 128, 2, 2, 677, 678, 5, 166, 84, 2,
	678, 679, 7, 210, 2, 2, 679, 83, 3, 2, 2, 2, 680, 681, 7, 80, 2, 2, 681,
	683, 7, 202, 2, 2, 682, 684, 5, 86, 44, 2, 683, 682, 3, 2, 2, 2, 683, 684,
	3, 2, 2, 2, 684, 685, 3, 2, 2, 2, 685, 687, 7, 210, 2, 2, 686, 688, 5,
	164, 83, 2, 687, 686, 3, 2, 2, 2, 687, 688, 3, 2, 2, 2, 688, 689, 3, 2,
	2, 2, 689, 691, 7, 210, 2, 2, 690, 692, 5, 88, 45, 2, 691, 690, 3, 2, 2,
	2, 691, 692, 3, 2, 2, 2, 692, 693, 3, 2, 2, 2, 693, 700, 7, 203, 2, 2,
	694, 701, 5, 64, 33, 2, 695, 696, 7, 209, 2, 2, 696, 697, 5, 60, 31, 2,
	697, 698, 7, 69, 2, 2, 698, 699, 7, 210, 2, 2, 699, 701, 3, 2, 2, 2, 700,
	694, 3, 2, 2, 2, 700, 695, 3, 2, 2, 2, 701, 85, 3, 2, 2, 2, 702, 703, 5,
	164, 83, 2, 703, 87, 3, 2, 2, 2, 704, 705, 5, 164, 83, 2, 705, 89, 3, 2,
	2, 2, 706, 707, 7, 118, 2, 2, 707, 731, 5, 166, 84, 2, 708, 710, 7, 206,
	2, 2, 709, 711, 7, 210, 2, 2, 710, 709, 3, 2, 2, 2, 710, 711, 3, 2, 2,
	2, 711, 715, 3, 2, 2, 2, 712, 714, 5, 92, 47, 2, 713, 712, 3, 2, 2, 2,
	714, 717, 3, 2, 2, 2, 715, 713, 3, 2, 2, 2, 715, 716, 3, 2, 2, 2, 716,
	718, 3, 2, 2, 2, 717, 715, 3, 2, 2, 2, 718, 732, 7, 207, 2, 2, 719, 721,
	7, 209, 2, 2, 720, 722, 7, 210, 2, 2, 721, 720, 3, 2, 2, 2, 721, 722, 3,
	2, 2, 2, 722, 726, 3, 2, 2, 2, 723, 725, 5, 92, 47, 2, 724, 723, 3, 2,
	2, 2, 725, 728, 3, 2, 2, 2, 726, 724, 3, 2, 2, 2, 726, 727, 3, 2, 2, 2,
	727, 729, 3, 2, 2, 2, 728, 726, 3, 2, 2, 2, 729, 730, 7, 72, 2, 2, 730,
	732, 7, 210, 2, 2, 731, 708, 3, 2, 2, 2, 731, 719, 3, 2, 2, 2, 732, 91,
	3, 2, 2, 2, 733, 734, 7, 53, 2, 2, 734, 737, 5, 168, 85, 2, 735, 737, 7,
	60, 2, 2, 736, 733, 3, 2, 2, 2, 736, 735, 3, 2, 2, 2, 737, 738, 3, 2, 2,
	2, 738, 740, 9, 4, 2, 2, 739, 736, 3, 2, 2, 2, 740, 741, 3, 2, 2, 2, 741,
	739, 3, 2, 2, 2, 741, 742, 3, 2, 2, 2, 742, 743, 3, 2, 2, 2, 743, 744,
	5, 60, 31, 2, 744, 93, 3, 2, 2, 2, 745, 747, 7, 51, 2, 2, 746, 748, 5,
	168, 85, 2, 747, 746, 3, 2, 2, 2, 747, 748, 3, 2, 2, 2, 748, 749, 3, 2,
	2, 2, 749, 750, 7, 210, 2, 2, 750, 95, 3, 2, 2, 2, 751, 753, 7, 58, 2,
	2, 752, 754, 5, 168, 85, 2, 753, 752, 3, 2, 2, 2, 753, 754, 3, 2, 2, 2,
	754, 755, 3, 2, 2, 2, 755, 756, 7, 210, 2, 2, 756, 97, 3, 2, 2, 2, 757,
	759, 7, 115, 2, 2, 758, 760, 5, 168, 85, 2, 759, 758, 3, 2, 2, 2, 759,
	760, 3, 2, 2, 2, 760, 761, 3, 2, 2, 2, 761, 762, 7, 210, 2, 2, 762, 99,
	3, 2, 2, 2, 763, 764, 5, 168, 85, 2, 764, 765, 7, 210, 2, 2, 765, 101,
	3, 2, 2, 2, 766, 767, 7, 125, 2, 2, 767, 768, 7, 202, 2, 2, 768, 769, 5,
	220, 111, 2, 769, 770, 7, 203, 2, 2, 770, 771, 7, 210, 2, 2, 771, 103,
	3, 2, 2, 2, 772, 811, 7, 81, 2, 2, 773, 774, 7, 202, 2, 2, 774, 775, 5,
	222, 112, 2, 775, 777, 7, 47, 2, 2, 776, 778, 7, 188, 2, 2, 777, 776, 3,
	2, 2, 2, 777, 778, 3, 2, 2, 2, 778, 779, 3, 2, 2, 2, 779, 785, 5, 222,
	112, 2, 780, 782, 7, 156, 2, 2, 781, 783, 7, 188, 2, 2, 782, 781, 3, 2,
	2, 2, 782, 783, 3, 2, 2, 2, 783, 784, 3, 2, 2, 2, 784, 786, 5, 222, 112,
	2, 785, 780, 3, 2, 2, 2, 785, 786, 3, 2, 2, 2, 786, 787, 3, 2, 2, 2, 787,
	788, 7, 203, 2, 2, 788, 812, 3, 2, 2, 2, 789, 790, 7, 202, 2, 2, 790, 791,
	5, 168, 85, 2, 791, 792, 7, 47, 2, 2, 792, 798, 5, 222, 112, 2, 793, 795,
	7, 156, 2, 2, 794, 796, 7, 188, 2, 2, 795, 794, 3, 2, 2, 2, 795, 796, 3,
	2, 2, 2, 796, 797, 3, 2, 2, 2, 797, 799, 5, 222, 112, 2, 798, 793, 3, 2,
	2, 2, 798, 799, 3, 2, 2, 2, 799, 800, 3, 2, 2, 2, 800, 801, 7, 203, 2,
	2, 801, 812, 3, 2, 2, 2, 802, 803, 7, 202, 2, 2, 803, 804, 5, 222, 112,
	2, 804, 805, 7, 47, 2, 2, 805, 806, 7, 98, 2, 2, 806, 807, 7, 202, 2, 2,
	807, 808, 5, 242, 122, 2, 808, 809, 7, 203, 2, 2, 809, 810, 7, 203, 2,
	2, 810, 812, 3, 2, 2, 2, 811, 773, 3, 2, 2, 2, 811, 789, 3, 2, 2, 2, 811,
	802, 3, 2, 2, 2, 812, 819, 3, 2, 2, 2, 813, 820, 5, 64, 33, 2, 814, 815,
	7, 209, 2, 2, 815, 816, 5, 60, 31, 2, 816, 817, 7, 70, 2, 2, 817, 818,
	7, 210, 2, 2, 818, 820, 3, 2, 2, 2, 819, 813, 3, 2, 2, 2, 819, 814, 3,
	2, 2, 2, 820, 105, 3, 2, 2, 2, 821, 822, 7, 121, 2, 2, 822, 838, 5, 68,
	35, 2, 823, 825, 5, 108, 55, 2, 824, 823, 3, 2, 2, 2, 825, 826, 3, 2, 2,
	2, 826, 824, 3, 2, 2, 2, 826, 827, 3, 2, 2, 2, 827, 829, 3, 2, 2, 2, 828,
	830, 5, 110, 56, 2, 829, 828, 3, 2, 2, 2, 829, 830, 3, 2, 2, 2, 830, 839,
	3, 2, 2, 2, 831, 833, 5, 108, 55, 2, 832, 831, 3, 2, 2, 2, 833, 836, 3,
	2, 2, 2, 834, 832, 3, 2, 2, 2, 834, 835, 3, 2, 2, 2, 835, 837, 3, 2, 2,
	2, 836, 834, 3, 2, 2, 2, 837, 839, 5, 110, 56, 2, 838, 824, 3, 2, 2, 2,
	838, 834, 3, 2, 2, 2, 839, 107, 3, 2, 2, 2, 840, 841, 7, 54, 2, 2, 841,
	842, 7, 202, 2, 2, 842, 843, 5, 184, 93, 2, 843, 844, 7, 214, 2, 2, 844,
	845, 7, 203, 2, 2, 845, 846, 5, 68, 35, 2, 846, 109, 3, 2, 2, 2, 847, 848,
	7, 78, 2, 2, 848, 849, 5, 68, 35, 2, 849, 111, 3, 2, 2, 2, 850, 851, 7,
	119, 2, 2, 851, 852, 5, 168, 85, 2, 852, 853, 7, 210, 2, 2, 853, 113, 3,
	2, 2, 2, 854, 855, 7, 84, 2, 2, 855, 856, 5, 248, 125, 2, 856, 857, 7,
	210, 2, 2, 857, 115, 3, 2, 2, 2, 858, 859, 7, 59, 2, 2, 859, 860, 7, 202,
	2, 2, 860, 861, 5, 122, 62, 2, 861, 868, 7, 203, 2, 2, 862, 869, 5, 64,
	33, 2, 863, 864, 7, 209, 2, 2, 864, 865, 5, 60, 31, 2, 865, 866, 7, 68,
	2, 2, 866, 867, 7, 210, 2, 2, 867, 869, 3, 2, 2, 2, 868, 862, 3, 2, 2,
	2, 868, 863, 3, 2, 2, 2, 869, 117, 3, 2, 2, 2, 870, 872, 5, 120, 61, 2,
	871, 870, 3, 2, 2, 2, 872, 873, 3, 2, 2, 2, 873, 871, 3, 2, 2, 2, 873,
	874, 3, 2, 2, 2, 874, 119, 3, 2, 2, 2, 875, 878, 5, 6, 4, 2, 876, 878,
	5, 10, 6, 2, 877, 875, 3, 2, 2, 2, 877, 876, 3, 2, 2, 2, 878, 121, 3, 2,
	2, 2, 879, 884, 5, 160, 81, 2, 880, 881, 7, 208, 2, 2, 881, 883, 5, 160,
	81, 2, 882, 880, 3, 2, 2, 2, 883, 886, 3, 2, 2, 2, 884, 882, 3, 2, 2, 2,
	884, 885, 3, 2, 2, 2, 885, 123, 3, 2, 2, 2, 886, 884, 3, 2, 2, 2, 887,
	889, 5, 126, 64, 2, 888, 887, 3, 2, 2, 2, 888, 889, 3, 2, 2, 2, 889, 894,
	3, 2, 2, 2, 890, 891, 7, 208, 2, 2, 891, 893, 5, 126, 64, 2, 892, 890,
	3, 2, 2, 2, 893, 896, 3, 2, 2, 2, 894, 892, 3, 2, 2, 2, 894, 895, 3, 2,
	2, 2, 895, 125, 3, 2, 2, 2, 896, 894, 3, 2, 2, 2, 897, 899, 5, 48, 25,
	2, 898, 900, 5, 128, 65, 2, 899, 898, 3, 2, 2, 2, 899, 900, 3, 2, 2, 2,
	900, 902, 3, 2, 2, 2, 901, 903, 7, 188, 2, 2, 902, 901, 3, 2, 2, 2, 902,
	903, 3, 2, 2, 2, 903, 905, 3, 2, 2, 2, 904, 906, 7, 185, 2, 2, 905, 904,
	3, 2, 2, 2, 905, 906, 3, 2, 2, 2, 906, 907, 3, 2, 2, 2, 907, 908, 5, 158,
	80, 2, 908, 127, 3, 2, 2, 2, 909, 913, 5, 184, 93, 2, 910, 913, 7, 52,
	2, 2, 911, 913, 5, 256, 129, 2, 912, 909, 3, 2, 2, 2, 912, 910, 3, 2, 2,
	2, 912, 911, 3, 2, 2, 2, 913, 129, 3, 2, 2, 2, 914, 915, 7, 83, 2, 2, 915,
	920, 5, 132, 67, 2, 916, 917, 7, 208, 2, 2, 917, 919, 5, 132, 67, 2, 918,
	916, 3, 2, 2, 2, 919, 922, 3, 2, 2, 2, 920, 918, 3, 2, 2, 2, 920, 921,
	3, 2, 2, 2, 921, 923, 3, 2, 2, 2, 922, 920, 3, 2, 2, 2, 923, 924, 7, 210,
	2, 2, 924, 131, 3, 2, 2, 2, 925, 934, 7, 214, 2, 2, 926, 927, 7, 199, 2,
	2, 927, 934, 5, 222, 112, 2, 928, 929, 7, 199, 2, 2, 929, 930, 7, 206,
	2, 2, 930, 931, 5, 168, 85, 2, 931, 932, 7, 207, 2, 2, 932, 934, 3, 2,
	2, 2, 933, 925, 3, 2, 2, 2, 933, 926, 3, 2, 2, 2, 933, 928, 3, 2, 2, 2,
	934, 133, 3, 2, 2, 2, 935, 936, 7, 64, 2, 2, 936, 937, 5, 164, 83, 2, 937,
	938, 7, 210, 2, 2, 938, 135, 3, 2, 2, 2, 939, 940, 7, 116, 2, 2, 940, 945,
	5, 158, 80, 2, 941, 942, 7, 208, 2, 2, 942, 944, 5, 158, 80, 2, 943, 941,
	3, 2, 2, 2, 944, 947, 3, 2, 2, 2, 945, 943, 3, 2, 2, 2, 945, 946, 3, 2,
	2, 2, 946, 948, 3, 2, 2, 2, 947, 945, 3, 2, 2, 2, 948, 949, 7, 210, 2,
	2, 949, 137, 3, 2, 2, 2, 950, 951, 5, 48, 25, 2, 951, 952, 5, 154, 78,
	2, 952, 957, 5, 158, 80, 2, 953, 954, 7, 208, 2, 2, 954, 956, 5, 158, 80,
	2, 955, 953, 3, 2, 2, 2, 956, 959, 3, 2, 2, 2, 957, 955, 3, 2, 2, 2, 957,
	958, 3, 2, 2, 2, 958, 960, 3, 2, 2, 2, 959, 957, 3, 2, 2, 2, 960, 961,
	7, 210, 2, 2, 961, 999, 3, 2, 2, 2, 962, 963, 5, 48, 25, 2, 963, 964, 7,
	57, 2, 2, 964, 969, 5, 160, 81, 2, 965, 966, 7, 208, 2, 2, 966, 968, 5,
	160, 81, 2, 967, 965, 3, 2, 2, 2, 968, 971, 3, 2, 2, 2, 969, 967, 3, 2,
	2, 2, 969, 970, 3, 2, 2, 2, 970, 972, 3, 2, 2, 2, 971, 969, 3, 2, 2, 2,
	972, 973, 7, 210, 2, 2, 973, 999, 3, 2, 2, 2, 974, 976, 5, 48, 25, 2, 975,
	977, 5, 156, 79, 2, 976, 975, 3, 2, 2, 2, 976, 977, 3, 2, 2, 2, 977, 978,
	3, 2, 2, 2, 978, 980, 7, 82, 2, 2, 979, 981, 7, 188, 2, 2, 980, 979, 3,
	2, 2, 2, 980, 981, 3, 2, 2, 2, 981, 982, 3, 2, 2, 2, 982, 984, 5, 248,
	125, 2, 983, 985, 5, 36, 19, 2, 984, 983, 3, 2, 2, 2, 984, 985, 3, 2, 2,
	2, 985, 986, 3, 2, 2, 2, 986, 987, 7, 202, 2, 2, 987, 988, 5, 124, 63,
	2, 988, 990, 7, 203, 2, 2, 989, 991, 5, 150, 76, 2, 990, 989, 3, 2, 2,
	2, 990, 991, 3, 2, 2, 2, 991, 992, 3, 2, 2, 2, 992, 993, 5, 152, 77, 2,
	993, 999, 3, 2, 2, 2, 994, 995, 7, 126, 2, 2, 995, 996, 5, 194, 98, 2,
	996, 997, 5, 140, 71, 2, 997, 999, 3, 2, 2, 2, 998, 950, 3, 2, 2, 2, 998,
	962, 3, 2, 2, 2, 998, 974, 3, 2, 2, 2, 998, 994, 3, 2, 2, 2, 999, 139,
	3, 2, 2, 2, 1000, 1010, 7, 210, 2, 2, 1001, 1005, 7, 206, 2, 2, 1002, 1004,
	5, 142, 72, 2, 1003, 1002, 3, 2, 2, 2, 1004, 1007, 3, 2, 2, 2, 1005, 1003,
	3, 2, 2, 2, 1005, 1006, 3, 2, 2, 2, 1006, 1008, 3, 2, 2, 2, 1007, 1005,
	3, 2, 2, 2, 1008, 1010, 7, 207, 2, 2, 1009, 1000, 3, 2, 2, 2, 1009, 1001,
	3, 2, 2, 2, 1010, 141, 3, 2, 2, 2, 1011, 1014, 5, 144, 73, 2, 1012, 1014,
	5, 146, 74, 2, 1013, 1011, 3, 2, 2, 2, 1013, 1012, 3, 2, 2, 2, 1014, 143,
	3, 2, 2, 2, 1015, 1016, 5, 190, 96, 2, 1016, 1017, 7, 182, 2, 2, 1017,
	1018, 5, 248, 125, 2, 1018, 1019, 7, 91, 2, 2, 1019, 1020, 5, 194, 98,
	2, 1020, 1021, 7, 210, 2, 2, 1021, 145, 3, 2, 2, 2, 1022, 1023, 5, 148,
	75, 2, 1023, 1029, 7, 47, 2, 2, 1024, 1030, 5, 250, 126, 2, 1025, 1027,
	5, 250, 126, 2, 1026, 1025, 3, 2, 2, 2, 1026, 1027, 3, 2, 2, 2, 1027, 1028,
	3, 2, 2, 2, 1028, 1030, 5, 248, 125, 2, 1029, 1024, 3, 2, 2, 2, 1029, 1026,
	3, 2, 2, 2, 1030, 1031, 3, 2, 2, 2, 1031, 1032, 7, 210, 2, 2, 1032, 147,
	3, 2, 2, 2, 1033, 1034, 5, 190, 96, 2, 1034, 1035, 7, 182, 2, 2, 1035,
	1037, 3, 2, 2, 2, 1036, 1033, 3, 2, 2, 2, 1036, 1037, 3, 2, 2, 2, 1037,
	1038, 3, 2, 2, 2, 1038, 1039, 5, 248, 125, 2, 1039, 149, 3, 2, 2, 2, 1040,
	1041, 7, 209, 2, 2, 1041, 1042, 5, 248, 125, 2, 1042, 1043, 5, 196, 99,
	2, 1043, 151, 3, 2, 2, 2, 1044, 1047, 7, 210, 2, 2, 1045, 1047, 5, 68,
	35, 2, 1046, 1044, 3, 2, 2, 2, 1046, 1045, 3, 2, 2, 2, 1047, 153, 3, 2,
	2, 2, 1048, 1051, 5, 156, 79, 2, 1049, 1051, 7, 127, 2, 2, 1050, 1048,
	3, 2, 2, 2, 1050, 1049, 3, 2, 2, 2, 1051, 155, 3, 2, 2, 2, 1052, 1054,
	5, 250, 126, 2, 1053, 1052, 3, 2, 2, 2, 1054, 1055, 3, 2, 2, 2, 1055, 1053,
	3, 2, 2, 2, 1055, 1056, 3, 2, 2, 2, 1056, 157, 3, 2, 2, 2, 1057, 1060,
	7, 214, 2, 2, 1058, 1059, 7, 211, 2, 2, 1059, 1061, 5, 200, 101, 2, 1060,
	1058, 3, 2, 2, 2, 1060, 1061, 3, 2, 2, 2, 1061, 159, 3, 2, 2, 2, 1062,
	1063, 5, 248, 125, 2, 1063, 1064, 7, 211, 2, 2, 1064, 1065, 5, 200, 101,
	2, 1065, 161, 3, 2, 2, 2, 1066, 1067, 5, 48, 25, 2, 1067, 1068, 7, 57,
	2, 2, 1068, 1073, 5, 160, 81, 2, 1069, 1070, 7, 208, 2, 2, 1070, 1072,
	5, 160, 81, 2, 1071, 1069, 3, 2, 2, 2, 1072, 1075, 3, 2, 2, 2, 1073, 1071,
	3, 2, 2, 2, 1073, 1074, 3, 2, 2, 2, 1074, 1076, 3, 2, 2, 2, 1075, 1073,
	3, 2, 2, 2, 1076, 1077, 7, 210, 2, 2, 1077, 163, 3, 2, 2, 2, 1078, 1083,
	5, 168, 85, 2, 1079, 1080, 7, 208, 2, 2, 1080, 1082, 5, 168, 85, 2, 1081,
	1079, 3, 2, 2, 2, 1082, 1085, 3, 2, 2, 2, 1083, 1081, 3, 2, 2, 2, 1083,
	1084, 3, 2, 2, 2, 1084, 165, 3, 2, 2, 2, 1085, 1083, 3, 2, 2, 2, 1086,
	1089, 7, 202, 2, 2, 1087, 1090, 5, 168, 85, 2, 1088, 1090, 5, 174, 88,
	2, 1089, 1087, 3, 2, 2, 2, 1089, 1088, 3, 2, 2, 2, 1090, 1091, 3, 2, 2,
	2, 1091, 1092, 7, 203, 2, 2, 1092, 167, 3, 2, 2, 2, 1093, 1094, 8, 85,
	1, 2, 1094, 1095, 7, 56, 2, 2, 1095, 1203, 5, 168, 85, 45, 1096, 1203,
	5, 170, 86, 2, 1097, 1098, 5, 214, 108, 2, 1098, 1099, 7, 204, 2, 2, 1099,
	1100, 5, 168, 85, 2, 1100, 1101, 7, 205, 2, 2, 1101, 1203, 3, 2, 2, 2,
	1102, 1103, 7, 202, 2, 2, 1103, 1104, 5, 258, 130, 2, 1104, 1105, 7, 203,
	2, 2, 1105, 1106, 5, 168, 85, 42, 1106, 1203, 3, 2, 2, 2, 1107, 1108, 9,
	5, 2, 2, 1108, 1203, 5, 168, 85, 41, 1109, 1110, 9, 6, 2, 2, 1110, 1203,
	5, 168, 85, 40, 1111, 1112, 9, 7, 2, 2, 1112, 1203, 5, 222, 112, 2, 1113,
	1114, 5, 222, 112, 2, 1114, 1115, 9, 7, 2, 2, 1115, 1203, 3, 2, 2, 2, 1116,
	1117, 7, 108, 2, 2, 1117, 1203, 5, 168, 85, 37, 1118, 1203, 5, 222, 112,
	2, 1119, 1203, 5, 206, 104, 2, 1120, 1203, 5, 216, 109, 2, 1121, 1203,
	7, 215, 2, 2, 1122, 1203, 7, 221, 2, 2, 1123, 1203, 5, 166, 84, 2, 1124,
	1125, 7, 46, 2, 2, 1125, 1127, 7, 202, 2, 2, 1126, 1128, 5, 176, 89, 2,
	1127, 1126, 3, 2, 2, 2, 1127, 1128, 3, 2, 2, 2, 1128, 1129, 3, 2, 2, 2,
	1129, 1136, 7, 203, 2, 2, 1130, 1132, 7, 204, 2, 2, 1131, 1133, 5, 176,
	89, 2, 1132, 1131, 3, 2, 2, 2, 1132, 1133, 3, 2, 2, 2, 1133, 1134, 3, 2,
	2, 2, 1134, 1136, 7, 205, 2, 2, 1135, 1124, 3, 2, 2, 2, 1135, 1130, 3,
	2, 2, 2, 1136, 1141, 3, 2, 2, 2, 1137, 1138, 7, 204, 2, 2, 1138, 1139,
	5, 168, 85, 2, 1139, 1140, 7, 205, 2, 2, 1140, 1142, 3, 2, 2, 2, 1141,
	1137, 3, 2, 2, 2, 1141, 1142, 3, 2, 2, 2, 1142, 1203, 3, 2, 2, 2, 1143,
	1203, 7, 129, 2, 2, 1144, 1145, 7, 98, 2, 2, 1145, 1146, 7, 202, 2, 2,
	1146, 1147, 5, 242, 122, 2, 1147, 1148, 7, 203, 2, 2, 1148, 1149, 7, 211,
	2, 2, 1149, 1150, 5, 168, 85, 28, 1150, 1203, 3, 2, 2, 2, 1151, 1152, 7,
	97, 2, 2, 1152, 1153, 7, 202, 2, 2, 1153, 1154, 5, 220, 111, 2, 1154, 1155,
	7, 203, 2, 2, 1155, 1203, 3, 2, 2, 2, 1156, 1157, 7, 67, 2, 2, 1157, 1158,
	7, 202, 2, 2, 1158, 1159, 5, 222, 112, 2, 1159, 1160, 7, 203, 2, 2, 1160,
	1203, 3, 2, 2, 2, 1161, 1162, 7, 74, 2, 2, 1162, 1163, 7, 202, 2, 2, 1163,
	1164, 5, 168, 85, 2, 1164, 1165, 7, 203, 2, 2, 1165, 1203, 3, 2, 2, 2,
	1166, 1170, 7, 75, 2, 2, 1167, 1168, 7, 202, 2, 2, 1168, 1171, 7, 203,
	2, 2, 1169, 1171, 5, 166, 84, 2, 1170, 1167, 3, 2, 2, 2, 1170, 1169, 3,
	2, 2, 2, 1170, 1171, 3, 2, 2, 2, 1171, 1203, 3, 2, 2, 2, 1172, 1173, 9,
	8, 2, 2, 1173, 1203, 5, 168, 85, 23, 1174, 1175, 9, 9, 2, 2, 1175, 1203,
	5, 168, 85, 22, 1176, 1178, 7, 116, 2, 2, 1177, 1176, 3, 2, 2, 2, 1177,
	1178, 3, 2, 2, 2, 1178, 1179, 3, 2, 2, 2, 1179, 1181, 7, 82, 2, 2, 1180,
	1182, 7, 188, 2, 2, 1181, 1180, 3, 2, 2, 2, 1181, 1182, 3, 2, 2, 2, 1182,
	1183, 3, 2, 2, 2, 1183, 1184, 7, 202, 2, 2, 1184, 1185, 5, 124, 63, 2,
	1185, 1187, 7, 203, 2, 2, 1186, 1188, 5, 180, 91, 2, 1187, 1186, 3, 2,
	2, 2, 1187, 1188, 3, 2, 2, 2, 1188, 1189, 3, 2, 2, 2, 1189, 1190, 5, 68,
	35, 2, 1190, 1203, 3, 2, 2, 2, 1191, 1192, 5, 222, 112, 2, 1192, 1193,
	5, 172, 87, 2, 1193, 1194, 5, 168, 85, 7, 1194, 1203, 3, 2, 2, 2, 1195,
	1196, 5, 222, 112, 2, 1196, 1197, 7, 211, 2, 2, 1197, 1200, 7, 188, 2,
	2, 1198, 1201, 5, 222, 112, 2, 1199, 1201, 5, 170, 86, 2, 1200, 1198, 3,
	2, 2, 2, 1200, 1199, 3, 2, 2, 2, 1201, 1203, 3, 2, 2, 2, 1202, 1093, 3,
	2, 2, 2, 1202, 1096, 3, 2, 2, 2, 1202, 1097, 3, 2, 2, 2, 1202, 1102, 3,
	2, 2, 2, 1202, 1107, 3, 2, 2, 2, 1202, 1109, 3, 2, 2, 2, 1202, 1111, 3,
	2, 2, 2, 1202, 1113, 3, 2, 2, 2, 1202, 1116, 3, 2, 2, 2, 1202, 1118, 3,
	2, 2, 2, 1202, 1119, 3, 2, 2, 2, 1202, 1120, 3, 2, 2, 2, 1202, 1121, 3,
	2, 2, 2, 1202, 1122, 3, 2, 2, 2, 1202, 1123, 3, 2, 2, 2, 1202, 1135, 3,
	2, 2, 2, 1202, 1143, 3, 2, 2, 2, 1202, 1144, 3, 2, 2, 2, 1202, 1151, 3,
	2, 2, 2, 1202, 1156, 3, 2, 2, 2, 1202, 1161, 3, 2, 2, 2, 1202, 1166, 3,
	2, 2, 2, 1202, 1172, 3, 2, 2, 2, 1202, 1174, 3, 2, 2, 2, 1202, 1177, 3,
	2, 2, 2, 1202, 1191, 3, 2, 2, 2, 1202, 1195, 3, 2, 2, 2, 1203, 1258, 3,
	2, 2, 2, 1204, 1205, 12, 20, 2, 2, 1205, 1206, 7, 168, 2, 2, 1206, 1257,
	5, 168, 85, 20, 1207, 1208, 12, 18, 2, 2, 1208, 1209, 9, 10, 2, 2, 1209,
	1257, 5, 168, 85, 19, 1210, 1211, 12, 17, 2, 2, 1211, 1212, 9, 11, 2, 2,
	1212, 1257, 5, 168, 85, 18, 1213, 1214, 12, 16, 2, 2, 1214, 1215, 9, 12,
	2, 2, 1215, 1257, 5, 168, 85, 17, 1216, 1217, 12, 15, 2, 2, 1217, 1218,
	9, 13, 2, 2, 1218, 1257, 5, 168, 85, 16, 1219, 1220, 12, 14, 2, 2, 1220,
	1221, 9, 14, 2, 2, 1221, 1257, 5, 168, 85, 15, 1222, 1223, 12, 13, 2, 2,
	1223, 1224, 7, 188, 2, 2, 1224, 1257, 5, 168, 85, 14, 1225, 1226, 12, 12,
	2, 2, 1226, 1227, 7, 191, 2, 2, 1227, 1257, 5, 168, 85, 13, 1228, 1229,
	12, 11, 2, 2, 1229, 1230, 7, 189, 2, 2, 1230, 1257, 5, 168, 85, 12, 1231,
	1232, 12, 10, 2, 2, 1232, 1233, 7, 179, 2, 2, 1233, 1257, 5, 168, 85, 11,
	1234, 1235, 12, 9, 2, 2, 1235, 1236, 7, 178, 2, 2, 1236, 1257, 5, 168,
	85, 10, 1237, 1238, 12, 8, 2, 2, 1238, 1240, 7, 201, 2, 2, 1239, 1241,
	5, 168, 85, 2, 1240, 1239, 3, 2, 2, 2, 1240, 1241, 3, 2, 2, 2, 1241, 1242,
	3, 2, 2, 2, 1242, 1243, 7, 209, 2, 2, 1243, 1257, 5, 168, 85, 9, 1244,
	1245, 12, 5, 2, 2, 1245, 1246, 7, 99, 2, 2, 1246, 1257, 5, 168, 85, 6,
	1247, 1248, 12, 4, 2, 2, 1248, 1249, 7, 101, 2, 2, 1249, 1257, 5, 168,
	85, 5, 1250, 1251, 12, 3, 2, 2, 1251, 1252, 7, 100, 2, 2, 1252, 1257, 5,
	168, 85, 4, 1253, 1254, 12, 19, 2, 2, 1254, 1255, 7, 90, 2, 2, 1255, 1257,
	5, 186, 94, 2, 1256, 1204, 3, 2, 2, 2, 1256, 1207, 3, 2, 2, 2, 1256, 1210,
	3, 2, 2, 2, 1256, 1213, 3, 2, 2, 2, 1256, 1216, 3, 2, 2, 2, 1256, 1219,
	3, 2, 2, 2, 1256, 1222, 3, 2, 2, 2, 1256, 1225, 3, 2, 2, 2, 1256, 1228,
	3, 2, 2, 2, 1256, 1231, 3, 2, 2, 2, 1256, 1234, 3, 2, 2, 2, 1256, 1237,
	3, 2, 2, 2, 1256, 1244, 3, 2, 2, 2, 1256, 1247, 3, 2, 2, 2, 1256, 1250,
	3, 2, 2, 2, 1256, 1253, 3, 2, 2, 2, 1257, 1260, 3, 2, 2, 2, 1258, 1256,
	3, 2, 2, 2, 1258, 1259, 3, 2, 2, 2, 1259, 169, 3, 2, 2, 2, 1260, 1258,
	3, 2, 2, 2, 1261, 1262, 7, 103, 2, 2, 1262, 1264, 5, 186, 94, 2, 1263,
	1265, 5, 196, 99, 2, 1264, 1263, 3, 2, 2, 2, 1264, 1265, 3, 2, 2, 2, 1265,
	171, 3, 2, 2, 2, 1266, 1267, 9, 15, 2, 2, 1267, 173, 3, 2, 2, 2, 1268,
	1269, 7, 129, 2, 2, 1269, 1272, 5, 168, 85, 2, 1270, 1271, 7, 156, 2, 2,
	1271, 1273, 5, 168, 85, 2, 1272, 1270, 3, 2, 2, 2, 1272, 1273, 3, 2, 2,
	2, 1273, 175, 3, 2, 2, 2, 1274, 1279, 5, 178, 90, 2, 1275, 1276, 7, 208,
	2, 2, 1276, 1278, 5, 178, 90, 2, 1277, 1275, 3, 2, 2, 2, 1278, 1281, 3,
	2, 2, 2, 1279, 1277, 3, 2, 2, 2, 1279, 1280, 3, 2, 2, 2, 1280, 1283, 3,
	2, 2, 2, 1281, 1279, 3, 2, 2, 2, 1282, 1284, 7, 208, 2, 2, 1283, 1282,
	3, 2, 2, 2, 1283, 1284, 3, 2, 2, 2, 1284, 177, 3, 2, 2, 2, 1285, 1288,
	5, 168, 85, 2, 1286, 1287, 7, 156, 2, 2, 1287, 1289, 5, 168, 85, 2, 1288,
	1286, 3, 2, 2, 2, 1288, 1289, 3, 2, 2, 2, 1289, 1298, 3, 2, 2, 2, 1290,
	1291, 5, 168, 85, 2, 1291, 1292, 7, 156, 2, 2, 1292, 1294, 3, 2, 2, 2,
	1293, 1290, 3, 2, 2, 2, 1293, 1294, 3, 2, 2, 2, 1294, 1295, 3, 2, 2, 2,
	1295, 1296, 7, 188, 2, 2, 1296, 1298, 5, 222, 112, 2, 1297, 1285, 3, 2,
	2, 2, 1297, 1293, 3, 2, 2, 2, 1298, 179, 3, 2, 2, 2, 1299, 1300, 7, 126,
	2, 2, 1300, 1301, 7, 202, 2, 2, 1301, 1306, 5, 182, 92, 2, 1302, 1303,
	7, 208, 2, 2, 1303, 1305, 5, 182, 92, 2, 1304, 1302, 3, 2, 2, 2, 1305,
	1308, 3, 2, 2, 2, 1306, 1304, 3, 2, 2, 2, 1306, 1307, 3, 2, 2, 2, 1307,
	1309, 3, 2, 2, 2, 1308, 1306, 3, 2, 2, 2, 1309, 1310, 7, 203, 2, 2, 1310,
	181, 3, 2, 2, 2, 1311, 1313, 7, 188, 2, 2, 1312, 1311, 3, 2, 2, 2, 1312,
	1313, 3, 2, 2, 2, 1313, 1314, 3, 2, 2, 2, 1314, 1315, 7, 214, 2, 2, 1315,
	183, 3, 2, 2, 2, 1316, 1318, 5, 190, 96, 2, 1317, 1319, 5, 46, 24, 2, 1318,
	1317, 3, 2, 2, 2, 1318, 1319, 3, 2, 2, 2, 1319, 1322, 3, 2, 2, 2, 1320,
	1322, 7, 116, 2, 2, 1321, 1316, 3, 2, 2, 2, 1321, 1320, 3, 2, 2, 2, 1322,
	185, 3, 2, 2, 2, 1323, 1326, 5, 190, 96, 2, 1324, 1326, 5, 188, 95, 2,
	1325, 1323, 3, 2, 2, 2, 1325, 1324, 3, 2, 2, 2, 1326, 1328, 3, 2, 2, 2,
	1327, 1329, 5, 46, 24, 2, 1328, 1327, 3, 2, 2, 2, 1328, 1329, 3, 2, 2,
	2, 1329, 1333, 3, 2, 2, 2, 1330, 1333, 5, 256, 129, 2, 1331, 1333, 7, 116,
	2, 2, 1332, 1325, 3, 2, 2, 2, 1332, 1330, 3, 2, 2, 2, 1332, 1331, 3, 2,
	2, 2, 1333, 187, 3, 2, 2, 2, 1334, 1339, 5, 232, 117, 2, 1335, 1336, 7,
	183, 2, 2, 1336, 1338, 5, 234, 118, 2, 1337, 1335, 3, 2, 2, 2, 1338, 1341,
	3, 2, 2, 2, 1339, 1337, 3, 2, 2, 2, 1339, 1340, 3, 2, 2, 2, 1340, 189,
	3, 2, 2, 2, 1341, 1339, 3, 2, 2, 2, 1342, 1344, 7, 102, 2, 2, 1343, 1342,
	3, 2, 2, 2, 1343, 1344, 3, 2, 2, 2, 1344, 1346, 3, 2, 2, 2, 1345, 1347,
	7, 184, 2, 2, 1346, 1345, 3, 2, 2, 2, 1346, 1347, 3, 2, 2, 2, 1347, 1348,
	3, 2, 2, 2, 1348, 1349, 5, 192, 97, 2, 1349, 191, 3, 2, 2, 2, 1350, 1355,
	5, 248, 125, 2, 1351, 1352, 7, 184, 2, 2, 1352, 1354, 5, 248, 125, 2, 1353,
	1351, 3, 2, 2, 2, 1354, 1357, 3, 2, 2, 2, 1355, 1353, 3, 2, 2, 2, 1355,
	1356, 3, 2, 2, 2, 1356, 193, 3, 2, 2, 2, 1357, 1355, 3, 2, 2, 2, 1358,
	1363, 5, 190, 96, 2, 1359, 1360, 7, 208, 2, 2, 1360, 1362, 5, 190, 96,
	2, 1361, 1359, 3, 2, 2, 2, 1362, 1365, 3, 2, 2, 2, 1363, 1361, 3, 2, 2,
	2, 1363, 1364, 3, 2, 2, 2, 1364, 195, 3, 2, 2, 2, 1365, 1363, 3, 2, 2,
	2, 1366, 1376, 7, 202, 2, 2, 1367, 1372, 5, 198, 100, 2, 1368, 1369, 7,
	208, 2, 2, 1369, 1371, 5, 198, 100, 2, 1370, 1368, 3, 2, 2, 2, 1371, 1374,
	3, 2, 2, 2, 1372, 1370, 3, 2, 2, 2, 1372, 1373, 3, 2, 2, 2, 1373, 1377,
	3, 2, 2, 2, 1374, 1372, 3, 2, 2, 2, 1375, 1377, 5, 174, 88, 2, 1376, 1367,
	3, 2, 2, 2, 1376, 1375, 3, 2, 2, 2, 1376, 1377, 3, 2, 2, 2, 1377, 1378,
	3, 2, 2, 2, 1378, 1379, 7, 203, 2, 2, 1379, 197, 3, 2, 2, 2, 1380, 1382,
	7, 185, 2, 2, 1381, 1380, 3, 2, 2, 2, 1381, 1382, 3, 2, 2, 2, 1382, 1383,
	3, 2, 2, 2, 1383, 1387, 5, 168, 85, 2, 1384, 1385, 7, 188, 2, 2, 1385,
	1387, 5, 222, 112, 2, 1386, 1381, 3, 2, 2, 2, 1386, 1384, 3, 2, 2, 2, 1387,
	199, 3, 2, 2, 2, 1388, 1410, 5, 206, 104, 2, 1389, 1410, 5, 216, 109, 2,
	1390, 1391, 7, 46, 2, 2, 1391, 1396, 7, 202, 2, 2, 1392, 1394, 5, 202,
	102, 2, 1393, 1395, 7, 208, 2, 2, 1394, 1393, 3, 2, 2, 2, 1394, 1395, 3,
	2, 2, 2, 1395, 1397, 3, 2, 2, 2, 1396, 1392, 3, 2, 2, 2, 1396, 1397, 3,
	2, 2, 2, 1397, 1398, 3, 2, 2, 2, 1398, 1410, 7, 203, 2, 2, 1399, 1404,
	7, 204, 2, 2, 1400, 1402, 5, 202, 102, 2, 1401, 1403, 7, 208, 2, 2, 1402,
	1401, 3, 2, 2, 2, 1402, 1403, 3, 2, 2, 2, 1403, 1405, 3, 2, 2, 2, 1404,
	1400, 3, 2, 2, 2, 1404, 1405, 3, 2, 2, 2, 1405, 1406, 3, 2, 2, 2, 1406,
	1410, 7, 205, 2, 2, 1407, 1408, 9, 16, 2, 2, 1408, 1410, 5, 200, 101, 2,
	1409, 1388, 3, 2, 2, 2, 1409, 1389, 3, 2, 2, 2, 1409, 1390, 3, 2, 2, 2,
	1409, 1399, 3, 2, 2, 2, 1409, 1407, 3, 2, 2, 2, 1410, 201, 3, 2, 2, 2,
	1411, 1416, 5, 204, 103, 2, 1412, 1413, 7, 208, 2, 2, 1413, 1415, 5, 204,
	103, 2, 1414, 1412, 3, 2, 2, 2, 1415, 1418, 3, 2, 2, 2, 1416, 1414, 3,
	2, 2, 2, 1416, 1417, 3, 2, 2, 2, 1417, 203, 3, 2, 2, 2, 1418, 1416, 3,
	2, 2, 2, 1419, 1422, 5, 200, 101, 2, 1420, 1421, 7, 156, 2, 2, 1421, 1423,
	5, 200, 101, 2, 1422, 1420, 3, 2, 2, 2, 1422, 1423, 3, 2, 2, 2, 1423, 205,
	3, 2, 2, 2, 1424, 1430, 7, 104, 2, 2, 1425, 1430, 5, 208, 105, 2, 1426,
	1430, 5, 252, 127, 2, 1427, 1430, 5, 212, 107, 2, 1428, 1430, 5, 190, 96,
	2, 1429, 1424, 3, 2, 2, 2, 1429, 1425, 3, 2, 2, 2, 1429, 1426, 3, 2, 2,
	2, 1429, 1427, 3, 2, 2, 2, 1429, 1428, 3, 2, 2, 2, 1430, 207, 3, 2, 2,
	2, 1431, 1436, 7, 218, 2, 2, 1432, 1436, 7, 50, 2, 2, 1433, 1436, 5, 210,
	106, 2, 1434, 1436, 5, 214, 108, 2, 1435, 1431, 3, 2, 2, 2, 1435, 1432,
	3, 2, 2, 2, 1435, 1433, 3, 2, 2, 2, 1435, 1434, 3, 2, 2, 2, 1436, 209,
	3, 2, 2, 2, 1437, 1438, 9, 17, 2, 2, 1438, 211, 3, 2, 2, 2, 1439, 1440,
	9, 18, 2, 2, 1440, 1445, 7, 182, 2, 2, 1441, 1446, 5, 248, 125, 2, 1442,
	1446, 7, 134, 2, 2, 1443, 1446, 7, 130, 2, 2, 1444, 1446, 7, 131, 2, 2,
	1445, 1441, 3, 2, 2, 2, 1445, 1442, 3, 2, 2, 2, 1445, 1443, 3, 2, 2, 2,
	1445, 1444, 3, 2, 2, 2, 1446, 1455, 3, 2, 2, 2, 1447, 1450, 5, 184, 93,
	2, 1448, 1450, 5, 238, 120, 2, 1449, 1447, 3, 2, 2, 2, 1449, 1448, 3, 2,
	2, 2, 1450, 1451, 3, 2, 2, 2, 1451, 1452, 7, 182, 2, 2, 1452, 1453, 5,
	248, 125, 2, 1453, 1455, 3, 2, 2, 2, 1454, 1439, 3, 2, 2, 2, 1454, 1449,
	3, 2, 2, 2, 1455, 213, 3, 2, 2, 2, 1456, 1457, 7, 215, 2, 2, 1457, 215,
	3, 2, 2, 2, 1458, 1460, 7, 225, 2, 2, 1459, 1461, 7, 232, 2, 2, 1460, 1459,
	3, 2, 2, 2, 1461, 1462, 3, 2, 2, 2, 1462, 1460, 3, 2, 2, 2, 1462, 1463,
	3, 2, 2, 2, 1463, 1480, 3, 2, 2, 2, 1464, 1466, 7, 224, 2, 2, 1465, 1467,
	7, 232, 2, 2, 1466, 1465, 3, 2, 2, 2, 1467, 1468, 3, 2, 2, 2, 1468, 1466,
	3, 2, 2, 2, 1468, 1469, 3, 2, 2, 2, 1469, 1480, 3, 2, 2, 2, 1470, 1480,
	7, 222, 2, 2, 1471, 1475, 7, 223, 2, 2, 1472, 1474, 5, 218, 110, 2, 1473,
	1472, 3, 2, 2, 2, 1474, 1477, 3, 2, 2, 2, 1475, 1473, 3, 2, 2, 2, 1475,
	1476, 3, 2, 2, 2, 1476, 1478, 3, 2, 2, 2, 1477, 1475, 3, 2, 2, 2, 1478,
	1480, 7, 223, 2, 2, 1479, 1458, 3, 2, 2, 2, 1479, 1464, 3, 2, 2, 2, 1479,
	1470, 3, 2, 2, 2, 1479, 1471, 3, 2, 2, 2, 1480, 217, 3, 2, 2, 2, 1481,
	1484, 7, 228, 2, 2, 1482, 1484, 5, 222, 112, 2, 1483, 1481, 3, 2, 2, 2,
	1483, 1482, 3, 2, 2, 2, 1484, 219, 3, 2, 2, 2, 1485, 1490, 5, 222, 112,
	2, 1486, 1487, 7, 208, 2, 2, 1487, 1489, 5, 222, 112, 2, 1488, 1486, 3,
	2, 2, 2, 1489, 1492, 3, 2, 2, 2, 1490, 1488, 3, 2, 2, 2, 1490, 1491, 3,
	2, 2, 2, 1491, 221, 3, 2, 2, 2, 1492, 1490, 3, 2, 2, 2, 1493, 1500, 5,
	232, 117, 2, 1494, 1500, 5, 226, 114, 2, 1495, 1496, 7, 202, 2, 2, 1496,
	1497, 5, 170, 86, 2, 1497, 1498, 7, 203, 2, 2, 1498, 1500, 3, 2, 2, 2,
	1499, 1493, 3, 2, 2, 2, 1499, 1494, 3, 2, 2, 2, 1499, 1495, 3, 2, 2, 2,
	1500, 1504, 3, 2, 2, 2, 1501, 1503, 5, 224, 113, 2, 1502, 1501, 3, 2, 2,
	2, 1503, 1506, 3, 2, 2, 2, 1504, 1502, 3, 2, 2, 2, 1504, 1505, 3, 2, 2,
	2, 1505, 223, 3, 2, 2, 2, 1506, 1504, 3, 2, 2, 2, 1507, 1508, 7, 183, 2,
	2, 1508, 1510, 5, 234, 118, 2, 1509, 1511, 5, 230, 116, 2, 1510, 1509,
	3, 2, 2, 2, 1510, 1511, 3, 2, 2, 2, 1511, 225, 3, 2, 2, 2, 1512, 1513,
	5, 228, 115, 2, 1513, 1514, 5, 230, 116, 2, 1514, 227, 3, 2, 2, 2, 1515,
	1519, 5, 190, 96, 2, 1516, 1519, 5, 212, 107, 2, 1517, 1519, 5, 232, 117,
	2, 1518, 1515, 3, 2, 2, 2, 1518, 1516, 3, 2, 2, 2, 1518, 1517, 3, 2, 2,
	2, 1519, 229, 3, 2, 2, 2, 1520, 1522, 5, 46, 24, 2, 1521, 1520, 3, 2, 2,
	2, 1521, 1522, 3, 2, 2, 2, 1522, 1523, 3, 2, 2, 2, 1523, 1527, 5, 196,
	99, 2, 1524, 1526, 5, 240, 121, 2, 1525, 1524, 3, 2, 2, 2, 1526, 1529,
	3, 2, 2, 2, 1527, 1525, 3, 2, 2, 2, 1527, 1528, 3, 2, 2, 2, 1528, 231,
	3, 2, 2, 2, 1529, 1527, 3, 2, 2, 2, 1530, 1533, 5, 238, 120, 2, 1531, 1532,
	7, 182, 2, 2, 1532, 1534, 5, 238, 120, 2, 1533, 1531, 3, 2, 2, 2, 1533,
	1534, 3, 2, 2, 2, 1534, 1540, 3, 2, 2, 2, 1535, 1536, 5, 184, 93, 2, 1536,
	1537, 7, 182, 2, 2, 1537, 1538, 5, 238, 120, 2, 1538, 1540, 3, 2, 2, 2,
	1539, 1530, 3, 2, 2, 2, 1539, 1535, 3, 2, 2, 2, 1540, 233, 3, 2, 2, 2,
	1541, 1544, 5, 236, 119, 2, 1542, 1544, 5, 238, 120, 2, 1543, 1541, 3,
	2, 2, 2, 1543, 1542, 3, 2, 2, 2, 1544, 235, 3, 2, 2, 2, 1545, 1551, 5,
	248, 125, 2, 1546, 1547, 7, 206, 2, 2, 1547, 1548, 5, 168, 85, 2, 1548,
	1549, 7, 207, 2, 2, 1549, 1551, 3, 2, 2, 2, 1550, 1545, 3, 2, 2, 2, 1550,
	1546, 3, 2, 2, 2, 1551, 1555, 3, 2, 2, 2, 1552, 1554, 5, 240, 121, 2, 1553,
	1552, 3, 2, 2, 2, 1554, 1557, 3, 2, 2, 2, 1555, 1553, 3, 2, 2, 2, 1555,
	1556, 3, 2, 2, 2, 1556, 237, 3, 2, 2, 2, 1557, 1555, 3, 2, 2, 2, 1558,
	1560, 7, 199, 2, 2, 1559, 1558, 3, 2, 2, 2, 1560, 1563, 3, 2, 2, 2, 1561,
	1559, 3, 2, 2, 2, 1561, 1562, 3, 2, 2, 2, 1562, 1570, 3, 2, 2, 2, 1563,
	1561, 3, 2, 2, 2, 1564, 1571, 7, 214, 2, 2, 1565, 1566, 7, 199, 2, 2, 1566,
	1567, 7, 206, 2, 2, 1567, 1568, 5, 168, 85, 2, 1568, 1569, 7, 207, 2, 2,
	1569, 1571, 3, 2, 2, 2, 1570, 1564, 3, 2, 2, 2, 1570, 1565, 3, 2, 2, 2,
	1571, 1575, 3, 2, 2, 2, 1572, 1574, 5, 240, 121, 2, 1573, 1572, 3, 2, 2,
	2, 1574, 1577, 3, 2, 2, 2, 1575, 1573, 3, 2, 2, 2, 1575, 1576, 3, 2, 2,
	2, 1576, 239, 3, 2, 2, 2, 1577, 1575, 3, 2, 2, 2, 1578, 1580, 7, 204, 2,
	2, 1579, 1581, 5, 168, 85, 2, 1580, 1579, 3, 2, 2, 2, 1580, 1581, 3, 2,
	2, 2, 1581, 1582, 3, 2, 2, 2, 1582, 1588, 7, 205, 2, 2, 1583, 1584, 7,
	206, 2, 2, 1584, 1585, 5, 168, 85, 2, 1585, 1586, 7, 207, 2, 2, 1586, 1588,
	3, 2, 2, 2, 1587, 1578, 3, 2, 2, 2, 1587, 1583, 3, 2, 2, 2, 1588, 241,
	3, 2, 2, 2, 1589, 1591, 5, 244, 123, 2, 1590, 1589, 3, 2, 2, 2, 1590, 1591,
	3, 2, 2, 2, 1591, 1598, 3, 2, 2, 2, 1592, 1594, 7, 208, 2, 2, 1593, 1595,
	5, 244, 123, 2, 1594, 1593, 3, 2, 2, 2, 1594, 1595, 3, 2, 2, 2, 1595, 1597,
	3, 2, 2, 2, 1596, 1592, 3, 2, 2, 2, 1597, 1600, 3, 2, 2, 2, 1598, 1596,
	3, 2, 2, 2, 1598, 1599, 3, 2, 2, 2, 1599, 243, 3, 2, 2, 2, 1600, 1598,
	3, 2, 2, 2, 1601, 1608, 5, 222, 112, 2, 1602, 1603, 7, 98, 2, 2, 1603,
	1604, 7, 202, 2, 2, 1604, 1605, 5, 242, 122, 2, 1605, 1606, 7, 203, 2,
	2, 1606, 1608, 3, 2, 2, 2, 1607, 1601, 3, 2, 2, 2, 1607, 1602, 3, 2, 2,
	2, 1608, 245, 3, 2, 2, 2, 1609, 1610, 9, 19, 2, 2, 1610, 247, 3, 2, 2,
	2, 1611, 1612, 9, 20, 2, 2, 1612, 249, 3, 2, 2, 2, 1613, 1614, 9, 21, 2,
	2, 1614, 251, 3, 2, 2, 2, 1615, 1616, 9, 22, 2, 2, 1616, 253, 3, 2, 2,
	2, 1617, 1618, 9, 23, 2, 2, 1618, 255, 3, 2, 2, 2, 1619, 1620, 9, 24, 2,
	2, 1620, 257, 3, 2, 2, 2, 1621, 1622, 9, 25, 2, 2, 1622, 259, 3, 2, 2,
	2, 186, 261, 266, 274, 279, 305, 309, 314, 319, 325, 338, 342, 348, 353,
	358, 364, 368, 374, 381, 388, 393, 397, 406, 409, 412, 417, 421, 425, 430,
	434, 436, 442, 454, 471, 478, 486, 497, 505, 513, 520, 527, 550, 557, 565,
	575, 581, 610, 624, 628, 637, 641, 646, 672, 683, 687, 691, 700, 710, 715,
	721, 726, 731, 736, 741, 747, 753, 759, 777, 782, 785, 795, 798, 811, 819,
	826, 829, 834, 838, 868, 873, 877, 884, 888, 894, 899, 902, 905, 912, 920,
	933, 945, 957, 969, 976, 980, 984, 990, 998, 1005, 1009, 1013, 1026, 1029,
	1036, 1046, 1050, 1055, 1060, 1073, 1083, 1089, 1127, 1132, 1135, 1141,
	1170, 1177, 1181, 1187, 1200, 1202, 1240, 1256, 1258, 1264, 1272, 1279,
	1283, 1288, 1293, 1297, 1306, 1312, 1318, 1321, 1325, 1328, 1332, 1339,
	1343, 1346, 1355, 1363, 1372, 1376, 1381, 1386, 1394, 1396, 1402, 1404,
	1409, 1416, 1422, 1429, 1435, 1445, 1449, 1454, 1462, 1468, 1475, 1479,
	1483, 1490, 1499, 1504, 1510, 1518, 1521, 1527, 1533, 1539, 1543, 1550,
	1555, 1561, 1570, 1575, 1580, 1587, 1590, 1594, 1598, 1607,
}
var deserializer = antlr.NewATNDeserializer(nil)
var deserializedATN = deserializer.DeserializeFromUInt16(parserATN)

var literalNames = []string{
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "'/>'",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "'abstract'", "'array'", "'as'", "'binary'",
	"", "", "'break'", "'callable'", "'case'", "'catch'", "'class'", "'clone'",
	"'const'", "'continue'", "'declare'", "'default'", "'do'", "'real'", "'double'",
	"'echo'", "'else'", "'elseif'", "'empty'", "'enddeclare'", "'endfor'",
	"'endforeach'", "'endif'", "'endswitch'", "'endwhile'", "'eval'", "'die'",
	"'extends'", "'final'", "'finally'", "'float'", "'for'", "'foreach'", "'function'",
	"'global'", "'goto'", "'if'", "'implements'", "'import'", "'include'",
	"'include_once'", "'instanceof'", "'insteadof'", "'int8'", "'int16'", "'int64'",
	"", "'interface'", "'isset'", "'list'", "'and'", "'or'", "'xor'", "'namespace'",
	"'new'", "'null'", "'object'", "'parent'", "'partial'", "'print'", "'private'",
	"'protected'", "'public'", "'require'", "'require_once'", "'resource'",
	"'return'", "'static'", "'string'", "'switch'", "'throw'", "'trait'", "'try'",
	"'clrtypeof'", "", "'unicode'", "'unset'", "'use'", "'var'", "'while'",
	"'yield'", "'__get'", "'__set'", "'__call'", "'__callstatic'", "'__construct'",
	"'__destruct'", "'__wakeup'", "'__sleep'", "'__autoload'", "'__isset'",
	"'__unset'", "'__tostring'", "'__invoke'", "'__set_state'", "'__clone'",
	"'__debuginfo'", "'__namespace__'", "'__class__'", "'__trait__'", "'__function__'",
	"'__method__'", "'__line__'", "'__file__'", "'__dir__'", "'<:'", "':>'",
	"'=>'", "'++'", "'--'", "'==='", "'!=='", "'=='", "", "'<='", "'>='", "'+='",
	"'-='", "'*='", "'**'", "'**='", "'/='", "'.='", "'%='", "'<<='", "'>>='",
	"'&='", "'|='", "'^='", "'||'", "'&&'", "'<<'", "'>>'", "'::'", "'->'",
	"'\\'", "'...'", "", "", "'&'", "'|'", "'!'", "'^'", "'+'", "'-'", "'*'",
	"'%'", "", "'~'", "'@'", "", "'.'", "", "'('", "')'", "'['", "']'", "",
	"'}'", "','", "':'", "';'", "", "'''", "'`'",
}
var symbolicNames = []string{
	"", "SeaWhitespace", "HtmlText", "XmlStart", "PHPStart", "HtmlScriptOpen",
	"HtmlStyleOpen", "HtmlComment", "HtmlDtd", "HtmlOpen", "Shebang", "Error",
	"XmlText", "XmlClose", "PHPStartInside", "HtmlClose", "HtmlSlashClose",
	"HtmlSlash", "HtmlEquals", "HtmlStartQuoteString", "HtmlStartDoubleQuoteString",
	"HtmlHex", "HtmlDecimal", "HtmlSpace", "HtmlName", "ErrorInside", "PHPStartInsideQuoteString",
	"HtmlEndQuoteString", "HtmlQuoteString", "ErrorHtmlQuote", "PHPStartDoubleQuoteString",
	"HtmlEndDoubleQuoteString", "HtmlDoubleQuoteString", "ErrorHtmlDoubleQuote",
	"ScriptText", "ScriptClose", "PHPStartInsideScript", "StyleBody", "PHPEnd",
	"Whitespace", "MultiLineComment", "SingleLineComment", "ShellStyleComment",
	"Abstract", "Array", "As", "BinaryCast", "BoolType", "BooleanConstant",
	"Break", "Callable", "Case", "Catch", "Class", "Clone", "Const", "Continue",
	"Declare", "Default", "Do", "DoubleCast", "DoubleType", "Echo", "Else",
	"ElseIf", "Empty", "EndDeclare", "EndFor", "EndForeach", "EndIf", "EndSwitch",
	"EndWhile", "Eval", "Exit", "Extends", "Final", "Finally", "FloatCast",
	"For", "Foreach", "Function", "Global", "Goto", "If", "Implements", "Import",
	"Include", "IncludeOnce", "InstanceOf", "InsteadOf", "Int8Cast", "Int16Cast",
	"Int64Type", "IntType", "Interface", "IsSet", "List", "LogicalAnd", "LogicalOr",
	"LogicalXor", "Namespace", "New", "Null", "ObjectType", "Parent_", "Partial",
	"Print", "Private", "Protected", "Public", "Require", "RequireOnce", "Resource",
	"Return", "Static", "StringType", "Switch", "Throw", "Trait", "Try", "Typeof",
	"UintCast", "UnicodeCast", "Unset", "Use", "Var", "While", "Yield", "Get",
	"Set", "Call", "CallStatic", "Constructor", "Destruct", "Wakeup", "Sleep",
	"Autoload", "IsSet__", "Unset__", "ToString__", "Invoke", "SetState", "Clone__",
	"DebugInfo", "Namespace__", "Class__", "Traic__", "Function__", "Method__",
	"Line__", "File__", "Dir__", "Lgeneric", "Rgeneric", "DoubleArrow", "Inc",
	"Dec", "IsIdentical", "IsNoidentical", "IsEqual", "IsNotEq", "IsSmallerOrEqual",
	"IsGreaterOrEqual", "PlusEqual", "MinusEqual", "MulEqual", "Pow", "PowEqual",
	"DivEqual", "Concaequal", "ModEqual", "ShiftLeftEqual", "ShiftRightEqual",
	"AndEqual", "OrEqual", "XorEqual", "BooleanOr", "BooleanAnd", "ShiftLeft",
	"ShiftRight", "DoubleColon", "ObjectOperator", "NamespaceSeparator", "Ellipsis",
	"Less", "Greater", "Ampersand", "Pipe", "Bang", "Caret", "Plus", "Minus",
	"Asterisk", "Percent", "Divide", "Tilde", "SuppressWarnings", "Dollar",
	"Dot", "QuestionMark", "OpenRoundBracket", "CloseRoundBracket", "OpenSquareBracket",
	"CloseSquareBracket", "OpenCurlyBracket", "CloseCurlyBracket", "Comma",
	"Colon", "SemiColon", "Eq", "Quote", "BackQuote", "VarName", "Label", "Octal",
	"Decimal", "Real", "Hex", "Binary", "BackQuoteString", "SingleQuoteString",
	"DoubleQuote", "StartNowDoc", "StartHereDoc", "ErrorPhp", "CurlyDollar",
	"StringPart", "Comment", "PHPEndSingleLineComment", "CommentEnd", "HereDocText",
	"XmlText2",
}

var ruleNames = []string{
	"htmlDocument", "htmlElementOrPhpBlock", "htmlElements", "htmlElement",
	"scriptTextPart", "phpBlock", "importStatement", "topStatement", "useDeclaration",
	"useDeclarationContentList", "useDeclarationContent", "namespaceDeclaration",
	"namespaceStatement", "functionDeclaration", "classDeclaration", "classEntryType",
	"interfaceList", "typeParameterListInBrackets", "typeParameterList", "typeParameterWithDefaultsList",
	"typeParameterDecl", "typeParameterWithDefaultDecl", "genericDynamicArgs",
	"attributes", "attributesGroup", "attribute", "attributeArgList", "attributeNamedArgList",
	"attributeNamedArg", "innerStatementList", "innerStatement", "statement",
	"voidStatement", "blockStatement", "ifStatement", "elseIfStatement", "elseIfColonStatement",
	"elseStatement", "elseColonStatement", "whileStatement", "doWhileStatement",
	"forStatement", "forInit", "forUpdate", "switchStatement", "switchBlock",
	"breakStatement", "continueStatement", "returnStatement", "expressionStatement",
	"unsetStatement", "foreachStatement", "tryCatchFinally", "catchClause",
	"finallyStatement", "throwStatement", "gotoStatement", "declareStatement",
	"inlineHtmlStatement", "inlineHtml", "declareList", "formalParameterList",
	"formalParameter", "typeHint", "globalStatement", "globalVar", "echoStatement",
	"staticVariableStatement", "classStatement", "traitAdaptations", "traitAdaptationStatement",
	"traitPrecedence", "traitAlias", "traitMethodReference", "baseCtorCall",
	"methodBody", "propertyModifiers", "memberModifiers", "variableInitializer",
	"identifierInititalizer", "globalConstantDeclaration", "expressionList",
	"parenthesis", "expression", "newExpr", "assignmentOperator", "yieldExpression",
	"arrayItemList", "arrayItem", "lambdaFunctionUseVars", "lambdaFunctionUseVar",
	"qualifiedStaticTypeRef", "typeRef", "indirectTypeRef", "qualifiedNamespaceName",
	"namespaceNameList", "qualifiedNamespaceNameList", "arguments", "actualArgument",
	"constantInititalizer", "constantArrayItemList", "constantArrayItem", "constant",
	"literalConstant", "numericConstant", "classConstant", "stringConstant",
	"str", "interpolatedStringPart", "chainList", "chain", "memberAccess",
	"functionCall", "functionCallName", "actualArguments", "chainBase", "keyedFieldName",
	"keyedSimpleFieldName", "keyedVariable", "squareCurlyExpression", "assignmentList",
	"assignmentListElement", "modifier", "identifier", "memberModifier", "magicConstant",
	"magicMethod", "primitiveType", "castOperation",
}
var decisionToDFA = make([]*antlr.DFA, len(deserializedATN.DecisionToState))

func init() {
	for index, ds := range deserializedATN.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(ds, index)
	}
}

type PhpParser struct {
	*antlr.BaseParser
}

func NewPhpParser(input antlr.TokenStream) *PhpParser {
	this := new(PhpParser)

	this.BaseParser = antlr.NewBaseParser(input)

	this.Interpreter = antlr.NewParserATNSimulator(this, deserializedATN, decisionToDFA, antlr.NewPredictionContextCache())
	this.RuleNames = ruleNames
	this.LiteralNames = literalNames
	this.SymbolicNames = symbolicNames
	this.GrammarFileName = "PhpParser.g4"

	return this
}

// PhpParser tokens.
const (
	PhpParserEOF                        = antlr.TokenEOF
	PhpParserSeaWhitespace              = 1
	PhpParserHtmlText                   = 2
	PhpParserXmlStart                   = 3
	PhpParserPHPStart                   = 4
	PhpParserHtmlScriptOpen             = 5
	PhpParserHtmlStyleOpen              = 6
	PhpParserHtmlComment                = 7
	PhpParserHtmlDtd                    = 8
	PhpParserHtmlOpen                   = 9
	PhpParserShebang                    = 10
	PhpParserError                      = 11
	PhpParserXmlText                    = 12
	PhpParserXmlClose                   = 13
	PhpParserPHPStartInside             = 14
	PhpParserHtmlClose                  = 15
	PhpParserHtmlSlashClose             = 16
	PhpParserHtmlSlash                  = 17
	PhpParserHtmlEquals                 = 18
	PhpParserHtmlStartQuoteString       = 19
	PhpParserHtmlStartDoubleQuoteString = 20
	PhpParserHtmlHex                    = 21
	PhpParserHtmlDecimal                = 22
	PhpParserHtmlSpace                  = 23
	PhpParserHtmlName                   = 24
	PhpParserErrorInside                = 25
	PhpParserPHPStartInsideQuoteString  = 26
	PhpParserHtmlEndQuoteString         = 27
	PhpParserHtmlQuoteString            = 28
	PhpParserErrorHtmlQuote             = 29
	PhpParserPHPStartDoubleQuoteString  = 30
	PhpParserHtmlEndDoubleQuoteString   = 31
	PhpParserHtmlDoubleQuoteString      = 32
	PhpParserErrorHtmlDoubleQuote       = 33
	PhpParserScriptText                 = 34
	PhpParserScriptClose                = 35
	PhpParserPHPStartInsideScript       = 36
	PhpParserStyleBody                  = 37
	PhpParserPHPEnd                     = 38
	PhpParserWhitespace                 = 39
	PhpParserMultiLineComment           = 40
	PhpParserSingleLineComment          = 41
	PhpParserShellStyleComment          = 42
	PhpParserAbstract                   = 43
	PhpParserArray                      = 44
	PhpParserAs                         = 45
	PhpParserBinaryCast                 = 46
	PhpParserBoolType                   = 47
	PhpParserBooleanConstant            = 48
	PhpParserBreak                      = 49
	PhpParserCallable                   = 50
	PhpParserCase                       = 51
	PhpParserCatch                      = 52
	PhpParserClass                      = 53
	PhpParserClone                      = 54
	PhpParserConst                      = 55
	PhpParserContinue                   = 56
	PhpParserDeclare                    = 57
	PhpParserDefault                    = 58
	PhpParserDo                         = 59
	PhpParserDoubleCast                 = 60
	PhpParserDoubleType                 = 61
	PhpParserEcho                       = 62
	PhpParserElse                       = 63
	PhpParserElseIf                     = 64
	PhpParserEmpty                      = 65
	PhpParserEndDeclare                 = 66
	PhpParserEndFor                     = 67
	PhpParserEndForeach                 = 68
	PhpParserEndIf                      = 69
	PhpParserEndSwitch                  = 70
	PhpParserEndWhile                   = 71
	PhpParserEval                       = 72
	PhpParserExit                       = 73
	PhpParserExtends                    = 74
	PhpParserFinal                      = 75
	PhpParserFinally                    = 76
	PhpParserFloatCast                  = 77
	PhpParserFor                        = 78
	PhpParserForeach                    = 79
	PhpParserFunction                   = 80
	PhpParserGlobal                     = 81
	PhpParserGoto                       = 82
	PhpParserIf                         = 83
	PhpParserImplements                 = 84
	PhpParserImport                     = 85
	PhpParserInclude                    = 86
	PhpParserIncludeOnce                = 87
	PhpParserInstanceOf                 = 88
	PhpParserInsteadOf                  = 89
	PhpParserInt8Cast                   = 90
	PhpParserInt16Cast                  = 91
	PhpParserInt64Type                  = 92
	PhpParserIntType                    = 93
	PhpParserInterface                  = 94
	PhpParserIsSet                      = 95
	PhpParserList                       = 96
	PhpParserLogicalAnd                 = 97
	PhpParserLogicalOr                  = 98
	PhpParserLogicalXor                 = 99
	PhpParserNamespace                  = 100
	PhpParserNew                        = 101
	PhpParserNull                       = 102
	PhpParserObjectType                 = 103
	PhpParserParent_                    = 104
	PhpParserPartial                    = 105
	PhpParserPrint                      = 106
	PhpParserPrivate                    = 107
	PhpParserProtected                  = 108
	PhpParserPublic                     = 109
	PhpParserRequire                    = 110
	PhpParserRequireOnce                = 111
	PhpParserResource                   = 112
	PhpParserReturn                     = 113
	PhpParserStatic                     = 114
	PhpParserStringType                 = 115
	PhpParserSwitch                     = 116
	PhpParserThrow                      = 117
	PhpParserTrait                      = 118
	PhpParserTry                        = 119
	PhpParserTypeof                     = 120
	PhpParserUintCast                   = 121
	PhpParserUnicodeCast                = 122
	PhpParserUnset                      = 123
	PhpParserUse                        = 124
	PhpParserVar                        = 125
	PhpParserWhile                      = 126
	PhpParserYield                      = 127
	PhpParserGet                        = 128
	PhpParserSet                        = 129
	PhpParserCall                       = 130
	PhpParserCallStatic                 = 131
	PhpParserConstructor                = 132
	PhpParserDestruct                   = 133
	PhpParserWakeup                     = 134
	PhpParserSleep                      = 135
	PhpParserAutoload                   = 136
	PhpParserIsSet__                    = 137
	PhpParserUnset__                    = 138
	PhpParserToString__                 = 139
	PhpParserInvoke                     = 140
	PhpParserSetState                   = 141
	PhpParserClone__                    = 142
	PhpParserDebugInfo                  = 143
	PhpParserNamespace__                = 144
	PhpParserClass__                    = 145
	PhpParserTraic__                    = 146
	PhpParserFunction__                 = 147
	PhpParserMethod__                   = 148
	PhpParserLine__                     = 149
	PhpParserFile__                     = 150
	PhpParserDir__                      = 151
	PhpParserLgeneric                   = 152
	PhpParserRgeneric                   = 153
	PhpParserDoubleArrow                = 154
	PhpParserInc                        = 155
	PhpParserDec                        = 156
	PhpParserIsIdentical                = 157
	PhpParserIsNoidentical              = 158
	PhpParserIsEqual                    = 159
	PhpParserIsNotEq                    = 160
	PhpParserIsSmallerOrEqual           = 161
	PhpParserIsGreaterOrEqual           = 162
	PhpParserPlusEqual                  = 163
	PhpParserMinusEqual                 = 164
	PhpParserMulEqual                   = 165
	PhpParserPow                        = 166
	PhpParserPowEqual                   = 167
	PhpParserDivEqual                   = 168
	PhpParserConcaequal                 = 169
	PhpParserModEqual                   = 170
	PhpParserShiftLeftEqual             = 171
	PhpParserShiftRightEqual            = 172
	PhpParserAndEqual                   = 173
	PhpParserOrEqual                    = 174
	PhpParserXorEqual                   = 175
	PhpParserBooleanOr                  = 176
	PhpParserBooleanAnd                 = 177
	PhpParserShiftLeft                  = 178
	PhpParserShiftRight                 = 179
	PhpParserDoubleColon                = 180
	PhpParserObjectOperator             = 181
	PhpParserNamespaceSeparator         = 182
	PhpParserEllipsis                   = 183
	PhpParserLess                       = 184
	PhpParserGreater                    = 185
	PhpParserAmpersand                  = 186
	PhpParserPipe                       = 187
	PhpParserBang                       = 188
	PhpParserCaret                      = 189
	PhpParserPlus                       = 190
	PhpParserMinus                      = 191
	PhpParserAsterisk                   = 192
	PhpParserPercent                    = 193
	PhpParserDivide                     = 194
	PhpParserTilde                      = 195
	PhpParserSuppressWarnings           = 196
	PhpParserDollar                     = 197
	PhpParserDot                        = 198
	PhpParserQuestionMark               = 199
	PhpParserOpenRoundBracket           = 200
	PhpParserCloseRoundBracket          = 201
	PhpParserOpenSquareBracket          = 202
	PhpParserCloseSquareBracket         = 203
	PhpParserOpenCurlyBracket           = 204
	PhpParserCloseCurlyBracket          = 205
	PhpParserComma                      = 206
	PhpParserColon                      = 207
	PhpParserSemiColon                  = 208
	PhpParserEq                         = 209
	PhpParserQuote                      = 210
	PhpParserBackQuote                  = 211
	PhpParserVarName                    = 212
	PhpParserLabel                      = 213
	PhpParserOctal                      = 214
	PhpParserDecimal                    = 215
	PhpParserReal                       = 216
	PhpParserHex                        = 217
	PhpParserBinary                     = 218
	PhpParserBackQuoteString            = 219
	PhpParserSingleQuoteString          = 220
	PhpParserDoubleQuote                = 221
	PhpParserStartNowDoc                = 222
	PhpParserStartHereDoc               = 223
	PhpParserErrorPhp                   = 224
	PhpParserCurlyDollar                = 225
	PhpParserStringPart                 = 226
	PhpParserComment                    = 227
	PhpParserPHPEndSingleLineComment    = 228
	PhpParserCommentEnd                 = 229
	PhpParserHereDocText                = 230
	PhpParserXmlText2                   = 231
)

// PhpParser rules.
const (
	PhpParserRULE_htmlDocument                  = 0
	PhpParserRULE_htmlElementOrPhpBlock         = 1
	PhpParserRULE_htmlElements                  = 2
	PhpParserRULE_htmlElement                   = 3
	PhpParserRULE_scriptTextPart                = 4
	PhpParserRULE_phpBlock                      = 5
	PhpParserRULE_importStatement               = 6
	PhpParserRULE_topStatement                  = 7
	PhpParserRULE_useDeclaration                = 8
	PhpParserRULE_useDeclarationContentList     = 9
	PhpParserRULE_useDeclarationContent         = 10
	PhpParserRULE_namespaceDeclaration          = 11
	PhpParserRULE_namespaceStatement            = 12
	PhpParserRULE_functionDeclaration           = 13
	PhpParserRULE_classDeclaration              = 14
	PhpParserRULE_classEntryType                = 15
	PhpParserRULE_interfaceList                 = 16
	PhpParserRULE_typeParameterListInBrackets   = 17
	PhpParserRULE_typeParameterList             = 18
	PhpParserRULE_typeParameterWithDefaultsList = 19
	PhpParserRULE_typeParameterDecl             = 20
	PhpParserRULE_typeParameterWithDefaultDecl  = 21
	PhpParserRULE_genericDynamicArgs            = 22
	PhpParserRULE_attributes                    = 23
	PhpParserRULE_attributesGroup               = 24
	PhpParserRULE_attribute                     = 25
	PhpParserRULE_attributeArgList              = 26
	PhpParserRULE_attributeNamedArgList         = 27
	PhpParserRULE_attributeNamedArg             = 28
	PhpParserRULE_innerStatementList            = 29
	PhpParserRULE_innerStatement                = 30
	PhpParserRULE_statement                     = 31
	PhpParserRULE_voidStatement                 = 32
	PhpParserRULE_blockStatement                = 33
	PhpParserRULE_ifStatement                   = 34
	PhpParserRULE_elseIfStatement               = 35
	PhpParserRULE_elseIfColonStatement          = 36
	PhpParserRULE_elseStatement                 = 37
	PhpParserRULE_elseColonStatement            = 38
	PhpParserRULE_whileStatement                = 39
	PhpParserRULE_doWhileStatement              = 40
	PhpParserRULE_forStatement                  = 41
	PhpParserRULE_forInit                       = 42
	PhpParserRULE_forUpdate                     = 43
	PhpParserRULE_switchStatement               = 44
	PhpParserRULE_switchBlock                   = 45
	PhpParserRULE_breakStatement                = 46
	PhpParserRULE_continueStatement             = 47
	PhpParserRULE_returnStatement               = 48
	PhpParserRULE_expressionStatement           = 49
	PhpParserRULE_unsetStatement                = 50
	PhpParserRULE_foreachStatement              = 51
	PhpParserRULE_tryCatchFinally               = 52
	PhpParserRULE_catchClause                   = 53
	PhpParserRULE_finallyStatement              = 54
	PhpParserRULE_throwStatement                = 55
	PhpParserRULE_gotoStatement                 = 56
	PhpParserRULE_declareStatement              = 57
	PhpParserRULE_inlineHtmlStatement           = 58
	PhpParserRULE_inlineHtml                    = 59
	PhpParserRULE_declareList                   = 60
	PhpParserRULE_formalParameterList           = 61
	PhpParserRULE_formalParameter               = 62
	PhpParserRULE_typeHint                      = 63
	PhpParserRULE_globalStatement               = 64
	PhpParserRULE_globalVar                     = 65
	PhpParserRULE_echoStatement                 = 66
	PhpParserRULE_staticVariableStatement       = 67
	PhpParserRULE_classStatement                = 68
	PhpParserRULE_traitAdaptations              = 69
	PhpParserRULE_traitAdaptationStatement      = 70
	PhpParserRULE_traitPrecedence               = 71
	PhpParserRULE_traitAlias                    = 72
	PhpParserRULE_traitMethodReference          = 73
	PhpParserRULE_baseCtorCall                  = 74
	PhpParserRULE_methodBody                    = 75
	PhpParserRULE_propertyModifiers             = 76
	PhpParserRULE_memberModifiers               = 77
	PhpParserRULE_variableInitializer           = 78
	PhpParserRULE_identifierInititalizer        = 79
	PhpParserRULE_globalConstantDeclaration     = 80
	PhpParserRULE_expressionList                = 81
	PhpParserRULE_parenthesis                   = 82
	PhpParserRULE_expression                    = 83
	PhpParserRULE_newExpr                       = 84
	PhpParserRULE_assignmentOperator            = 85
	PhpParserRULE_yieldExpression               = 86
	PhpParserRULE_arrayItemList                 = 87
	PhpParserRULE_arrayItem                     = 88
	PhpParserRULE_lambdaFunctionUseVars         = 89
	PhpParserRULE_lambdaFunctionUseVar          = 90
	PhpParserRULE_qualifiedStaticTypeRef        = 91
	PhpParserRULE_typeRef                       = 92
	PhpParserRULE_indirectTypeRef               = 93
	PhpParserRULE_qualifiedNamespaceName        = 94
	PhpParserRULE_namespaceNameList             = 95
	PhpParserRULE_qualifiedNamespaceNameList    = 96
	PhpParserRULE_arguments                     = 97
	PhpParserRULE_actualArgument                = 98
	PhpParserRULE_constantInititalizer          = 99
	PhpParserRULE_constantArrayItemList         = 100
	PhpParserRULE_constantArrayItem             = 101
	PhpParserRULE_constant                      = 102
	PhpParserRULE_literalConstant               = 103
	PhpParserRULE_numericConstant               = 104
	PhpParserRULE_classConstant                 = 105
	PhpParserRULE_stringConstant                = 106
	PhpParserRULE_str                           = 107
	PhpParserRULE_interpolatedStringPart        = 108
	PhpParserRULE_chainList                     = 109
	PhpParserRULE_chain                         = 110
	PhpParserRULE_memberAccess                  = 111
	PhpParserRULE_functionCall                  = 112
	PhpParserRULE_functionCallName              = 113
	PhpParserRULE_actualArguments               = 114
	PhpParserRULE_chainBase                     = 115
	PhpParserRULE_keyedFieldName                = 116
	PhpParserRULE_keyedSimpleFieldName          = 117
	PhpParserRULE_keyedVariable                 = 118
	PhpParserRULE_squareCurlyExpression         = 119
	PhpParserRULE_assignmentList                = 120
	PhpParserRULE_assignmentListElement         = 121
	PhpParserRULE_modifier                      = 122
	PhpParserRULE_identifier                    = 123
	PhpParserRULE_memberModifier                = 124
	PhpParserRULE_magicConstant                 = 125
	PhpParserRULE_magicMethod                   = 126
	PhpParserRULE_primitiveType                 = 127
	PhpParserRULE_castOperation                 = 128
)

// IHtmlDocumentContext is an interface to support dynamic dispatch.
type IHtmlDocumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHtmlDocumentContext differentiates from other interfaces.
	IsHtmlDocumentContext()
}

type HtmlDocumentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHtmlDocumentContext() *HtmlDocumentContext {
	var p = new(HtmlDocumentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_htmlDocument
	return p
}

func (*HtmlDocumentContext) IsHtmlDocumentContext() {}

func NewHtmlDocumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HtmlDocumentContext {
	var p = new(HtmlDocumentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_htmlDocument

	return p
}

func (s *HtmlDocumentContext) GetParser() antlr.Parser { return s.parser }

func (s *HtmlDocumentContext) EOF() antlr.TerminalNode {
	return s.GetToken(PhpParserEOF, 0)
}

func (s *HtmlDocumentContext) Shebang() antlr.TerminalNode {
	return s.GetToken(PhpParserShebang, 0)
}

func (s *HtmlDocumentContext) AllHtmlElementOrPhpBlock() []IHtmlElementOrPhpBlockContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IHtmlElementOrPhpBlockContext)(nil)).Elem())
	var tst = make([]IHtmlElementOrPhpBlockContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IHtmlElementOrPhpBlockContext)
		}
	}

	return tst
}

func (s *HtmlDocumentContext) HtmlElementOrPhpBlock(i int) IHtmlElementOrPhpBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHtmlElementOrPhpBlockContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IHtmlElementOrPhpBlockContext)
}

func (s *HtmlDocumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HtmlDocumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HtmlDocumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterHtmlDocument(s)
	}
}

func (s *HtmlDocumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitHtmlDocument(s)
	}
}

func (p *PhpParser) HtmlDocument() (localctx IHtmlDocumentContext) {
	localctx = NewHtmlDocumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, PhpParserRULE_htmlDocument)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(259)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PhpParserShebang {
		{
			p.SetState(258)
			p.Match(PhpParserShebang)
		}

	}
	p.SetState(264)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PhpParserHtmlText)|(1<<PhpParserXmlStart)|(1<<PhpParserHtmlScriptOpen)|(1<<PhpParserHtmlStyleOpen)|(1<<PhpParserHtmlDtd)|(1<<PhpParserHtmlOpen)|(1<<PhpParserHtmlClose)|(1<<PhpParserHtmlSlashClose)|(1<<PhpParserHtmlSlash)|(1<<PhpParserHtmlEquals)|(1<<PhpParserHtmlStartQuoteString)|(1<<PhpParserHtmlStartDoubleQuoteString)|(1<<PhpParserHtmlHex)|(1<<PhpParserHtmlDecimal)|(1<<PhpParserHtmlName)|(1<<PhpParserHtmlEndQuoteString)|(1<<PhpParserHtmlQuoteString)|(1<<PhpParserHtmlEndDoubleQuoteString))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(PhpParserHtmlDoubleQuoteString-32))|(1<<(PhpParserScriptText-32))|(1<<(PhpParserScriptClose-32))|(1<<(PhpParserStyleBody-32))|(1<<(PhpParserAbstract-32))|(1<<(PhpParserArray-32))|(1<<(PhpParserAs-32))|(1<<(PhpParserBinaryCast-32))|(1<<(PhpParserBoolType-32))|(1<<(PhpParserBooleanConstant-32))|(1<<(PhpParserBreak-32))|(1<<(PhpParserCallable-32))|(1<<(PhpParserCase-32))|(1<<(PhpParserCatch-32))|(1<<(PhpParserClass-32))|(1<<(PhpParserClone-32))|(1<<(PhpParserConst-32))|(1<<(PhpParserContinue-32))|(1<<(PhpParserDeclare-32))|(1<<(PhpParserDefault-32))|(1<<(PhpParserDo-32))|(1<<(PhpParserDoubleCast-32))|(1<<(PhpParserDoubleType-32))|(1<<(PhpParserEcho-32))|(1<<(PhpParserElse-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(PhpParserElseIf-64))|(1<<(PhpParserEmpty-64))|(1<<(PhpParserEndDeclare-64))|(1<<(PhpParserEndFor-64))|(1<<(PhpParserEndForeach-64))|(1<<(PhpParserEndIf-64))|(1<<(PhpParserEndSwitch-64))|(1<<(PhpParserEndWhile-64))|(1<<(PhpParserEval-64))|(1<<(PhpParserExit-64))|(1<<(PhpParserExtends-64))|(1<<(PhpParserFinal-64))|(1<<(PhpParserFinally-64))|(1<<(PhpParserFloatCast-64))|(1<<(PhpParserFor-64))|(1<<(PhpParserForeach-64))|(1<<(PhpParserFunction-64))|(1<<(PhpParserGlobal-64))|(1<<(PhpParserGoto-64))|(1<<(PhpParserIf-64))|(1<<(PhpParserImplements-64))|(1<<(PhpParserImport-64))|(1<<(PhpParserInclude-64))|(1<<(PhpParserIncludeOnce-64))|(1<<(PhpParserInstanceOf-64))|(1<<(PhpParserInsteadOf-64))|(1<<(PhpParserInt8Cast-64))|(1<<(PhpParserInt16Cast-64))|(1<<(PhpParserInt64Type-64))|(1<<(PhpParserIntType-64))|(1<<(PhpParserInterface-64))|(1<<(PhpParserIsSet-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(PhpParserList-96))|(1<<(PhpParserLogicalAnd-96))|(1<<(PhpParserLogicalOr-96))|(1<<(PhpParserLogicalXor-96))|(1<<(PhpParserNamespace-96))|(1<<(PhpParserNew-96))|(1<<(PhpParserNull-96))|(1<<(PhpParserObjectType-96))|(1<<(PhpParserParent_-96))|(1<<(PhpParserPartial-96))|(1<<(PhpParserPrint-96))|(1<<(PhpParserPrivate-96))|(1<<(PhpParserProtected-96))|(1<<(PhpParserPublic-96))|(1<<(PhpParserRequire-96))|(1<<(PhpParserRequireOnce-96))|(1<<(PhpParserResource-96))|(1<<(PhpParserReturn-96))|(1<<(PhpParserStatic-96))|(1<<(PhpParserStringType-96))|(1<<(PhpParserSwitch-96))|(1<<(PhpParserThrow-96))|(1<<(PhpParserTrait-96))|(1<<(PhpParserTry-96))|(1<<(PhpParserTypeof-96))|(1<<(PhpParserUintCast-96))|(1<<(PhpParserUnicodeCast-96))|(1<<(PhpParserUnset-96))|(1<<(PhpParserUse-96))|(1<<(PhpParserVar-96))|(1<<(PhpParserWhile-96))|(1<<(PhpParserYield-96)))) != 0) || (((_la-128)&-(0x1f+1)) == 0 && ((1<<uint((_la-128)))&((1<<(PhpParserGet-128))|(1<<(PhpParserSet-128))|(1<<(PhpParserCall-128))|(1<<(PhpParserCallStatic-128))|(1<<(PhpParserConstructor-128))|(1<<(PhpParserDestruct-128))|(1<<(PhpParserWakeup-128))|(1<<(PhpParserSleep-128))|(1<<(PhpParserAutoload-128))|(1<<(PhpParserIsSet__-128))|(1<<(PhpParserUnset__-128))|(1<<(PhpParserToString__-128))|(1<<(PhpParserInvoke-128))|(1<<(PhpParserSetState-128))|(1<<(PhpParserClone__-128))|(1<<(PhpParserDebugInfo-128))|(1<<(PhpParserNamespace__-128))|(1<<(PhpParserClass__-128))|(1<<(PhpParserTraic__-128))|(1<<(PhpParserFunction__-128))|(1<<(PhpParserMethod__-128))|(1<<(PhpParserLine__-128))|(1<<(PhpParserFile__-128))|(1<<(PhpParserDir__-128))|(1<<(PhpParserInc-128))|(1<<(PhpParserDec-128)))) != 0) || (((_la-182)&-(0x1f+1)) == 0 && ((1<<uint((_la-182)))&((1<<(PhpParserNamespaceSeparator-182))|(1<<(PhpParserBang-182))|(1<<(PhpParserPlus-182))|(1<<(PhpParserMinus-182))|(1<<(PhpParserTilde-182))|(1<<(PhpParserSuppressWarnings-182))|(1<<(PhpParserDollar-182))|(1<<(PhpParserOpenRoundBracket-182))|(1<<(PhpParserOpenSquareBracket-182))|(1<<(PhpParserOpenCurlyBracket-182))|(1<<(PhpParserSemiColon-182))|(1<<(PhpParserVarName-182))|(1<<(PhpParserLabel-182)))) != 0) || (((_la-214)&-(0x1f+1)) == 0 && ((1<<uint((_la-214)))&((1<<(PhpParserOctal-214))|(1<<(PhpParserDecimal-214))|(1<<(PhpParserReal-214))|(1<<(PhpParserHex-214))|(1<<(PhpParserBinary-214))|(1<<(PhpParserBackQuoteString-214))|(1<<(PhpParserSingleQuoteString-214))|(1<<(PhpParserDoubleQuote-214))|(1<<(PhpParserStartNowDoc-214))|(1<<(PhpParserStartHereDoc-214)))) != 0) {
		{
			p.SetState(261)
			p.HtmlElementOrPhpBlock()
		}

		p.SetState(266)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(267)
		p.Match(PhpParserEOF)
	}

	return localctx
}

// IHtmlElementOrPhpBlockContext is an interface to support dynamic dispatch.
type IHtmlElementOrPhpBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHtmlElementOrPhpBlockContext differentiates from other interfaces.
	IsHtmlElementOrPhpBlockContext()
}

type HtmlElementOrPhpBlockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHtmlElementOrPhpBlockContext() *HtmlElementOrPhpBlockContext {
	var p = new(HtmlElementOrPhpBlockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_htmlElementOrPhpBlock
	return p
}

func (*HtmlElementOrPhpBlockContext) IsHtmlElementOrPhpBlockContext() {}

func NewHtmlElementOrPhpBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HtmlElementOrPhpBlockContext {
	var p = new(HtmlElementOrPhpBlockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_htmlElementOrPhpBlock

	return p
}

func (s *HtmlElementOrPhpBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *HtmlElementOrPhpBlockContext) HtmlElements() IHtmlElementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHtmlElementsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHtmlElementsContext)
}

func (s *HtmlElementOrPhpBlockContext) PhpBlock() IPhpBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPhpBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPhpBlockContext)
}

func (s *HtmlElementOrPhpBlockContext) ScriptTextPart() IScriptTextPartContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScriptTextPartContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IScriptTextPartContext)
}

func (s *HtmlElementOrPhpBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HtmlElementOrPhpBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HtmlElementOrPhpBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterHtmlElementOrPhpBlock(s)
	}
}

func (s *HtmlElementOrPhpBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitHtmlElementOrPhpBlock(s)
	}
}

func (p *PhpParser) HtmlElementOrPhpBlock() (localctx IHtmlElementOrPhpBlockContext) {
	localctx = NewHtmlElementOrPhpBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, PhpParserRULE_htmlElementOrPhpBlock)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(272)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 2, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(269)
			p.HtmlElements()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(270)
			p.PhpBlock()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(271)
			p.ScriptTextPart()
		}

	}

	return localctx
}

// IHtmlElementsContext is an interface to support dynamic dispatch.
type IHtmlElementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHtmlElementsContext differentiates from other interfaces.
	IsHtmlElementsContext()
}

type HtmlElementsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHtmlElementsContext() *HtmlElementsContext {
	var p = new(HtmlElementsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_htmlElements
	return p
}

func (*HtmlElementsContext) IsHtmlElementsContext() {}

func NewHtmlElementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HtmlElementsContext {
	var p = new(HtmlElementsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_htmlElements

	return p
}

func (s *HtmlElementsContext) GetParser() antlr.Parser { return s.parser }

func (s *HtmlElementsContext) AllHtmlElement() []IHtmlElementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IHtmlElementContext)(nil)).Elem())
	var tst = make([]IHtmlElementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IHtmlElementContext)
		}
	}

	return tst
}

func (s *HtmlElementsContext) HtmlElement(i int) IHtmlElementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHtmlElementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IHtmlElementContext)
}

func (s *HtmlElementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HtmlElementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HtmlElementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterHtmlElements(s)
	}
}

func (s *HtmlElementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitHtmlElements(s)
	}
}

func (p *PhpParser) HtmlElements() (localctx IHtmlElementsContext) {
	localctx = NewHtmlElementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, PhpParserRULE_htmlElements)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(275)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(274)
				p.HtmlElement()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(277)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 3, p.GetParserRuleContext())
	}

	return localctx
}

// IHtmlElementContext is an interface to support dynamic dispatch.
type IHtmlElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHtmlElementContext differentiates from other interfaces.
	IsHtmlElementContext()
}

type HtmlElementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHtmlElementContext() *HtmlElementContext {
	var p = new(HtmlElementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_htmlElement
	return p
}

func (*HtmlElementContext) IsHtmlElementContext() {}

func NewHtmlElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HtmlElementContext {
	var p = new(HtmlElementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_htmlElement

	return p
}

func (s *HtmlElementContext) GetParser() antlr.Parser { return s.parser }

func (s *HtmlElementContext) HtmlDtd() antlr.TerminalNode {
	return s.GetToken(PhpParserHtmlDtd, 0)
}

func (s *HtmlElementContext) HtmlScriptOpen() antlr.TerminalNode {
	return s.GetToken(PhpParserHtmlScriptOpen, 0)
}

func (s *HtmlElementContext) HtmlClose() antlr.TerminalNode {
	return s.GetToken(PhpParserHtmlClose, 0)
}

func (s *HtmlElementContext) HtmlStyleOpen() antlr.TerminalNode {
	return s.GetToken(PhpParserHtmlStyleOpen, 0)
}

func (s *HtmlElementContext) HtmlOpen() antlr.TerminalNode {
	return s.GetToken(PhpParserHtmlOpen, 0)
}

func (s *HtmlElementContext) HtmlName() antlr.TerminalNode {
	return s.GetToken(PhpParserHtmlName, 0)
}

func (s *HtmlElementContext) HtmlSlashClose() antlr.TerminalNode {
	return s.GetToken(PhpParserHtmlSlashClose, 0)
}

func (s *HtmlElementContext) HtmlSlash() antlr.TerminalNode {
	return s.GetToken(PhpParserHtmlSlash, 0)
}

func (s *HtmlElementContext) HtmlText() antlr.TerminalNode {
	return s.GetToken(PhpParserHtmlText, 0)
}

func (s *HtmlElementContext) HtmlEquals() antlr.TerminalNode {
	return s.GetToken(PhpParserHtmlEquals, 0)
}

func (s *HtmlElementContext) HtmlStartQuoteString() antlr.TerminalNode {
	return s.GetToken(PhpParserHtmlStartQuoteString, 0)
}

func (s *HtmlElementContext) HtmlEndQuoteString() antlr.TerminalNode {
	return s.GetToken(PhpParserHtmlEndQuoteString, 0)
}

func (s *HtmlElementContext) HtmlStartDoubleQuoteString() antlr.TerminalNode {
	return s.GetToken(PhpParserHtmlStartDoubleQuoteString, 0)
}

func (s *HtmlElementContext) HtmlEndDoubleQuoteString() antlr.TerminalNode {
	return s.GetToken(PhpParserHtmlEndDoubleQuoteString, 0)
}

func (s *HtmlElementContext) HtmlHex() antlr.TerminalNode {
	return s.GetToken(PhpParserHtmlHex, 0)
}

func (s *HtmlElementContext) HtmlDecimal() antlr.TerminalNode {
	return s.GetToken(PhpParserHtmlDecimal, 0)
}

func (s *HtmlElementContext) HtmlQuoteString() antlr.TerminalNode {
	return s.GetToken(PhpParserHtmlQuoteString, 0)
}

func (s *HtmlElementContext) HtmlDoubleQuoteString() antlr.TerminalNode {
	return s.GetToken(PhpParserHtmlDoubleQuoteString, 0)
}

func (s *HtmlElementContext) StyleBody() antlr.TerminalNode {
	return s.GetToken(PhpParserStyleBody, 0)
}

func (s *HtmlElementContext) ScriptClose() antlr.TerminalNode {
	return s.GetToken(PhpParserScriptClose, 0)
}

func (s *HtmlElementContext) XmlStart() antlr.TerminalNode {
	return s.GetToken(PhpParserXmlStart, 0)
}

func (s *HtmlElementContext) XmlClose() antlr.TerminalNode {
	return s.GetToken(PhpParserXmlClose, 0)
}

func (s *HtmlElementContext) AllXmlText() []antlr.TerminalNode {
	return s.GetTokens(PhpParserXmlText)
}

func (s *HtmlElementContext) XmlText(i int) antlr.TerminalNode {
	return s.GetToken(PhpParserXmlText, i)
}

func (s *HtmlElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HtmlElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HtmlElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterHtmlElement(s)
	}
}

func (s *HtmlElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitHtmlElement(s)
	}
}

func (p *PhpParser) HtmlElement() (localctx IHtmlElementContext) {
	localctx = NewHtmlElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, PhpParserRULE_htmlElement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(307)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PhpParserHtmlDtd:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(279)
			p.Match(PhpParserHtmlDtd)
		}

	case PhpParserHtmlScriptOpen:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(280)
			p.Match(PhpParserHtmlScriptOpen)
		}

	case PhpParserHtmlClose:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(281)
			p.Match(PhpParserHtmlClose)
		}

	case PhpParserHtmlStyleOpen:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(282)
			p.Match(PhpParserHtmlStyleOpen)
		}

	case PhpParserHtmlOpen:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(283)
			p.Match(PhpParserHtmlOpen)
		}

	case PhpParserHtmlName:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(284)
			p.Match(PhpParserHtmlName)
		}

	case PhpParserHtmlSlashClose:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(285)
			p.Match(PhpParserHtmlSlashClose)
		}

	case PhpParserHtmlSlash:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(286)
			p.Match(PhpParserHtmlSlash)
		}

	case PhpParserHtmlText:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(287)
			p.Match(PhpParserHtmlText)
		}

	case PhpParserHtmlEquals:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(288)
			p.Match(PhpParserHtmlEquals)
		}

	case PhpParserHtmlStartQuoteString:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(289)
			p.Match(PhpParserHtmlStartQuoteString)
		}

	case PhpParserHtmlEndQuoteString:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(290)
			p.Match(PhpParserHtmlEndQuoteString)
		}

	case PhpParserHtmlStartDoubleQuoteString:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(291)
			p.Match(PhpParserHtmlStartDoubleQuoteString)
		}

	case PhpParserHtmlEndDoubleQuoteString:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(292)
			p.Match(PhpParserHtmlEndDoubleQuoteString)
		}

	case PhpParserHtmlHex:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(293)
			p.Match(PhpParserHtmlHex)
		}

	case PhpParserHtmlDecimal:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(294)
			p.Match(PhpParserHtmlDecimal)
		}

	case PhpParserHtmlQuoteString:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(295)
			p.Match(PhpParserHtmlQuoteString)
		}

	case PhpParserHtmlDoubleQuoteString:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(296)
			p.Match(PhpParserHtmlDoubleQuoteString)
		}

	case PhpParserStyleBody:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(297)
			p.Match(PhpParserStyleBody)
		}

	case PhpParserScriptClose:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(298)
			p.Match(PhpParserScriptClose)
		}

	case PhpParserXmlStart:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(299)
			p.Match(PhpParserXmlStart)
		}
		p.SetState(303)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == PhpParserXmlText {
			{
				p.SetState(300)
				p.Match(PhpParserXmlText)
			}

			p.SetState(305)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(306)
			p.Match(PhpParserXmlClose)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IScriptTextPartContext is an interface to support dynamic dispatch.
type IScriptTextPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScriptTextPartContext differentiates from other interfaces.
	IsScriptTextPartContext()
}

type ScriptTextPartContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScriptTextPartContext() *ScriptTextPartContext {
	var p = new(ScriptTextPartContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_scriptTextPart
	return p
}

func (*ScriptTextPartContext) IsScriptTextPartContext() {}

func NewScriptTextPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScriptTextPartContext {
	var p = new(ScriptTextPartContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_scriptTextPart

	return p
}

func (s *ScriptTextPartContext) GetParser() antlr.Parser { return s.parser }

func (s *ScriptTextPartContext) AllScriptText() []antlr.TerminalNode {
	return s.GetTokens(PhpParserScriptText)
}

func (s *ScriptTextPartContext) ScriptText(i int) antlr.TerminalNode {
	return s.GetToken(PhpParserScriptText, i)
}

func (s *ScriptTextPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScriptTextPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScriptTextPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterScriptTextPart(s)
	}
}

func (s *ScriptTextPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitScriptTextPart(s)
	}
}

func (p *PhpParser) ScriptTextPart() (localctx IScriptTextPartContext) {
	localctx = NewScriptTextPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, PhpParserRULE_scriptTextPart)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(310)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(309)
				p.Match(PhpParserScriptText)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(312)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 6, p.GetParserRuleContext())
	}

	return localctx
}

// IPhpBlockContext is an interface to support dynamic dispatch.
type IPhpBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPhpBlockContext differentiates from other interfaces.
	IsPhpBlockContext()
}

type PhpBlockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPhpBlockContext() *PhpBlockContext {
	var p = new(PhpBlockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_phpBlock
	return p
}

func (*PhpBlockContext) IsPhpBlockContext() {}

func NewPhpBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PhpBlockContext {
	var p = new(PhpBlockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_phpBlock

	return p
}

func (s *PhpBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *PhpBlockContext) AllImportStatement() []IImportStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IImportStatementContext)(nil)).Elem())
	var tst = make([]IImportStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IImportStatementContext)
		}
	}

	return tst
}

func (s *PhpBlockContext) ImportStatement(i int) IImportStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImportStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IImportStatementContext)
}

func (s *PhpBlockContext) AllTopStatement() []ITopStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITopStatementContext)(nil)).Elem())
	var tst = make([]ITopStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITopStatementContext)
		}
	}

	return tst
}

func (s *PhpBlockContext) TopStatement(i int) ITopStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITopStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITopStatementContext)
}

func (s *PhpBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PhpBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PhpBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterPhpBlock(s)
	}
}

func (s *PhpBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitPhpBlock(s)
	}
}

func (p *PhpParser) PhpBlock() (localctx IPhpBlockContext) {
	localctx = NewPhpBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, PhpParserRULE_phpBlock)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(317)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 7, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(314)
				p.ImportStatement()
			}

		}
		p.SetState(319)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 7, p.GetParserRuleContext())
	}
	p.SetState(321)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(320)
				p.TopStatement()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(323)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 8, p.GetParserRuleContext())
	}

	return localctx
}

// IImportStatementContext is an interface to support dynamic dispatch.
type IImportStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImportStatementContext differentiates from other interfaces.
	IsImportStatementContext()
}

type ImportStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportStatementContext() *ImportStatementContext {
	var p = new(ImportStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_importStatement
	return p
}

func (*ImportStatementContext) IsImportStatementContext() {}

func NewImportStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportStatementContext {
	var p = new(ImportStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_importStatement

	return p
}

func (s *ImportStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportStatementContext) Import() antlr.TerminalNode {
	return s.GetToken(PhpParserImport, 0)
}

func (s *ImportStatementContext) Namespace() antlr.TerminalNode {
	return s.GetToken(PhpParserNamespace, 0)
}

func (s *ImportStatementContext) NamespaceNameList() INamespaceNameListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INamespaceNameListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INamespaceNameListContext)
}

func (s *ImportStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterImportStatement(s)
	}
}

func (s *ImportStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitImportStatement(s)
	}
}

func (p *PhpParser) ImportStatement() (localctx IImportStatementContext) {
	localctx = NewImportStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, PhpParserRULE_importStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(325)
		p.Match(PhpParserImport)
	}
	{
		p.SetState(326)
		p.Match(PhpParserNamespace)
	}
	{
		p.SetState(327)
		p.NamespaceNameList()
	}
	{
		p.SetState(328)
		p.Match(PhpParserSemiColon)
	}

	return localctx
}

// ITopStatementContext is an interface to support dynamic dispatch.
type ITopStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTopStatementContext differentiates from other interfaces.
	IsTopStatementContext()
}

type TopStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTopStatementContext() *TopStatementContext {
	var p = new(TopStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_topStatement
	return p
}

func (*TopStatementContext) IsTopStatementContext() {}

func NewTopStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TopStatementContext {
	var p = new(TopStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_topStatement

	return p
}

func (s *TopStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *TopStatementContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *TopStatementContext) UseDeclaration() IUseDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUseDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUseDeclarationContext)
}

func (s *TopStatementContext) NamespaceDeclaration() INamespaceDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INamespaceDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INamespaceDeclarationContext)
}

func (s *TopStatementContext) FunctionDeclaration() IFunctionDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionDeclarationContext)
}

func (s *TopStatementContext) ClassDeclaration() IClassDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassDeclarationContext)
}

func (s *TopStatementContext) GlobalConstantDeclaration() IGlobalConstantDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGlobalConstantDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGlobalConstantDeclarationContext)
}

func (s *TopStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TopStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TopStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterTopStatement(s)
	}
}

func (s *TopStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitTopStatement(s)
	}
}

func (p *PhpParser) TopStatement() (localctx ITopStatementContext) {
	localctx = NewTopStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, PhpParserRULE_topStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(336)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 9, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(330)
			p.Statement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(331)
			p.UseDeclaration()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(332)
			p.NamespaceDeclaration()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(333)
			p.FunctionDeclaration()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(334)
			p.ClassDeclaration()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(335)
			p.GlobalConstantDeclaration()
		}

	}

	return localctx
}

// IUseDeclarationContext is an interface to support dynamic dispatch.
type IUseDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUseDeclarationContext differentiates from other interfaces.
	IsUseDeclarationContext()
}

type UseDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUseDeclarationContext() *UseDeclarationContext {
	var p = new(UseDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_useDeclaration
	return p
}

func (*UseDeclarationContext) IsUseDeclarationContext() {}

func NewUseDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UseDeclarationContext {
	var p = new(UseDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_useDeclaration

	return p
}

func (s *UseDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *UseDeclarationContext) Use() antlr.TerminalNode {
	return s.GetToken(PhpParserUse, 0)
}

func (s *UseDeclarationContext) UseDeclarationContentList() IUseDeclarationContentListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUseDeclarationContentListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUseDeclarationContentListContext)
}

func (s *UseDeclarationContext) Function() antlr.TerminalNode {
	return s.GetToken(PhpParserFunction, 0)
}

func (s *UseDeclarationContext) Const() antlr.TerminalNode {
	return s.GetToken(PhpParserConst, 0)
}

func (s *UseDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UseDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UseDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterUseDeclaration(s)
	}
}

func (s *UseDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitUseDeclaration(s)
	}
}

func (p *PhpParser) UseDeclaration() (localctx IUseDeclarationContext) {
	localctx = NewUseDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, PhpParserRULE_useDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(338)
		p.Match(PhpParserUse)
	}
	p.SetState(340)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 10, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(339)
			_la = p.GetTokenStream().LA(1)

			if !(_la == PhpParserConst || _la == PhpParserFunction) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(342)
		p.UseDeclarationContentList()
	}
	{
		p.SetState(343)
		p.Match(PhpParserSemiColon)
	}

	return localctx
}

// IUseDeclarationContentListContext is an interface to support dynamic dispatch.
type IUseDeclarationContentListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUseDeclarationContentListContext differentiates from other interfaces.
	IsUseDeclarationContentListContext()
}

type UseDeclarationContentListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUseDeclarationContentListContext() *UseDeclarationContentListContext {
	var p = new(UseDeclarationContentListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_useDeclarationContentList
	return p
}

func (*UseDeclarationContentListContext) IsUseDeclarationContentListContext() {}

func NewUseDeclarationContentListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UseDeclarationContentListContext {
	var p = new(UseDeclarationContentListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_useDeclarationContentList

	return p
}

func (s *UseDeclarationContentListContext) GetParser() antlr.Parser { return s.parser }

func (s *UseDeclarationContentListContext) AllUseDeclarationContent() []IUseDeclarationContentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IUseDeclarationContentContext)(nil)).Elem())
	var tst = make([]IUseDeclarationContentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IUseDeclarationContentContext)
		}
	}

	return tst
}

func (s *UseDeclarationContentListContext) UseDeclarationContent(i int) IUseDeclarationContentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUseDeclarationContentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IUseDeclarationContentContext)
}

func (s *UseDeclarationContentListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UseDeclarationContentListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UseDeclarationContentListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterUseDeclarationContentList(s)
	}
}

func (s *UseDeclarationContentListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitUseDeclarationContentList(s)
	}
}

func (p *PhpParser) UseDeclarationContentList() (localctx IUseDeclarationContentListContext) {
	localctx = NewUseDeclarationContentListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, PhpParserRULE_useDeclarationContentList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(346)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PhpParserNamespaceSeparator {
		{
			p.SetState(345)
			p.Match(PhpParserNamespaceSeparator)
		}

	}
	{
		p.SetState(348)
		p.UseDeclarationContent()
	}
	p.SetState(356)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PhpParserComma {
		{
			p.SetState(349)
			p.Match(PhpParserComma)
		}
		p.SetState(351)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PhpParserNamespaceSeparator {
			{
				p.SetState(350)
				p.Match(PhpParserNamespaceSeparator)
			}

		}
		{
			p.SetState(353)
			p.UseDeclarationContent()
		}

		p.SetState(358)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IUseDeclarationContentContext is an interface to support dynamic dispatch.
type IUseDeclarationContentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUseDeclarationContentContext differentiates from other interfaces.
	IsUseDeclarationContentContext()
}

type UseDeclarationContentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUseDeclarationContentContext() *UseDeclarationContentContext {
	var p = new(UseDeclarationContentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_useDeclarationContent
	return p
}

func (*UseDeclarationContentContext) IsUseDeclarationContentContext() {}

func NewUseDeclarationContentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UseDeclarationContentContext {
	var p = new(UseDeclarationContentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_useDeclarationContent

	return p
}

func (s *UseDeclarationContentContext) GetParser() antlr.Parser { return s.parser }

func (s *UseDeclarationContentContext) NamespaceNameList() INamespaceNameListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INamespaceNameListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INamespaceNameListContext)
}

func (s *UseDeclarationContentContext) As() antlr.TerminalNode {
	return s.GetToken(PhpParserAs, 0)
}

func (s *UseDeclarationContentContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *UseDeclarationContentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UseDeclarationContentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UseDeclarationContentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterUseDeclarationContent(s)
	}
}

func (s *UseDeclarationContentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitUseDeclarationContent(s)
	}
}

func (p *PhpParser) UseDeclarationContent() (localctx IUseDeclarationContentContext) {
	localctx = NewUseDeclarationContentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, PhpParserRULE_useDeclarationContent)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(359)
		p.NamespaceNameList()
	}
	p.SetState(362)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PhpParserAs {
		{
			p.SetState(360)
			p.Match(PhpParserAs)
		}
		{
			p.SetState(361)
			p.Identifier()
		}

	}

	return localctx
}

// INamespaceDeclarationContext is an interface to support dynamic dispatch.
type INamespaceDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNamespaceDeclarationContext differentiates from other interfaces.
	IsNamespaceDeclarationContext()
}

type NamespaceDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamespaceDeclarationContext() *NamespaceDeclarationContext {
	var p = new(NamespaceDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_namespaceDeclaration
	return p
}

func (*NamespaceDeclarationContext) IsNamespaceDeclarationContext() {}

func NewNamespaceDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamespaceDeclarationContext {
	var p = new(NamespaceDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_namespaceDeclaration

	return p
}

func (s *NamespaceDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *NamespaceDeclarationContext) Namespace() antlr.TerminalNode {
	return s.GetToken(PhpParserNamespace, 0)
}

func (s *NamespaceDeclarationContext) OpenCurlyBracket() antlr.TerminalNode {
	return s.GetToken(PhpParserOpenCurlyBracket, 0)
}

func (s *NamespaceDeclarationContext) NamespaceNameList() INamespaceNameListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INamespaceNameListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INamespaceNameListContext)
}

func (s *NamespaceDeclarationContext) AllNamespaceStatement() []INamespaceStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INamespaceStatementContext)(nil)).Elem())
	var tst = make([]INamespaceStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INamespaceStatementContext)
		}
	}

	return tst
}

func (s *NamespaceDeclarationContext) NamespaceStatement(i int) INamespaceStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INamespaceStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INamespaceStatementContext)
}

func (s *NamespaceDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamespaceDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamespaceDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterNamespaceDeclaration(s)
	}
}

func (s *NamespaceDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitNamespaceDeclaration(s)
	}
}

func (p *PhpParser) NamespaceDeclaration() (localctx INamespaceDeclarationContext) {
	localctx = NewNamespaceDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, PhpParserRULE_namespaceDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(364)
		p.Match(PhpParserNamespace)
	}
	p.SetState(379)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 17, p.GetParserRuleContext()) {
	case 1:
		p.SetState(366)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la-43)&-(0x1f+1)) == 0 && ((1<<uint((_la-43)))&((1<<(PhpParserAbstract-43))|(1<<(PhpParserArray-43))|(1<<(PhpParserAs-43))|(1<<(PhpParserBinaryCast-43))|(1<<(PhpParserBoolType-43))|(1<<(PhpParserBooleanConstant-43))|(1<<(PhpParserBreak-43))|(1<<(PhpParserCallable-43))|(1<<(PhpParserCase-43))|(1<<(PhpParserCatch-43))|(1<<(PhpParserClass-43))|(1<<(PhpParserClone-43))|(1<<(PhpParserConst-43))|(1<<(PhpParserContinue-43))|(1<<(PhpParserDeclare-43))|(1<<(PhpParserDefault-43))|(1<<(PhpParserDo-43))|(1<<(PhpParserDoubleCast-43))|(1<<(PhpParserDoubleType-43))|(1<<(PhpParserEcho-43))|(1<<(PhpParserElse-43))|(1<<(PhpParserElseIf-43))|(1<<(PhpParserEmpty-43))|(1<<(PhpParserEndDeclare-43))|(1<<(PhpParserEndFor-43))|(1<<(PhpParserEndForeach-43))|(1<<(PhpParserEndIf-43))|(1<<(PhpParserEndSwitch-43))|(1<<(PhpParserEndWhile-43))|(1<<(PhpParserEval-43))|(1<<(PhpParserExit-43))|(1<<(PhpParserExtends-43)))) != 0) || (((_la-75)&-(0x1f+1)) == 0 && ((1<<uint((_la-75)))&((1<<(PhpParserFinal-75))|(1<<(PhpParserFinally-75))|(1<<(PhpParserFloatCast-75))|(1<<(PhpParserFor-75))|(1<<(PhpParserForeach-75))|(1<<(PhpParserFunction-75))|(1<<(PhpParserGlobal-75))|(1<<(PhpParserGoto-75))|(1<<(PhpParserIf-75))|(1<<(PhpParserImplements-75))|(1<<(PhpParserImport-75))|(1<<(PhpParserInclude-75))|(1<<(PhpParserIncludeOnce-75))|(1<<(PhpParserInstanceOf-75))|(1<<(PhpParserInsteadOf-75))|(1<<(PhpParserInt8Cast-75))|(1<<(PhpParserInt16Cast-75))|(1<<(PhpParserInt64Type-75))|(1<<(PhpParserIntType-75))|(1<<(PhpParserInterface-75))|(1<<(PhpParserIsSet-75))|(1<<(PhpParserList-75))|(1<<(PhpParserLogicalAnd-75))|(1<<(PhpParserLogicalOr-75))|(1<<(PhpParserLogicalXor-75))|(1<<(PhpParserNamespace-75))|(1<<(PhpParserNew-75))|(1<<(PhpParserNull-75))|(1<<(PhpParserObjectType-75))|(1<<(PhpParserParent_-75))|(1<<(PhpParserPartial-75))|(1<<(PhpParserPrint-75)))) != 0) || (((_la-107)&-(0x1f+1)) == 0 && ((1<<uint((_la-107)))&((1<<(PhpParserPrivate-107))|(1<<(PhpParserProtected-107))|(1<<(PhpParserPublic-107))|(1<<(PhpParserRequire-107))|(1<<(PhpParserRequireOnce-107))|(1<<(PhpParserResource-107))|(1<<(PhpParserReturn-107))|(1<<(PhpParserStatic-107))|(1<<(PhpParserStringType-107))|(1<<(PhpParserSwitch-107))|(1<<(PhpParserThrow-107))|(1<<(PhpParserTrait-107))|(1<<(PhpParserTry-107))|(1<<(PhpParserTypeof-107))|(1<<(PhpParserUintCast-107))|(1<<(PhpParserUnicodeCast-107))|(1<<(PhpParserUnset-107))|(1<<(PhpParserUse-107))|(1<<(PhpParserVar-107))|(1<<(PhpParserWhile-107))|(1<<(PhpParserYield-107))|(1<<(PhpParserGet-107))|(1<<(PhpParserSet-107))|(1<<(PhpParserCall-107))|(1<<(PhpParserCallStatic-107))|(1<<(PhpParserConstructor-107))|(1<<(PhpParserDestruct-107))|(1<<(PhpParserWakeup-107))|(1<<(PhpParserSleep-107))|(1<<(PhpParserAutoload-107))|(1<<(PhpParserIsSet__-107))|(1<<(PhpParserUnset__-107)))) != 0) || (((_la-139)&-(0x1f+1)) == 0 && ((1<<uint((_la-139)))&((1<<(PhpParserToString__-139))|(1<<(PhpParserInvoke-139))|(1<<(PhpParserSetState-139))|(1<<(PhpParserClone__-139))|(1<<(PhpParserDebugInfo-139))|(1<<(PhpParserNamespace__-139))|(1<<(PhpParserClass__-139))|(1<<(PhpParserTraic__-139))|(1<<(PhpParserFunction__-139))|(1<<(PhpParserMethod__-139))|(1<<(PhpParserLine__-139))|(1<<(PhpParserFile__-139))|(1<<(PhpParserDir__-139)))) != 0) || _la == PhpParserLabel {
			{
				p.SetState(365)
				p.NamespaceNameList()
			}

		}
		{
			p.SetState(368)
			p.Match(PhpParserOpenCurlyBracket)
		}
		p.SetState(372)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<PhpParserHtmlText)|(1<<PhpParserXmlStart)|(1<<PhpParserHtmlScriptOpen)|(1<<PhpParserHtmlStyleOpen)|(1<<PhpParserHtmlDtd)|(1<<PhpParserHtmlOpen)|(1<<PhpParserHtmlClose)|(1<<PhpParserHtmlSlashClose)|(1<<PhpParserHtmlSlash)|(1<<PhpParserHtmlEquals)|(1<<PhpParserHtmlStartQuoteString)|(1<<PhpParserHtmlStartDoubleQuoteString)|(1<<PhpParserHtmlHex)|(1<<PhpParserHtmlDecimal)|(1<<PhpParserHtmlName)|(1<<PhpParserHtmlEndQuoteString)|(1<<PhpParserHtmlQuoteString)|(1<<PhpParserHtmlEndDoubleQuoteString))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(PhpParserHtmlDoubleQuoteString-32))|(1<<(PhpParserScriptText-32))|(1<<(PhpParserScriptClose-32))|(1<<(PhpParserStyleBody-32))|(1<<(PhpParserAbstract-32))|(1<<(PhpParserArray-32))|(1<<(PhpParserAs-32))|(1<<(PhpParserBinaryCast-32))|(1<<(PhpParserBoolType-32))|(1<<(PhpParserBooleanConstant-32))|(1<<(PhpParserBreak-32))|(1<<(PhpParserCallable-32))|(1<<(PhpParserCase-32))|(1<<(PhpParserCatch-32))|(1<<(PhpParserClass-32))|(1<<(PhpParserClone-32))|(1<<(PhpParserConst-32))|(1<<(PhpParserContinue-32))|(1<<(PhpParserDeclare-32))|(1<<(PhpParserDefault-32))|(1<<(PhpParserDo-32))|(1<<(PhpParserDoubleCast-32))|(1<<(PhpParserDoubleType-32))|(1<<(PhpParserEcho-32))|(1<<(PhpParserElse-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(PhpParserElseIf-64))|(1<<(PhpParserEmpty-64))|(1<<(PhpParserEndDeclare-64))|(1<<(PhpParserEndFor-64))|(1<<(PhpParserEndForeach-64))|(1<<(PhpParserEndIf-64))|(1<<(PhpParserEndSwitch-64))|(1<<(PhpParserEndWhile-64))|(1<<(PhpParserEval-64))|(1<<(PhpParserExit-64))|(1<<(PhpParserExtends-64))|(1<<(PhpParserFinal-64))|(1<<(PhpParserFinally-64))|(1<<(PhpParserFloatCast-64))|(1<<(PhpParserFor-64))|(1<<(PhpParserForeach-64))|(1<<(PhpParserFunction-64))|(1<<(PhpParserGlobal-64))|(1<<(PhpParserGoto-64))|(1<<(PhpParserIf-64))|(1<<(PhpParserImplements-64))|(1<<(PhpParserImport-64))|(1<<(PhpParserInclude-64))|(1<<(PhpParserIncludeOnce-64))|(1<<(PhpParserInstanceOf-64))|(1<<(PhpParserInsteadOf-64))|(1<<(PhpParserInt8Cast-64))|(1<<(PhpParserInt16Cast-64))|(1<<(PhpParserInt64Type-64))|(1<<(PhpParserIntType-64))|(1<<(PhpParserInterface-64))|(1<<(PhpParserIsSet-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(PhpParserList-96))|(1<<(PhpParserLogicalAnd-96))|(1<<(PhpParserLogicalOr-96))|(1<<(PhpParserLogicalXor-96))|(1<<(PhpParserNamespace-96))|(1<<(PhpParserNew-96))|(1<<(PhpParserNull-96))|(1<<(PhpParserObjectType-96))|(1<<(PhpParserParent_-96))|(1<<(PhpParserPartial-96))|(1<<(PhpParserPrint-96))|(1<<(PhpParserPrivate-96))|(1<<(PhpParserProtected-96))|(1<<(PhpParserPublic-96))|(1<<(PhpParserRequire-96))|(1<<(PhpParserRequireOnce-96))|(1<<(PhpParserResource-96))|(1<<(PhpParserReturn-96))|(1<<(PhpParserStatic-96))|(1<<(PhpParserStringType-96))|(1<<(PhpParserSwitch-96))|(1<<(PhpParserThrow-96))|(1<<(PhpParserTrait-96))|(1<<(PhpParserTry-96))|(1<<(PhpParserTypeof-96))|(1<<(PhpParserUintCast-96))|(1<<(PhpParserUnicodeCast-96))|(1<<(PhpParserUnset-96))|(1<<(PhpParserUse-96))|(1<<(PhpParserVar-96))|(1<<(PhpParserWhile-96))|(1<<(PhpParserYield-96)))) != 0) || (((_la-128)&-(0x1f+1)) == 0 && ((1<<uint((_la-128)))&((1<<(PhpParserGet-128))|(1<<(PhpParserSet-128))|(1<<(PhpParserCall-128))|(1<<(PhpParserCallStatic-128))|(1<<(PhpParserConstructor-128))|(1<<(PhpParserDestruct-128))|(1<<(PhpParserWakeup-128))|(1<<(PhpParserSleep-128))|(1<<(PhpParserAutoload-128))|(1<<(PhpParserIsSet__-128))|(1<<(PhpParserUnset__-128))|(1<<(PhpParserToString__-128))|(1<<(PhpParserInvoke-128))|(1<<(PhpParserSetState-128))|(1<<(PhpParserClone__-128))|(1<<(PhpParserDebugInfo-128))|(1<<(PhpParserNamespace__-128))|(1<<(PhpParserClass__-128))|(1<<(PhpParserTraic__-128))|(1<<(PhpParserFunction__-128))|(1<<(PhpParserMethod__-128))|(1<<(PhpParserLine__-128))|(1<<(PhpParserFile__-128))|(1<<(PhpParserDir__-128))|(1<<(PhpParserInc-128))|(1<<(PhpParserDec-128)))) != 0) || (((_la-182)&-(0x1f+1)) == 0 && ((1<<uint((_la-182)))&((1<<(PhpParserNamespaceSeparator-182))|(1<<(PhpParserBang-182))|(1<<(PhpParserPlus-182))|(1<<(PhpParserMinus-182))|(1<<(PhpParserTilde-182))|(1<<(PhpParserSuppressWarnings-182))|(1<<(PhpParserDollar-182))|(1<<(PhpParserOpenRoundBracket-182))|(1<<(PhpParserOpenSquareBracket-182))|(1<<(PhpParserOpenCurlyBracket-182))|(1<<(PhpParserSemiColon-182))|(1<<(PhpParserVarName-182))|(1<<(PhpParserLabel-182)))) != 0) || (((_la-214)&-(0x1f+1)) == 0 && ((1<<uint((_la-214)))&((1<<(PhpParserOctal-214))|(1<<(PhpParserDecimal-214))|(1<<(PhpParserReal-214))|(1<<(PhpParserHex-214))|(1<<(PhpParserBinary-214))|(1<<(PhpParserBackQuoteString-214))|(1<<(PhpParserSingleQuoteString-214))|(1<<(PhpParserDoubleQuote-214))|(1<<(PhpParserStartNowDoc-214))|(1<<(PhpParserStartHereDoc-214)))) != 0) {
			{
				p.SetState(369)
				p.NamespaceStatement()
			}

			p.SetState(374)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(375)
			p.Match(PhpParserCloseCurlyBracket)
		}

	case 2:
		{
			p.SetState(376)
			p.NamespaceNameList()
		}
		{
			p.SetState(377)
			p.Match(PhpParserSemiColon)
		}

	}

	return localctx
}

// INamespaceStatementContext is an interface to support dynamic dispatch.
type INamespaceStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNamespaceStatementContext differentiates from other interfaces.
	IsNamespaceStatementContext()
}

type NamespaceStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamespaceStatementContext() *NamespaceStatementContext {
	var p = new(NamespaceStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_namespaceStatement
	return p
}

func (*NamespaceStatementContext) IsNamespaceStatementContext() {}

func NewNamespaceStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamespaceStatementContext {
	var p = new(NamespaceStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_namespaceStatement

	return p
}

func (s *NamespaceStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *NamespaceStatementContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *NamespaceStatementContext) UseDeclaration() IUseDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUseDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUseDeclarationContext)
}

func (s *NamespaceStatementContext) FunctionDeclaration() IFunctionDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionDeclarationContext)
}

func (s *NamespaceStatementContext) ClassDeclaration() IClassDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassDeclarationContext)
}

func (s *NamespaceStatementContext) GlobalConstantDeclaration() IGlobalConstantDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGlobalConstantDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGlobalConstantDeclarationContext)
}

func (s *NamespaceStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamespaceStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamespaceStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterNamespaceStatement(s)
	}
}

func (s *NamespaceStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitNamespaceStatement(s)
	}
}

func (p *PhpParser) NamespaceStatement() (localctx INamespaceStatementContext) {
	localctx = NewNamespaceStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, PhpParserRULE_namespaceStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(386)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 18, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(381)
			p.Statement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(382)
			p.UseDeclaration()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(383)
			p.FunctionDeclaration()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(384)
			p.ClassDeclaration()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(385)
			p.GlobalConstantDeclaration()
		}

	}

	return localctx
}

// IFunctionDeclarationContext is an interface to support dynamic dispatch.
type IFunctionDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionDeclarationContext differentiates from other interfaces.
	IsFunctionDeclarationContext()
}

type FunctionDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionDeclarationContext() *FunctionDeclarationContext {
	var p = new(FunctionDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_functionDeclaration
	return p
}

func (*FunctionDeclarationContext) IsFunctionDeclarationContext() {}

func NewFunctionDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionDeclarationContext {
	var p = new(FunctionDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_functionDeclaration

	return p
}

func (s *FunctionDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionDeclarationContext) Attributes() IAttributesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttributesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttributesContext)
}

func (s *FunctionDeclarationContext) Function() antlr.TerminalNode {
	return s.GetToken(PhpParserFunction, 0)
}

func (s *FunctionDeclarationContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *FunctionDeclarationContext) FormalParameterList() IFormalParameterListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFormalParameterListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *FunctionDeclarationContext) BlockStatement() IBlockStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockStatementContext)
}

func (s *FunctionDeclarationContext) TypeParameterListInBrackets() ITypeParameterListInBracketsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeParameterListInBracketsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeParameterListInBracketsContext)
}

func (s *FunctionDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterFunctionDeclaration(s)
	}
}

func (s *FunctionDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitFunctionDeclaration(s)
	}
}

func (p *PhpParser) FunctionDeclaration() (localctx IFunctionDeclarationContext) {
	localctx = NewFunctionDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, PhpParserRULE_functionDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(388)
		p.Attributes()
	}
	{
		p.SetState(389)
		p.Match(PhpParserFunction)
	}
	p.SetState(391)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PhpParserAmpersand {
		{
			p.SetState(390)
			p.Match(PhpParserAmpersand)
		}

	}
	{
		p.SetState(393)
		p.Identifier()
	}
	p.SetState(395)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PhpParserLgeneric {
		{
			p.SetState(394)
			p.TypeParameterListInBrackets()
		}

	}
	{
		p.SetState(397)
		p.Match(PhpParserOpenRoundBracket)
	}
	{
		p.SetState(398)
		p.FormalParameterList()
	}
	{
		p.SetState(399)
		p.Match(PhpParserCloseRoundBracket)
	}
	{
		p.SetState(400)
		p.BlockStatement()
	}

	return localctx
}

// IClassDeclarationContext is an interface to support dynamic dispatch.
type IClassDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassDeclarationContext differentiates from other interfaces.
	IsClassDeclarationContext()
}

type ClassDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassDeclarationContext() *ClassDeclarationContext {
	var p = new(ClassDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_classDeclaration
	return p
}

func (*ClassDeclarationContext) IsClassDeclarationContext() {}

func NewClassDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassDeclarationContext {
	var p = new(ClassDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_classDeclaration

	return p
}

func (s *ClassDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassDeclarationContext) Attributes() IAttributesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttributesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttributesContext)
}

func (s *ClassDeclarationContext) OpenCurlyBracket() antlr.TerminalNode {
	return s.GetToken(PhpParserOpenCurlyBracket, 0)
}

func (s *ClassDeclarationContext) ClassEntryType() IClassEntryTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassEntryTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassEntryTypeContext)
}

func (s *ClassDeclarationContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ClassDeclarationContext) Interface() antlr.TerminalNode {
	return s.GetToken(PhpParserInterface, 0)
}

func (s *ClassDeclarationContext) Private() antlr.TerminalNode {
	return s.GetToken(PhpParserPrivate, 0)
}

func (s *ClassDeclarationContext) Modifier() IModifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModifierContext)
}

func (s *ClassDeclarationContext) Partial() antlr.TerminalNode {
	return s.GetToken(PhpParserPartial, 0)
}

func (s *ClassDeclarationContext) AllClassStatement() []IClassStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IClassStatementContext)(nil)).Elem())
	var tst = make([]IClassStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IClassStatementContext)
		}
	}

	return tst
}

func (s *ClassDeclarationContext) ClassStatement(i int) IClassStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IClassStatementContext)
}

func (s *ClassDeclarationContext) TypeParameterListInBrackets() ITypeParameterListInBracketsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeParameterListInBracketsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeParameterListInBracketsContext)
}

func (s *ClassDeclarationContext) Extends() antlr.TerminalNode {
	return s.GetToken(PhpParserExtends, 0)
}

func (s *ClassDeclarationContext) QualifiedStaticTypeRef() IQualifiedStaticTypeRefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedStaticTypeRefContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedStaticTypeRefContext)
}

func (s *ClassDeclarationContext) Implements() antlr.TerminalNode {
	return s.GetToken(PhpParserImplements, 0)
}

func (s *ClassDeclarationContext) InterfaceList() IInterfaceListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterfaceListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterfaceListContext)
}

func (s *ClassDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterClassDeclaration(s)
	}
}

func (s *ClassDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitClassDeclaration(s)
	}
}

func (p *PhpParser) ClassDeclaration() (localctx IClassDeclarationContext) {
	localctx = NewClassDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, PhpParserRULE_classDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(402)
		p.Attributes()
	}
	p.SetState(404)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PhpParserPrivate {
		{
			p.SetState(403)
			p.Match(PhpParserPrivate)
		}

	}
	p.SetState(407)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PhpParserAbstract || _la == PhpParserFinal {
		{
			p.SetState(406)
			p.Modifier()
		}

	}
	p.SetState(410)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PhpParserPartial {
		{
			p.SetState(409)
			p.Match(PhpParserPartial)
		}

	}
	p.SetState(434)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PhpParserClass, PhpParserTrait:
		{
			p.SetState(412)
			p.ClassEntryType()
		}
		{
			p.SetState(413)
			p.Identifier()
		}
		p.SetState(415)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PhpParserLgeneric {
			{
				p.SetState(414)
				p.TypeParameterListInBrackets()
			}

		}
		p.SetState(419)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PhpParserExtends {
			{
				p.SetState(417)
				p.Match(PhpParserExtends)
			}
			{
				p.SetState(418)
				p.QualifiedStaticTypeRef()
			}

		}
		p.SetState(423)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PhpParserImplements {
			{
				p.SetState(421)
				p.Match(PhpParserImplements)
			}
			{
				p.SetState(422)
				p.InterfaceList()
			}

		}

	case PhpParserInterface:
		{
			p.SetState(425)
			p.Match(PhpParserInterface)
		}
		{
			p.SetState(426)
			p.Identifier()
		}
		p.SetState(428)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PhpParserLgeneric {
			{
				p.SetState(427)
				p.TypeParameterListInBrackets()
			}

		}
		p.SetState(432)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PhpParserExtends {
			{
				p.SetState(430)
				p.Match(PhpParserExtends)
			}
			{
				p.SetState(431)
				p.InterfaceList()
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(436)
		p.Match(PhpParserOpenCurlyBracket)
	}
	p.SetState(440)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PhpParserAbstract || _la == PhpParserConst || _la == PhpParserFinal || _la == PhpParserFunction || (((_la-107)&-(0x1f+1)) == 0 && ((1<<uint((_la-107)))&((1<<(PhpParserPrivate-107))|(1<<(PhpParserProtected-107))|(1<<(PhpParserPublic-107))|(1<<(PhpParserStatic-107))|(1<<(PhpParserUse-107))|(1<<(PhpParserVar-107)))) != 0) || _la == PhpParserOpenSquareBracket {
		{
			p.SetState(437)
			p.ClassStatement()
		}

		p.SetState(442)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(443)
		p.Match(PhpParserCloseCurlyBracket)
	}

	return localctx
}

// IClassEntryTypeContext is an interface to support dynamic dispatch.
type IClassEntryTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassEntryTypeContext differentiates from other interfaces.
	IsClassEntryTypeContext()
}

type ClassEntryTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassEntryTypeContext() *ClassEntryTypeContext {
	var p = new(ClassEntryTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_classEntryType
	return p
}

func (*ClassEntryTypeContext) IsClassEntryTypeContext() {}

func NewClassEntryTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassEntryTypeContext {
	var p = new(ClassEntryTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_classEntryType

	return p
}

func (s *ClassEntryTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassEntryTypeContext) Class() antlr.TerminalNode {
	return s.GetToken(PhpParserClass, 0)
}

func (s *ClassEntryTypeContext) Trait() antlr.TerminalNode {
	return s.GetToken(PhpParserTrait, 0)
}

func (s *ClassEntryTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassEntryTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassEntryTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterClassEntryType(s)
	}
}

func (s *ClassEntryTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitClassEntryType(s)
	}
}

func (p *PhpParser) ClassEntryType() (localctx IClassEntryTypeContext) {
	localctx = NewClassEntryTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, PhpParserRULE_classEntryType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(445)
		_la = p.GetTokenStream().LA(1)

		if !(_la == PhpParserClass || _la == PhpParserTrait) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IInterfaceListContext is an interface to support dynamic dispatch.
type IInterfaceListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInterfaceListContext differentiates from other interfaces.
	IsInterfaceListContext()
}

type InterfaceListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceListContext() *InterfaceListContext {
	var p = new(InterfaceListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_interfaceList
	return p
}

func (*InterfaceListContext) IsInterfaceListContext() {}

func NewInterfaceListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceListContext {
	var p = new(InterfaceListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_interfaceList

	return p
}

func (s *InterfaceListContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceListContext) AllQualifiedStaticTypeRef() []IQualifiedStaticTypeRefContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IQualifiedStaticTypeRefContext)(nil)).Elem())
	var tst = make([]IQualifiedStaticTypeRefContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IQualifiedStaticTypeRefContext)
		}
	}

	return tst
}

func (s *InterfaceListContext) QualifiedStaticTypeRef(i int) IQualifiedStaticTypeRefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedStaticTypeRefContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IQualifiedStaticTypeRefContext)
}

func (s *InterfaceListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterInterfaceList(s)
	}
}

func (s *InterfaceListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitInterfaceList(s)
	}
}

func (p *PhpParser) InterfaceList() (localctx IInterfaceListContext) {
	localctx = NewInterfaceListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, PhpParserRULE_interfaceList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(447)
		p.QualifiedStaticTypeRef()
	}
	p.SetState(452)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PhpParserComma {
		{
			p.SetState(448)
			p.Match(PhpParserComma)
		}
		{
			p.SetState(449)
			p.QualifiedStaticTypeRef()
		}

		p.SetState(454)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ITypeParameterListInBracketsContext is an interface to support dynamic dispatch.
type ITypeParameterListInBracketsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeParameterListInBracketsContext differentiates from other interfaces.
	IsTypeParameterListInBracketsContext()
}

type TypeParameterListInBracketsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeParameterListInBracketsContext() *TypeParameterListInBracketsContext {
	var p = new(TypeParameterListInBracketsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_typeParameterListInBrackets
	return p
}

func (*TypeParameterListInBracketsContext) IsTypeParameterListInBracketsContext() {}

func NewTypeParameterListInBracketsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeParameterListInBracketsContext {
	var p = new(TypeParameterListInBracketsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_typeParameterListInBrackets

	return p
}

func (s *TypeParameterListInBracketsContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeParameterListInBracketsContext) TypeParameterList() ITypeParameterListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeParameterListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeParameterListContext)
}

func (s *TypeParameterListInBracketsContext) TypeParameterWithDefaultsList() ITypeParameterWithDefaultsListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeParameterWithDefaultsListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeParameterWithDefaultsListContext)
}

func (s *TypeParameterListInBracketsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeParameterListInBracketsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeParameterListInBracketsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterTypeParameterListInBrackets(s)
	}
}

func (s *TypeParameterListInBracketsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitTypeParameterListInBrackets(s)
	}
}

func (p *PhpParser) TypeParameterListInBrackets() (localctx ITypeParameterListInBracketsContext) {
	localctx = NewTypeParameterListInBracketsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, PhpParserRULE_typeParameterListInBrackets)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(469)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 32, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(455)
			p.Match(PhpParserLgeneric)
		}
		{
			p.SetState(456)
			p.TypeParameterList()
		}
		{
			p.SetState(457)
			p.Match(PhpParserRgeneric)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(459)
			p.Match(PhpParserLgeneric)
		}
		{
			p.SetState(460)
			p.TypeParameterWithDefaultsList()
		}
		{
			p.SetState(461)
			p.Match(PhpParserRgeneric)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(463)
			p.Match(PhpParserLgeneric)
		}
		{
			p.SetState(464)
			p.TypeParameterList()
		}
		{
			p.SetState(465)
			p.Match(PhpParserComma)
		}
		{
			p.SetState(466)
			p.TypeParameterWithDefaultsList()
		}
		{
			p.SetState(467)
			p.Match(PhpParserRgeneric)
		}

	}

	return localctx
}

// ITypeParameterListContext is an interface to support dynamic dispatch.
type ITypeParameterListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeParameterListContext differentiates from other interfaces.
	IsTypeParameterListContext()
}

type TypeParameterListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeParameterListContext() *TypeParameterListContext {
	var p = new(TypeParameterListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_typeParameterList
	return p
}

func (*TypeParameterListContext) IsTypeParameterListContext() {}

func NewTypeParameterListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeParameterListContext {
	var p = new(TypeParameterListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_typeParameterList

	return p
}

func (s *TypeParameterListContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeParameterListContext) AllTypeParameterDecl() []ITypeParameterDeclContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITypeParameterDeclContext)(nil)).Elem())
	var tst = make([]ITypeParameterDeclContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITypeParameterDeclContext)
		}
	}

	return tst
}

func (s *TypeParameterListContext) TypeParameterDecl(i int) ITypeParameterDeclContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeParameterDeclContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITypeParameterDeclContext)
}

func (s *TypeParameterListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeParameterListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeParameterListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterTypeParameterList(s)
	}
}

func (s *TypeParameterListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitTypeParameterList(s)
	}
}

func (p *PhpParser) TypeParameterList() (localctx ITypeParameterListContext) {
	localctx = NewTypeParameterListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, PhpParserRULE_typeParameterList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(471)
		p.TypeParameterDecl()
	}
	p.SetState(476)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 33, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(472)
				p.Match(PhpParserComma)
			}
			{
				p.SetState(473)
				p.TypeParameterDecl()
			}

		}
		p.SetState(478)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 33, p.GetParserRuleContext())
	}

	return localctx
}

// ITypeParameterWithDefaultsListContext is an interface to support dynamic dispatch.
type ITypeParameterWithDefaultsListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeParameterWithDefaultsListContext differentiates from other interfaces.
	IsTypeParameterWithDefaultsListContext()
}

type TypeParameterWithDefaultsListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeParameterWithDefaultsListContext() *TypeParameterWithDefaultsListContext {
	var p = new(TypeParameterWithDefaultsListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_typeParameterWithDefaultsList
	return p
}

func (*TypeParameterWithDefaultsListContext) IsTypeParameterWithDefaultsListContext() {}

func NewTypeParameterWithDefaultsListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeParameterWithDefaultsListContext {
	var p = new(TypeParameterWithDefaultsListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_typeParameterWithDefaultsList

	return p
}

func (s *TypeParameterWithDefaultsListContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeParameterWithDefaultsListContext) AllTypeParameterWithDefaultDecl() []ITypeParameterWithDefaultDeclContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITypeParameterWithDefaultDeclContext)(nil)).Elem())
	var tst = make([]ITypeParameterWithDefaultDeclContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITypeParameterWithDefaultDeclContext)
		}
	}

	return tst
}

func (s *TypeParameterWithDefaultsListContext) TypeParameterWithDefaultDecl(i int) ITypeParameterWithDefaultDeclContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeParameterWithDefaultDeclContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITypeParameterWithDefaultDeclContext)
}

func (s *TypeParameterWithDefaultsListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeParameterWithDefaultsListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeParameterWithDefaultsListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterTypeParameterWithDefaultsList(s)
	}
}

func (s *TypeParameterWithDefaultsListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitTypeParameterWithDefaultsList(s)
	}
}

func (p *PhpParser) TypeParameterWithDefaultsList() (localctx ITypeParameterWithDefaultsListContext) {
	localctx = NewTypeParameterWithDefaultsListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, PhpParserRULE_typeParameterWithDefaultsList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(479)
		p.TypeParameterWithDefaultDecl()
	}
	p.SetState(484)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PhpParserComma {
		{
			p.SetState(480)
			p.Match(PhpParserComma)
		}
		{
			p.SetState(481)
			p.TypeParameterWithDefaultDecl()
		}

		p.SetState(486)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ITypeParameterDeclContext is an interface to support dynamic dispatch.
type ITypeParameterDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeParameterDeclContext differentiates from other interfaces.
	IsTypeParameterDeclContext()
}

type TypeParameterDeclContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeParameterDeclContext() *TypeParameterDeclContext {
	var p = new(TypeParameterDeclContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_typeParameterDecl
	return p
}

func (*TypeParameterDeclContext) IsTypeParameterDeclContext() {}

func NewTypeParameterDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeParameterDeclContext {
	var p = new(TypeParameterDeclContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_typeParameterDecl

	return p
}

func (s *TypeParameterDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeParameterDeclContext) Attributes() IAttributesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttributesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttributesContext)
}

func (s *TypeParameterDeclContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TypeParameterDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeParameterDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeParameterDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterTypeParameterDecl(s)
	}
}

func (s *TypeParameterDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitTypeParameterDecl(s)
	}
}

func (p *PhpParser) TypeParameterDecl() (localctx ITypeParameterDeclContext) {
	localctx = NewTypeParameterDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, PhpParserRULE_typeParameterDecl)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(487)
		p.Attributes()
	}
	{
		p.SetState(488)
		p.Identifier()
	}

	return localctx
}

// ITypeParameterWithDefaultDeclContext is an interface to support dynamic dispatch.
type ITypeParameterWithDefaultDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeParameterWithDefaultDeclContext differentiates from other interfaces.
	IsTypeParameterWithDefaultDeclContext()
}

type TypeParameterWithDefaultDeclContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeParameterWithDefaultDeclContext() *TypeParameterWithDefaultDeclContext {
	var p = new(TypeParameterWithDefaultDeclContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_typeParameterWithDefaultDecl
	return p
}

func (*TypeParameterWithDefaultDeclContext) IsTypeParameterWithDefaultDeclContext() {}

func NewTypeParameterWithDefaultDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeParameterWithDefaultDeclContext {
	var p = new(TypeParameterWithDefaultDeclContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_typeParameterWithDefaultDecl

	return p
}

func (s *TypeParameterWithDefaultDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeParameterWithDefaultDeclContext) Attributes() IAttributesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttributesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttributesContext)
}

func (s *TypeParameterWithDefaultDeclContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TypeParameterWithDefaultDeclContext) Eq() antlr.TerminalNode {
	return s.GetToken(PhpParserEq, 0)
}

func (s *TypeParameterWithDefaultDeclContext) QualifiedStaticTypeRef() IQualifiedStaticTypeRefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedStaticTypeRefContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedStaticTypeRefContext)
}

func (s *TypeParameterWithDefaultDeclContext) PrimitiveType() IPrimitiveTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimitiveTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimitiveTypeContext)
}

func (s *TypeParameterWithDefaultDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeParameterWithDefaultDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeParameterWithDefaultDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterTypeParameterWithDefaultDecl(s)
	}
}

func (s *TypeParameterWithDefaultDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitTypeParameterWithDefaultDecl(s)
	}
}

func (p *PhpParser) TypeParameterWithDefaultDecl() (localctx ITypeParameterWithDefaultDeclContext) {
	localctx = NewTypeParameterWithDefaultDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, PhpParserRULE_typeParameterWithDefaultDecl)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(490)
		p.Attributes()
	}
	{
		p.SetState(491)
		p.Identifier()
	}
	{
		p.SetState(492)
		p.Match(PhpParserEq)
	}
	p.SetState(495)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 35, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(493)
			p.QualifiedStaticTypeRef()
		}

	case 2:
		{
			p.SetState(494)
			p.PrimitiveType()
		}

	}

	return localctx
}

// IGenericDynamicArgsContext is an interface to support dynamic dispatch.
type IGenericDynamicArgsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGenericDynamicArgsContext differentiates from other interfaces.
	IsGenericDynamicArgsContext()
}

type GenericDynamicArgsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenericDynamicArgsContext() *GenericDynamicArgsContext {
	var p = new(GenericDynamicArgsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_genericDynamicArgs
	return p
}

func (*GenericDynamicArgsContext) IsGenericDynamicArgsContext() {}

func NewGenericDynamicArgsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GenericDynamicArgsContext {
	var p = new(GenericDynamicArgsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_genericDynamicArgs

	return p
}

func (s *GenericDynamicArgsContext) GetParser() antlr.Parser { return s.parser }

func (s *GenericDynamicArgsContext) AllTypeRef() []ITypeRefContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITypeRefContext)(nil)).Elem())
	var tst = make([]ITypeRefContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITypeRefContext)
		}
	}

	return tst
}

func (s *GenericDynamicArgsContext) TypeRef(i int) ITypeRefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeRefContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITypeRefContext)
}

func (s *GenericDynamicArgsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GenericDynamicArgsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GenericDynamicArgsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterGenericDynamicArgs(s)
	}
}

func (s *GenericDynamicArgsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitGenericDynamicArgs(s)
	}
}

func (p *PhpParser) GenericDynamicArgs() (localctx IGenericDynamicArgsContext) {
	localctx = NewGenericDynamicArgsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, PhpParserRULE_genericDynamicArgs)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(497)
		p.Match(PhpParserLgeneric)
	}
	{
		p.SetState(498)
		p.TypeRef()
	}
	p.SetState(503)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PhpParserComma {
		{
			p.SetState(499)
			p.Match(PhpParserComma)
		}
		{
			p.SetState(500)
			p.TypeRef()
		}

		p.SetState(505)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(506)
		p.Match(PhpParserRgeneric)
	}

	return localctx
}

// IAttributesContext is an interface to support dynamic dispatch.
type IAttributesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttributesContext differentiates from other interfaces.
	IsAttributesContext()
}

type AttributesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttributesContext() *AttributesContext {
	var p = new(AttributesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_attributes
	return p
}

func (*AttributesContext) IsAttributesContext() {}

func NewAttributesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributesContext {
	var p = new(AttributesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_attributes

	return p
}

func (s *AttributesContext) GetParser() antlr.Parser { return s.parser }

func (s *AttributesContext) AllAttributesGroup() []IAttributesGroupContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttributesGroupContext)(nil)).Elem())
	var tst = make([]IAttributesGroupContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttributesGroupContext)
		}
	}

	return tst
}

func (s *AttributesContext) AttributesGroup(i int) IAttributesGroupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttributesGroupContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttributesGroupContext)
}

func (s *AttributesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AttributesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterAttributes(s)
	}
}

func (s *AttributesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitAttributes(s)
	}
}

func (p *PhpParser) Attributes() (localctx IAttributesContext) {
	localctx = NewAttributesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, PhpParserRULE_attributes)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(511)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PhpParserOpenSquareBracket {
		{
			p.SetState(508)
			p.AttributesGroup()
		}

		p.SetState(513)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IAttributesGroupContext is an interface to support dynamic dispatch.
type IAttributesGroupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttributesGroupContext differentiates from other interfaces.
	IsAttributesGroupContext()
}

type AttributesGroupContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttributesGroupContext() *AttributesGroupContext {
	var p = new(AttributesGroupContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_attributesGroup
	return p
}

func (*AttributesGroupContext) IsAttributesGroupContext() {}

func NewAttributesGroupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributesGroupContext {
	var p = new(AttributesGroupContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_attributesGroup

	return p
}

func (s *AttributesGroupContext) GetParser() antlr.Parser { return s.parser }

func (s *AttributesGroupContext) AllAttribute() []IAttributeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttributeContext)(nil)).Elem())
	var tst = make([]IAttributeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttributeContext)
		}
	}

	return tst
}

func (s *AttributesGroupContext) Attribute(i int) IAttributeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttributeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttributeContext)
}

func (s *AttributesGroupContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AttributesGroupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributesGroupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AttributesGroupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterAttributesGroup(s)
	}
}

func (s *AttributesGroupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitAttributesGroup(s)
	}
}

func (p *PhpParser) AttributesGroup() (localctx IAttributesGroupContext) {
	localctx = NewAttributesGroupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, PhpParserRULE_attributesGroup)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(514)
		p.Match(PhpParserOpenSquareBracket)
	}
	p.SetState(518)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 38, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(515)
			p.Identifier()
		}
		{
			p.SetState(516)
			p.Match(PhpParserColon)
		}

	}
	{
		p.SetState(520)
		p.Attribute()
	}
	p.SetState(525)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PhpParserComma {
		{
			p.SetState(521)
			p.Match(PhpParserComma)
		}
		{
			p.SetState(522)
			p.Attribute()
		}

		p.SetState(527)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(528)
		p.Match(PhpParserCloseSquareBracket)
	}

	return localctx
}

// IAttributeContext is an interface to support dynamic dispatch.
type IAttributeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttributeContext differentiates from other interfaces.
	IsAttributeContext()
}

type AttributeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttributeContext() *AttributeContext {
	var p = new(AttributeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_attribute
	return p
}

func (*AttributeContext) IsAttributeContext() {}

func NewAttributeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributeContext {
	var p = new(AttributeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_attribute

	return p
}

func (s *AttributeContext) GetParser() antlr.Parser { return s.parser }

func (s *AttributeContext) QualifiedNamespaceName() IQualifiedNamespaceNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNamespaceNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNamespaceNameContext)
}

func (s *AttributeContext) AttributeArgList() IAttributeArgListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttributeArgListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttributeArgListContext)
}

func (s *AttributeContext) AttributeNamedArgList() IAttributeNamedArgListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttributeNamedArgListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttributeNamedArgListContext)
}

func (s *AttributeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AttributeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterAttribute(s)
	}
}

func (s *AttributeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitAttribute(s)
	}
}

func (p *PhpParser) Attribute() (localctx IAttributeContext) {
	localctx = NewAttributeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, PhpParserRULE_attribute)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(548)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 40, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(530)
			p.QualifiedNamespaceName()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(531)
			p.QualifiedNamespaceName()
		}
		{
			p.SetState(532)
			p.Match(PhpParserOpenRoundBracket)
		}
		{
			p.SetState(533)
			p.AttributeArgList()
		}
		{
			p.SetState(534)
			p.Match(PhpParserCloseRoundBracket)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(536)
			p.QualifiedNamespaceName()
		}
		{
			p.SetState(537)
			p.Match(PhpParserOpenRoundBracket)
		}
		{
			p.SetState(538)
			p.AttributeNamedArgList()
		}
		{
			p.SetState(539)
			p.Match(PhpParserCloseRoundBracket)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(541)
			p.QualifiedNamespaceName()
		}
		{
			p.SetState(542)
			p.Match(PhpParserOpenRoundBracket)
		}
		{
			p.SetState(543)
			p.AttributeArgList()
		}
		{
			p.SetState(544)
			p.Match(PhpParserComma)
		}
		{
			p.SetState(545)
			p.AttributeNamedArgList()
		}
		{
			p.SetState(546)
			p.Match(PhpParserCloseRoundBracket)
		}

	}

	return localctx
}

// IAttributeArgListContext is an interface to support dynamic dispatch.
type IAttributeArgListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttributeArgListContext differentiates from other interfaces.
	IsAttributeArgListContext()
}

type AttributeArgListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttributeArgListContext() *AttributeArgListContext {
	var p = new(AttributeArgListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_attributeArgList
	return p
}

func (*AttributeArgListContext) IsAttributeArgListContext() {}

func NewAttributeArgListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributeArgListContext {
	var p = new(AttributeArgListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_attributeArgList

	return p
}

func (s *AttributeArgListContext) GetParser() antlr.Parser { return s.parser }

func (s *AttributeArgListContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *AttributeArgListContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AttributeArgListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributeArgListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AttributeArgListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterAttributeArgList(s)
	}
}

func (s *AttributeArgListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitAttributeArgList(s)
	}
}

func (p *PhpParser) AttributeArgList() (localctx IAttributeArgListContext) {
	localctx = NewAttributeArgListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, PhpParserRULE_attributeArgList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(550)
		p.expression(0)
	}
	p.SetState(555)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 41, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(551)
				p.Match(PhpParserComma)
			}
			{
				p.SetState(552)
				p.expression(0)
			}

		}
		p.SetState(557)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 41, p.GetParserRuleContext())
	}

	return localctx
}

// IAttributeNamedArgListContext is an interface to support dynamic dispatch.
type IAttributeNamedArgListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttributeNamedArgListContext differentiates from other interfaces.
	IsAttributeNamedArgListContext()
}

type AttributeNamedArgListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttributeNamedArgListContext() *AttributeNamedArgListContext {
	var p = new(AttributeNamedArgListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_attributeNamedArgList
	return p
}

func (*AttributeNamedArgListContext) IsAttributeNamedArgListContext() {}

func NewAttributeNamedArgListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributeNamedArgListContext {
	var p = new(AttributeNamedArgListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_attributeNamedArgList

	return p
}

func (s *AttributeNamedArgListContext) GetParser() antlr.Parser { return s.parser }

func (s *AttributeNamedArgListContext) AllAttributeNamedArg() []IAttributeNamedArgContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAttributeNamedArgContext)(nil)).Elem())
	var tst = make([]IAttributeNamedArgContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAttributeNamedArgContext)
		}
	}

	return tst
}

func (s *AttributeNamedArgListContext) AttributeNamedArg(i int) IAttributeNamedArgContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttributeNamedArgContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAttributeNamedArgContext)
}

func (s *AttributeNamedArgListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributeNamedArgListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AttributeNamedArgListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterAttributeNamedArgList(s)
	}
}

func (s *AttributeNamedArgListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitAttributeNamedArgList(s)
	}
}

func (p *PhpParser) AttributeNamedArgList() (localctx IAttributeNamedArgListContext) {
	localctx = NewAttributeNamedArgListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, PhpParserRULE_attributeNamedArgList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(558)
		p.AttributeNamedArg()
	}
	p.SetState(563)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PhpParserComma {
		{
			p.SetState(559)
			p.Match(PhpParserComma)
		}
		{
			p.SetState(560)
			p.AttributeNamedArg()
		}

		p.SetState(565)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IAttributeNamedArgContext is an interface to support dynamic dispatch.
type IAttributeNamedArgContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttributeNamedArgContext differentiates from other interfaces.
	IsAttributeNamedArgContext()
}

type AttributeNamedArgContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttributeNamedArgContext() *AttributeNamedArgContext {
	var p = new(AttributeNamedArgContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_attributeNamedArg
	return p
}

func (*AttributeNamedArgContext) IsAttributeNamedArgContext() {}

func NewAttributeNamedArgContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributeNamedArgContext {
	var p = new(AttributeNamedArgContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_attributeNamedArg

	return p
}

func (s *AttributeNamedArgContext) GetParser() antlr.Parser { return s.parser }

func (s *AttributeNamedArgContext) VarName() antlr.TerminalNode {
	return s.GetToken(PhpParserVarName, 0)
}

func (s *AttributeNamedArgContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AttributeNamedArgContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributeNamedArgContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AttributeNamedArgContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterAttributeNamedArg(s)
	}
}

func (s *AttributeNamedArgContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitAttributeNamedArg(s)
	}
}

func (p *PhpParser) AttributeNamedArg() (localctx IAttributeNamedArgContext) {
	localctx = NewAttributeNamedArgContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, PhpParserRULE_attributeNamedArg)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(566)
		p.Match(PhpParserVarName)
	}
	{
		p.SetState(567)
		p.Match(PhpParserDoubleArrow)
	}
	{
		p.SetState(568)
		p.expression(0)
	}

	return localctx
}

// IInnerStatementListContext is an interface to support dynamic dispatch.
type IInnerStatementListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInnerStatementListContext differentiates from other interfaces.
	IsInnerStatementListContext()
}

type InnerStatementListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInnerStatementListContext() *InnerStatementListContext {
	var p = new(InnerStatementListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_innerStatementList
	return p
}

func (*InnerStatementListContext) IsInnerStatementListContext() {}

func NewInnerStatementListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InnerStatementListContext {
	var p = new(InnerStatementListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_innerStatementList

	return p
}

func (s *InnerStatementListContext) GetParser() antlr.Parser { return s.parser }

func (s *InnerStatementListContext) AllInnerStatement() []IInnerStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInnerStatementContext)(nil)).Elem())
	var tst = make([]IInnerStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInnerStatementContext)
		}
	}

	return tst
}

func (s *InnerStatementListContext) InnerStatement(i int) IInnerStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInnerStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInnerStatementContext)
}

func (s *InnerStatementListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InnerStatementListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InnerStatementListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterInnerStatementList(s)
	}
}

func (s *InnerStatementListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitInnerStatementList(s)
	}
}

func (p *PhpParser) InnerStatementList() (localctx IInnerStatementListContext) {
	localctx = NewInnerStatementListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, PhpParserRULE_innerStatementList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(573)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 43, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(570)
				p.InnerStatement()
			}

		}
		p.SetState(575)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 43, p.GetParserRuleContext())
	}

	return localctx
}

// IInnerStatementContext is an interface to support dynamic dispatch.
type IInnerStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInnerStatementContext differentiates from other interfaces.
	IsInnerStatementContext()
}

type InnerStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInnerStatementContext() *InnerStatementContext {
	var p = new(InnerStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_innerStatement
	return p
}

func (*InnerStatementContext) IsInnerStatementContext() {}

func NewInnerStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InnerStatementContext {
	var p = new(InnerStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_innerStatement

	return p
}

func (s *InnerStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *InnerStatementContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *InnerStatementContext) FunctionDeclaration() IFunctionDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionDeclarationContext)
}

func (s *InnerStatementContext) ClassDeclaration() IClassDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassDeclarationContext)
}

func (s *InnerStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InnerStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InnerStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterInnerStatement(s)
	}
}

func (s *InnerStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitInnerStatement(s)
	}
}

func (p *PhpParser) InnerStatement() (localctx IInnerStatementContext) {
	localctx = NewInnerStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, PhpParserRULE_innerStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(579)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 44, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(576)
			p.Statement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(577)
			p.FunctionDeclaration()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(578)
			p.ClassDeclaration()
		}

	}

	return localctx
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_statement
	return p
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *StatementContext) BlockStatement() IBlockStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockStatementContext)
}

func (s *StatementContext) IfStatement() IIfStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIfStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIfStatementContext)
}

func (s *StatementContext) WhileStatement() IWhileStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWhileStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWhileStatementContext)
}

func (s *StatementContext) DoWhileStatement() IDoWhileStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDoWhileStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDoWhileStatementContext)
}

func (s *StatementContext) ForStatement() IForStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IForStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IForStatementContext)
}

func (s *StatementContext) SwitchStatement() ISwitchStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISwitchStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISwitchStatementContext)
}

func (s *StatementContext) BreakStatement() IBreakStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBreakStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBreakStatementContext)
}

func (s *StatementContext) ContinueStatement() IContinueStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IContinueStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IContinueStatementContext)
}

func (s *StatementContext) ReturnStatement() IReturnStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReturnStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReturnStatementContext)
}

func (s *StatementContext) YieldExpression() IYieldExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IYieldExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IYieldExpressionContext)
}

func (s *StatementContext) GlobalStatement() IGlobalStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGlobalStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGlobalStatementContext)
}

func (s *StatementContext) StaticVariableStatement() IStaticVariableStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStaticVariableStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStaticVariableStatementContext)
}

func (s *StatementContext) EchoStatement() IEchoStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEchoStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEchoStatementContext)
}

func (s *StatementContext) ExpressionStatement() IExpressionStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionStatementContext)
}

func (s *StatementContext) UnsetStatement() IUnsetStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnsetStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnsetStatementContext)
}

func (s *StatementContext) ForeachStatement() IForeachStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IForeachStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IForeachStatementContext)
}

func (s *StatementContext) TryCatchFinally() ITryCatchFinallyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITryCatchFinallyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITryCatchFinallyContext)
}

func (s *StatementContext) ThrowStatement() IThrowStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IThrowStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IThrowStatementContext)
}

func (s *StatementContext) GotoStatement() IGotoStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGotoStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGotoStatementContext)
}

func (s *StatementContext) DeclareStatement() IDeclareStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclareStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclareStatementContext)
}

func (s *StatementContext) VoidStatement() IVoidStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVoidStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVoidStatementContext)
}

func (s *StatementContext) InlineHtmlStatement() IInlineHtmlStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInlineHtmlStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInlineHtmlStatementContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterStatement(s)
	}
}

func (s *StatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitStatement(s)
	}
}

func (p *PhpParser) Statement() (localctx IStatementContext) {
	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, PhpParserRULE_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(608)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 45, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(581)
			p.Identifier()
		}
		{
			p.SetState(582)
			p.Match(PhpParserColon)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(584)
			p.BlockStatement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(585)
			p.IfStatement()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(586)
			p.WhileStatement()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(587)
			p.DoWhileStatement()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(588)
			p.ForStatement()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(589)
			p.SwitchStatement()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(590)
			p.BreakStatement()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(591)
			p.ContinueStatement()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(592)
			p.ReturnStatement()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(593)
			p.YieldExpression()
		}
		{
			p.SetState(594)
			p.Match(PhpParserSemiColon)
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(596)
			p.GlobalStatement()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(597)
			p.StaticVariableStatement()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(598)
			p.EchoStatement()
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(599)
			p.ExpressionStatement()
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(600)
			p.UnsetStatement()
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(601)
			p.ForeachStatement()
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(602)
			p.TryCatchFinally()
		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(603)
			p.ThrowStatement()
		}

	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(604)
			p.GotoStatement()
		}

	case 21:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(605)
			p.DeclareStatement()
		}

	case 22:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(606)
			p.VoidStatement()
		}

	case 23:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(607)
			p.InlineHtmlStatement()
		}

	}

	return localctx
}

// IVoidStatementContext is an interface to support dynamic dispatch.
type IVoidStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVoidStatementContext differentiates from other interfaces.
	IsVoidStatementContext()
}

type VoidStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVoidStatementContext() *VoidStatementContext {
	var p = new(VoidStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_voidStatement
	return p
}

func (*VoidStatementContext) IsVoidStatementContext() {}

func NewVoidStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VoidStatementContext {
	var p = new(VoidStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_voidStatement

	return p
}

func (s *VoidStatementContext) GetParser() antlr.Parser { return s.parser }
func (s *VoidStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VoidStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VoidStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterVoidStatement(s)
	}
}

func (s *VoidStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitVoidStatement(s)
	}
}

func (p *PhpParser) VoidStatement() (localctx IVoidStatementContext) {
	localctx = NewVoidStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, PhpParserRULE_voidStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(610)
		p.Match(PhpParserSemiColon)
	}

	return localctx
}

// IBlockStatementContext is an interface to support dynamic dispatch.
type IBlockStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlockStatementContext differentiates from other interfaces.
	IsBlockStatementContext()
}

type BlockStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockStatementContext() *BlockStatementContext {
	var p = new(BlockStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_blockStatement
	return p
}

func (*BlockStatementContext) IsBlockStatementContext() {}

func NewBlockStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockStatementContext {
	var p = new(BlockStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_blockStatement

	return p
}

func (s *BlockStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockStatementContext) OpenCurlyBracket() antlr.TerminalNode {
	return s.GetToken(PhpParserOpenCurlyBracket, 0)
}

func (s *BlockStatementContext) InnerStatementList() IInnerStatementListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInnerStatementListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInnerStatementListContext)
}

func (s *BlockStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlockStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterBlockStatement(s)
	}
}

func (s *BlockStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitBlockStatement(s)
	}
}

func (p *PhpParser) BlockStatement() (localctx IBlockStatementContext) {
	localctx = NewBlockStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, PhpParserRULE_blockStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(612)
		p.Match(PhpParserOpenCurlyBracket)
	}
	{
		p.SetState(613)
		p.InnerStatementList()
	}
	{
		p.SetState(614)
		p.Match(PhpParserCloseCurlyBracket)
	}

	return localctx
}

// IIfStatementContext is an interface to support dynamic dispatch.
type IIfStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIfStatementContext differentiates from other interfaces.
	IsIfStatementContext()
}

type IfStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfStatementContext() *IfStatementContext {
	var p = new(IfStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_ifStatement
	return p
}

func (*IfStatementContext) IsIfStatementContext() {}

func NewIfStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfStatementContext {
	var p = new(IfStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_ifStatement

	return p
}

func (s *IfStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *IfStatementContext) If() antlr.TerminalNode {
	return s.GetToken(PhpParserIf, 0)
}

func (s *IfStatementContext) Parenthesis() IParenthesisContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParenthesisContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParenthesisContext)
}

func (s *IfStatementContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *IfStatementContext) AllElseIfStatement() []IElseIfStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IElseIfStatementContext)(nil)).Elem())
	var tst = make([]IElseIfStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IElseIfStatementContext)
		}
	}

	return tst
}

func (s *IfStatementContext) ElseIfStatement(i int) IElseIfStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElseIfStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IElseIfStatementContext)
}

func (s *IfStatementContext) ElseStatement() IElseStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElseStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IElseStatementContext)
}

func (s *IfStatementContext) InnerStatementList() IInnerStatementListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInnerStatementListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInnerStatementListContext)
}

func (s *IfStatementContext) EndIf() antlr.TerminalNode {
	return s.GetToken(PhpParserEndIf, 0)
}

func (s *IfStatementContext) AllElseIfColonStatement() []IElseIfColonStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IElseIfColonStatementContext)(nil)).Elem())
	var tst = make([]IElseIfColonStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IElseIfColonStatementContext)
		}
	}

	return tst
}

func (s *IfStatementContext) ElseIfColonStatement(i int) IElseIfColonStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElseIfColonStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IElseIfColonStatementContext)
}

func (s *IfStatementContext) ElseColonStatement() IElseColonStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElseColonStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IElseColonStatementContext)
}

func (s *IfStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterIfStatement(s)
	}
}

func (s *IfStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitIfStatement(s)
	}
}

func (p *PhpParser) IfStatement() (localctx IIfStatementContext) {
	localctx = NewIfStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, PhpParserRULE_ifStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(644)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 50, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(616)
			p.Match(PhpParserIf)
		}
		{
			p.SetState(617)
			p.Parenthesis()
		}
		{
			p.SetState(618)
			p.Statement()
		}
		p.SetState(622)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 46, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(619)
					p.ElseIfStatement()
				}

			}
			p.SetState(624)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 46, p.GetParserRuleContext())
		}
		p.SetState(626)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 47, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(625)
				p.ElseStatement()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(628)
			p.Match(PhpParserIf)
		}
		{
			p.SetState(629)
			p.Parenthesis()
		}
		{
			p.SetState(630)
			p.Match(PhpParserColon)
		}
		{
			p.SetState(631)
			p.InnerStatementList()
		}
		p.SetState(635)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == PhpParserElseIf {
			{
				p.SetState(632)
				p.ElseIfColonStatement()
			}

			p.SetState(637)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(639)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PhpParserElse {
			{
				p.SetState(638)
				p.ElseColonStatement()
			}

		}
		{
			p.SetState(641)
			p.Match(PhpParserEndIf)
		}
		{
			p.SetState(642)
			p.Match(PhpParserSemiColon)
		}

	}

	return localctx
}

// IElseIfStatementContext is an interface to support dynamic dispatch.
type IElseIfStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElseIfStatementContext differentiates from other interfaces.
	IsElseIfStatementContext()
}

type ElseIfStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElseIfStatementContext() *ElseIfStatementContext {
	var p = new(ElseIfStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_elseIfStatement
	return p
}

func (*ElseIfStatementContext) IsElseIfStatementContext() {}

func NewElseIfStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElseIfStatementContext {
	var p = new(ElseIfStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_elseIfStatement

	return p
}

func (s *ElseIfStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ElseIfStatementContext) ElseIf() antlr.TerminalNode {
	return s.GetToken(PhpParserElseIf, 0)
}

func (s *ElseIfStatementContext) Parenthesis() IParenthesisContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParenthesisContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParenthesisContext)
}

func (s *ElseIfStatementContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *ElseIfStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElseIfStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElseIfStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterElseIfStatement(s)
	}
}

func (s *ElseIfStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitElseIfStatement(s)
	}
}

func (p *PhpParser) ElseIfStatement() (localctx IElseIfStatementContext) {
	localctx = NewElseIfStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, PhpParserRULE_elseIfStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(646)
		p.Match(PhpParserElseIf)
	}
	{
		p.SetState(647)
		p.Parenthesis()
	}
	{
		p.SetState(648)
		p.Statement()
	}

	return localctx
}

// IElseIfColonStatementContext is an interface to support dynamic dispatch.
type IElseIfColonStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElseIfColonStatementContext differentiates from other interfaces.
	IsElseIfColonStatementContext()
}

type ElseIfColonStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElseIfColonStatementContext() *ElseIfColonStatementContext {
	var p = new(ElseIfColonStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_elseIfColonStatement
	return p
}

func (*ElseIfColonStatementContext) IsElseIfColonStatementContext() {}

func NewElseIfColonStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElseIfColonStatementContext {
	var p = new(ElseIfColonStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_elseIfColonStatement

	return p
}

func (s *ElseIfColonStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ElseIfColonStatementContext) ElseIf() antlr.TerminalNode {
	return s.GetToken(PhpParserElseIf, 0)
}

func (s *ElseIfColonStatementContext) Parenthesis() IParenthesisContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParenthesisContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParenthesisContext)
}

func (s *ElseIfColonStatementContext) InnerStatementList() IInnerStatementListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInnerStatementListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInnerStatementListContext)
}

func (s *ElseIfColonStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElseIfColonStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElseIfColonStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterElseIfColonStatement(s)
	}
}

func (s *ElseIfColonStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitElseIfColonStatement(s)
	}
}

func (p *PhpParser) ElseIfColonStatement() (localctx IElseIfColonStatementContext) {
	localctx = NewElseIfColonStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, PhpParserRULE_elseIfColonStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(650)
		p.Match(PhpParserElseIf)
	}
	{
		p.SetState(651)
		p.Parenthesis()
	}
	{
		p.SetState(652)
		p.Match(PhpParserColon)
	}
	{
		p.SetState(653)
		p.InnerStatementList()
	}

	return localctx
}

// IElseStatementContext is an interface to support dynamic dispatch.
type IElseStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElseStatementContext differentiates from other interfaces.
	IsElseStatementContext()
}

type ElseStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElseStatementContext() *ElseStatementContext {
	var p = new(ElseStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_elseStatement
	return p
}

func (*ElseStatementContext) IsElseStatementContext() {}

func NewElseStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElseStatementContext {
	var p = new(ElseStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_elseStatement

	return p
}

func (s *ElseStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ElseStatementContext) Else() antlr.TerminalNode {
	return s.GetToken(PhpParserElse, 0)
}

func (s *ElseStatementContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *ElseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElseStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElseStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterElseStatement(s)
	}
}

func (s *ElseStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitElseStatement(s)
	}
}

func (p *PhpParser) ElseStatement() (localctx IElseStatementContext) {
	localctx = NewElseStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, PhpParserRULE_elseStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(655)
		p.Match(PhpParserElse)
	}
	{
		p.SetState(656)
		p.Statement()
	}

	return localctx
}

// IElseColonStatementContext is an interface to support dynamic dispatch.
type IElseColonStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElseColonStatementContext differentiates from other interfaces.
	IsElseColonStatementContext()
}

type ElseColonStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElseColonStatementContext() *ElseColonStatementContext {
	var p = new(ElseColonStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_elseColonStatement
	return p
}

func (*ElseColonStatementContext) IsElseColonStatementContext() {}

func NewElseColonStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElseColonStatementContext {
	var p = new(ElseColonStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_elseColonStatement

	return p
}

func (s *ElseColonStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ElseColonStatementContext) Else() antlr.TerminalNode {
	return s.GetToken(PhpParserElse, 0)
}

func (s *ElseColonStatementContext) InnerStatementList() IInnerStatementListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInnerStatementListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInnerStatementListContext)
}

func (s *ElseColonStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElseColonStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElseColonStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterElseColonStatement(s)
	}
}

func (s *ElseColonStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitElseColonStatement(s)
	}
}

func (p *PhpParser) ElseColonStatement() (localctx IElseColonStatementContext) {
	localctx = NewElseColonStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, PhpParserRULE_elseColonStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(658)
		p.Match(PhpParserElse)
	}
	{
		p.SetState(659)
		p.Match(PhpParserColon)
	}
	{
		p.SetState(660)
		p.InnerStatementList()
	}

	return localctx
}

// IWhileStatementContext is an interface to support dynamic dispatch.
type IWhileStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWhileStatementContext differentiates from other interfaces.
	IsWhileStatementContext()
}

type WhileStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhileStatementContext() *WhileStatementContext {
	var p = new(WhileStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_whileStatement
	return p
}

func (*WhileStatementContext) IsWhileStatementContext() {}

func NewWhileStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhileStatementContext {
	var p = new(WhileStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_whileStatement

	return p
}

func (s *WhileStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *WhileStatementContext) While() antlr.TerminalNode {
	return s.GetToken(PhpParserWhile, 0)
}

func (s *WhileStatementContext) Parenthesis() IParenthesisContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParenthesisContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParenthesisContext)
}

func (s *WhileStatementContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *WhileStatementContext) InnerStatementList() IInnerStatementListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInnerStatementListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInnerStatementListContext)
}

func (s *WhileStatementContext) EndWhile() antlr.TerminalNode {
	return s.GetToken(PhpParserEndWhile, 0)
}

func (s *WhileStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhileStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhileStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterWhileStatement(s)
	}
}

func (s *WhileStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitWhileStatement(s)
	}
}

func (p *PhpParser) WhileStatement() (localctx IWhileStatementContext) {
	localctx = NewWhileStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, PhpParserRULE_whileStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(662)
		p.Match(PhpParserWhile)
	}
	{
		p.SetState(663)
		p.Parenthesis()
	}
	p.SetState(670)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PhpParserHtmlText, PhpParserXmlStart, PhpParserHtmlScriptOpen, PhpParserHtmlStyleOpen, PhpParserHtmlDtd, PhpParserHtmlOpen, PhpParserHtmlClose, PhpParserHtmlSlashClose, PhpParserHtmlSlash, PhpParserHtmlEquals, PhpParserHtmlStartQuoteString, PhpParserHtmlStartDoubleQuoteString, PhpParserHtmlHex, PhpParserHtmlDecimal, PhpParserHtmlName, PhpParserHtmlEndQuoteString, PhpParserHtmlQuoteString, PhpParserHtmlEndDoubleQuoteString, PhpParserHtmlDoubleQuoteString, PhpParserScriptText, PhpParserScriptClose, PhpParserStyleBody, PhpParserAbstract, PhpParserArray, PhpParserAs, PhpParserBinaryCast, PhpParserBoolType, PhpParserBooleanConstant, PhpParserBreak, PhpParserCallable, PhpParserCase, PhpParserCatch, PhpParserClass, PhpParserClone, PhpParserConst, PhpParserContinue, PhpParserDeclare, PhpParserDefault, PhpParserDo, PhpParserDoubleCast, PhpParserDoubleType, PhpParserEcho, PhpParserElse, PhpParserElseIf, PhpParserEmpty, PhpParserEndDeclare, PhpParserEndFor, PhpParserEndForeach, PhpParserEndIf, PhpParserEndSwitch, PhpParserEndWhile, PhpParserEval, PhpParserExit, PhpParserExtends, PhpParserFinal, PhpParserFinally, PhpParserFloatCast, PhpParserFor, PhpParserForeach, PhpParserFunction, PhpParserGlobal, PhpParserGoto, PhpParserIf, PhpParserImplements, PhpParserImport, PhpParserInclude, PhpParserIncludeOnce, PhpParserInstanceOf, PhpParserInsteadOf, PhpParserInt8Cast, PhpParserInt16Cast, PhpParserInt64Type, PhpParserIntType, PhpParserInterface, PhpParserIsSet, PhpParserList, PhpParserLogicalAnd, PhpParserLogicalOr, PhpParserLogicalXor, PhpParserNamespace, PhpParserNew, PhpParserNull, PhpParserObjectType, PhpParserParent_, PhpParserPartial, PhpParserPrint, PhpParserPrivate, PhpParserProtected, PhpParserPublic, PhpParserRequire, PhpParserRequireOnce, PhpParserResource, PhpParserReturn, PhpParserStatic, PhpParserStringType, PhpParserSwitch, PhpParserThrow, PhpParserTrait, PhpParserTry, PhpParserTypeof, PhpParserUintCast, PhpParserUnicodeCast, PhpParserUnset, PhpParserUse, PhpParserVar, PhpParserWhile, PhpParserYield, PhpParserGet, PhpParserSet, PhpParserCall, PhpParserCallStatic, PhpParserConstructor, PhpParserDestruct, PhpParserWakeup, PhpParserSleep, PhpParserAutoload, PhpParserIsSet__, PhpParserUnset__, PhpParserToString__, PhpParserInvoke, PhpParserSetState, PhpParserClone__, PhpParserDebugInfo, PhpParserNamespace__, PhpParserClass__, PhpParserTraic__, PhpParserFunction__, PhpParserMethod__, PhpParserLine__, PhpParserFile__, PhpParserDir__, PhpParserInc, PhpParserDec, PhpParserNamespaceSeparator, PhpParserBang, PhpParserPlus, PhpParserMinus, PhpParserTilde, PhpParserSuppressWarnings, PhpParserDollar, PhpParserOpenRoundBracket, PhpParserOpenSquareBracket, PhpParserOpenCurlyBracket, PhpParserSemiColon, PhpParserVarName, PhpParserLabel, PhpParserOctal, PhpParserDecimal, PhpParserReal, PhpParserHex, PhpParserBinary, PhpParserBackQuoteString, PhpParserSingleQuoteString, PhpParserDoubleQuote, PhpParserStartNowDoc, PhpParserStartHereDoc:
		{
			p.SetState(664)
			p.Statement()
		}

	case PhpParserColon:
		{
			p.SetState(665)
			p.Match(PhpParserColon)
		}
		{
			p.SetState(666)
			p.InnerStatementList()
		}
		{
			p.SetState(667)
			p.Match(PhpParserEndWhile)
		}
		{
			p.SetState(668)
			p.Match(PhpParserSemiColon)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IDoWhileStatementContext is an interface to support dynamic dispatch.
type IDoWhileStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDoWhileStatementContext differentiates from other interfaces.
	IsDoWhileStatementContext()
}

type DoWhileStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDoWhileStatementContext() *DoWhileStatementContext {
	var p = new(DoWhileStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_doWhileStatement
	return p
}

func (*DoWhileStatementContext) IsDoWhileStatementContext() {}

func NewDoWhileStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DoWhileStatementContext {
	var p = new(DoWhileStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_doWhileStatement

	return p
}

func (s *DoWhileStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DoWhileStatementContext) Do() antlr.TerminalNode {
	return s.GetToken(PhpParserDo, 0)
}

func (s *DoWhileStatementContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *DoWhileStatementContext) While() antlr.TerminalNode {
	return s.GetToken(PhpParserWhile, 0)
}

func (s *DoWhileStatementContext) Parenthesis() IParenthesisContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParenthesisContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParenthesisContext)
}

func (s *DoWhileStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DoWhileStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DoWhileStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterDoWhileStatement(s)
	}
}

func (s *DoWhileStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitDoWhileStatement(s)
	}
}

func (p *PhpParser) DoWhileStatement() (localctx IDoWhileStatementContext) {
	localctx = NewDoWhileStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, PhpParserRULE_doWhileStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(672)
		p.Match(PhpParserDo)
	}
	{
		p.SetState(673)
		p.Statement()
	}
	{
		p.SetState(674)
		p.Match(PhpParserWhile)
	}
	{
		p.SetState(675)
		p.Parenthesis()
	}
	{
		p.SetState(676)
		p.Match(PhpParserSemiColon)
	}

	return localctx
}

// IForStatementContext is an interface to support dynamic dispatch.
type IForStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsForStatementContext differentiates from other interfaces.
	IsForStatementContext()
}

type ForStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForStatementContext() *ForStatementContext {
	var p = new(ForStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_forStatement
	return p
}

func (*ForStatementContext) IsForStatementContext() {}

func NewForStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForStatementContext {
	var p = new(ForStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_forStatement

	return p
}

func (s *ForStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ForStatementContext) For() antlr.TerminalNode {
	return s.GetToken(PhpParserFor, 0)
}

func (s *ForStatementContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *ForStatementContext) InnerStatementList() IInnerStatementListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInnerStatementListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInnerStatementListContext)
}

func (s *ForStatementContext) EndFor() antlr.TerminalNode {
	return s.GetToken(PhpParserEndFor, 0)
}

func (s *ForStatementContext) ForInit() IForInitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IForInitContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IForInitContext)
}

func (s *ForStatementContext) ExpressionList() IExpressionListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *ForStatementContext) ForUpdate() IForUpdateContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IForUpdateContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IForUpdateContext)
}

func (s *ForStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterForStatement(s)
	}
}

func (s *ForStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitForStatement(s)
	}
}

func (p *PhpParser) ForStatement() (localctx IForStatementContext) {
	localctx = NewForStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, PhpParserRULE_forStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(678)
		p.Match(PhpParserFor)
	}
	{
		p.SetState(679)
		p.Match(PhpParserOpenRoundBracket)
	}
	p.SetState(681)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la-43)&-(0x1f+1)) == 0 && ((1<<uint((_la-43)))&((1<<(PhpParserAbstract-43))|(1<<(PhpParserArray-43))|(1<<(PhpParserAs-43))|(1<<(PhpParserBinaryCast-43))|(1<<(PhpParserBoolType-43))|(1<<(PhpParserBooleanConstant-43))|(1<<(PhpParserBreak-43))|(1<<(PhpParserCallable-43))|(1<<(PhpParserCase-43))|(1<<(PhpParserCatch-43))|(1<<(PhpParserClass-43))|(1<<(PhpParserClone-43))|(1<<(PhpParserConst-43))|(1<<(PhpParserContinue-43))|(1<<(PhpParserDeclare-43))|(1<<(PhpParserDefault-43))|(1<<(PhpParserDo-43))|(1<<(PhpParserDoubleCast-43))|(1<<(PhpParserDoubleType-43))|(1<<(PhpParserEcho-43))|(1<<(PhpParserElse-43))|(1<<(PhpParserElseIf-43))|(1<<(PhpParserEmpty-43))|(1<<(PhpParserEndDeclare-43))|(1<<(PhpParserEndFor-43))|(1<<(PhpParserEndForeach-43))|(1<<(PhpParserEndIf-43))|(1<<(PhpParserEndSwitch-43))|(1<<(PhpParserEndWhile-43))|(1<<(PhpParserEval-43))|(1<<(PhpParserExit-43))|(1<<(PhpParserExtends-43)))) != 0) || (((_la-75)&-(0x1f+1)) == 0 && ((1<<uint((_la-75)))&((1<<(PhpParserFinal-75))|(1<<(PhpParserFinally-75))|(1<<(PhpParserFloatCast-75))|(1<<(PhpParserFor-75))|(1<<(PhpParserForeach-75))|(1<<(PhpParserFunction-75))|(1<<(PhpParserGlobal-75))|(1<<(PhpParserGoto-75))|(1<<(PhpParserIf-75))|(1<<(PhpParserImplements-75))|(1<<(PhpParserImport-75))|(1<<(PhpParserInclude-75))|(1<<(PhpParserIncludeOnce-75))|(1<<(PhpParserInstanceOf-75))|(1<<(PhpParserInsteadOf-75))|(1<<(PhpParserInt8Cast-75))|(1<<(PhpParserInt16Cast-75))|(1<<(PhpParserInt64Type-75))|(1<<(PhpParserIntType-75))|(1<<(PhpParserInterface-75))|(1<<(PhpParserIsSet-75))|(1<<(PhpParserList-75))|(1<<(PhpParserLogicalAnd-75))|(1<<(PhpParserLogicalOr-75))|(1<<(PhpParserLogicalXor-75))|(1<<(PhpParserNamespace-75))|(1<<(PhpParserNew-75))|(1<<(PhpParserNull-75))|(1<<(PhpParserObjectType-75))|(1<<(PhpParserParent_-75))|(1<<(PhpParserPartial-75))|(1<<(PhpParserPrint-75)))) != 0) || (((_la-107)&-(0x1f+1)) == 0 && ((1<<uint((_la-107)))&((1<<(PhpParserPrivate-107))|(1<<(PhpParserProtected-107))|(1<<(PhpParserPublic-107))|(1<<(PhpParserRequire-107))|(1<<(PhpParserRequireOnce-107))|(1<<(PhpParserResource-107))|(1<<(PhpParserReturn-107))|(1<<(PhpParserStatic-107))|(1<<(PhpParserStringType-107))|(1<<(PhpParserSwitch-107))|(1<<(PhpParserThrow-107))|(1<<(PhpParserTrait-107))|(1<<(PhpParserTry-107))|(1<<(PhpParserTypeof-107))|(1<<(PhpParserUintCast-107))|(1<<(PhpParserUnicodeCast-107))|(1<<(PhpParserUnset-107))|(1<<(PhpParserUse-107))|(1<<(PhpParserVar-107))|(1<<(PhpParserWhile-107))|(1<<(PhpParserYield-107))|(1<<(PhpParserGet-107))|(1<<(PhpParserSet-107))|(1<<(PhpParserCall-107))|(1<<(PhpParserCallStatic-107))|(1<<(PhpParserConstructor-107))|(1<<(PhpParserDestruct-107))|(1<<(PhpParserWakeup-107))|(1<<(PhpParserSleep-107))|(1<<(PhpParserAutoload-107))|(1<<(PhpParserIsSet__-107))|(1<<(PhpParserUnset__-107)))) != 0) || (((_la-139)&-(0x1f+1)) == 0 && ((1<<uint((_la-139)))&((1<<(PhpParserToString__-139))|(1<<(PhpParserInvoke-139))|(1<<(PhpParserSetState-139))|(1<<(PhpParserClone__-139))|(1<<(PhpParserDebugInfo-139))|(1<<(PhpParserNamespace__-139))|(1<<(PhpParserClass__-139))|(1<<(PhpParserTraic__-139))|(1<<(PhpParserFunction__-139))|(1<<(PhpParserMethod__-139))|(1<<(PhpParserLine__-139))|(1<<(PhpParserFile__-139))|(1<<(PhpParserDir__-139))|(1<<(PhpParserInc-139))|(1<<(PhpParserDec-139)))) != 0) || (((_la-182)&-(0x1f+1)) == 0 && ((1<<uint((_la-182)))&((1<<(PhpParserNamespaceSeparator-182))|(1<<(PhpParserBang-182))|(1<<(PhpParserPlus-182))|(1<<(PhpParserMinus-182))|(1<<(PhpParserTilde-182))|(1<<(PhpParserSuppressWarnings-182))|(1<<(PhpParserDollar-182))|(1<<(PhpParserOpenRoundBracket-182))|(1<<(PhpParserOpenSquareBracket-182))|(1<<(PhpParserVarName-182))|(1<<(PhpParserLabel-182)))) != 0) || (((_la-214)&-(0x1f+1)) == 0 && ((1<<uint((_la-214)))&((1<<(PhpParserOctal-214))|(1<<(PhpParserDecimal-214))|(1<<(PhpParserReal-214))|(1<<(PhpParserHex-214))|(1<<(PhpParserBinary-214))|(1<<(PhpParserBackQuoteString-214))|(1<<(PhpParserSingleQuoteString-214))|(1<<(PhpParserDoubleQuote-214))|(1<<(PhpParserStartNowDoc-214))|(1<<(PhpParserStartHereDoc-214)))) != 0) {
		{
			p.SetState(680)
			p.ForInit()
		}

	}
	{
		p.SetState(683)
		p.Match(PhpParserSemiColon)
	}
	p.SetState(685)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la-43)&-(0x1f+1)) == 0 && ((1<<uint((_la-43)))&((1<<(PhpParserAbstract-43))|(1<<(PhpParserArray-43))|(1<<(PhpParserAs-43))|(1<<(PhpParserBinaryCast-43))|(1<<(PhpParserBoolType-43))|(1<<(PhpParserBooleanConstant-43))|(1<<(PhpParserBreak-43))|(1<<(PhpParserCallable-43))|(1<<(PhpParserCase-43))|(1<<(PhpParserCatch-43))|(1<<(PhpParserClass-43))|(1<<(PhpParserClone-43))|(1<<(PhpParserConst-43))|(1<<(PhpParserContinue-43))|(1<<(PhpParserDeclare-43))|(1<<(PhpParserDefault-43))|(1<<(PhpParserDo-43))|(1<<(PhpParserDoubleCast-43))|(1<<(PhpParserDoubleType-43))|(1<<(PhpParserEcho-43))|(1<<(PhpParserElse-43))|(1<<(PhpParserElseIf-43))|(1<<(PhpParserEmpty-43))|(1<<(PhpParserEndDeclare-43))|(1<<(PhpParserEndFor-43))|(1<<(PhpParserEndForeach-43))|(1<<(PhpParserEndIf-43))|(1<<(PhpParserEndSwitch-43))|(1<<(PhpParserEndWhile-43))|(1<<(PhpParserEval-43))|(1<<(PhpParserExit-43))|(1<<(PhpParserExtends-43)))) != 0) || (((_la-75)&-(0x1f+1)) == 0 && ((1<<uint((_la-75)))&((1<<(PhpParserFinal-75))|(1<<(PhpParserFinally-75))|(1<<(PhpParserFloatCast-75))|(1<<(PhpParserFor-75))|(1<<(PhpParserForeach-75))|(1<<(PhpParserFunction-75))|(1<<(PhpParserGlobal-75))|(1<<(PhpParserGoto-75))|(1<<(PhpParserIf-75))|(1<<(PhpParserImplements-75))|(1<<(PhpParserImport-75))|(1<<(PhpParserInclude-75))|(1<<(PhpParserIncludeOnce-75))|(1<<(PhpParserInstanceOf-75))|(1<<(PhpParserInsteadOf-75))|(1<<(PhpParserInt8Cast-75))|(1<<(PhpParserInt16Cast-75))|(1<<(PhpParserInt64Type-75))|(1<<(PhpParserIntType-75))|(1<<(PhpParserInterface-75))|(1<<(PhpParserIsSet-75))|(1<<(PhpParserList-75))|(1<<(PhpParserLogicalAnd-75))|(1<<(PhpParserLogicalOr-75))|(1<<(PhpParserLogicalXor-75))|(1<<(PhpParserNamespace-75))|(1<<(PhpParserNew-75))|(1<<(PhpParserNull-75))|(1<<(PhpParserObjectType-75))|(1<<(PhpParserParent_-75))|(1<<(PhpParserPartial-75))|(1<<(PhpParserPrint-75)))) != 0) || (((_la-107)&-(0x1f+1)) == 0 && ((1<<uint((_la-107)))&((1<<(PhpParserPrivate-107))|(1<<(PhpParserProtected-107))|(1<<(PhpParserPublic-107))|(1<<(PhpParserRequire-107))|(1<<(PhpParserRequireOnce-107))|(1<<(PhpParserResource-107))|(1<<(PhpParserReturn-107))|(1<<(PhpParserStatic-107))|(1<<(PhpParserStringType-107))|(1<<(PhpParserSwitch-107))|(1<<(PhpParserThrow-107))|(1<<(PhpParserTrait-107))|(1<<(PhpParserTry-107))|(1<<(PhpParserTypeof-107))|(1<<(PhpParserUintCast-107))|(1<<(PhpParserUnicodeCast-107))|(1<<(PhpParserUnset-107))|(1<<(PhpParserUse-107))|(1<<(PhpParserVar-107))|(1<<(PhpParserWhile-107))|(1<<(PhpParserYield-107))|(1<<(PhpParserGet-107))|(1<<(PhpParserSet-107))|(1<<(PhpParserCall-107))|(1<<(PhpParserCallStatic-107))|(1<<(PhpParserConstructor-107))|(1<<(PhpParserDestruct-107))|(1<<(PhpParserWakeup-107))|(1<<(PhpParserSleep-107))|(1<<(PhpParserAutoload-107))|(1<<(PhpParserIsSet__-107))|(1<<(PhpParserUnset__-107)))) != 0) || (((_la-139)&-(0x1f+1)) == 0 && ((1<<uint((_la-139)))&((1<<(PhpParserToString__-139))|(1<<(PhpParserInvoke-139))|(1<<(PhpParserSetState-139))|(1<<(PhpParserClone__-139))|(1<<(PhpParserDebugInfo-139))|(1<<(PhpParserNamespace__-139))|(1<<(PhpParserClass__-139))|(1<<(PhpParserTraic__-139))|(1<<(PhpParserFunction__-139))|(1<<(PhpParserMethod__-139))|(1<<(PhpParserLine__-139))|(1<<(PhpParserFile__-139))|(1<<(PhpParserDir__-139))|(1<<(PhpParserInc-139))|(1<<(PhpParserDec-139)))) != 0) || (((_la-182)&-(0x1f+1)) == 0 && ((1<<uint((_la-182)))&((1<<(PhpParserNamespaceSeparator-182))|(1<<(PhpParserBang-182))|(1<<(PhpParserPlus-182))|(1<<(PhpParserMinus-182))|(1<<(PhpParserTilde-182))|(1<<(PhpParserSuppressWarnings-182))|(1<<(PhpParserDollar-182))|(1<<(PhpParserOpenRoundBracket-182))|(1<<(PhpParserOpenSquareBracket-182))|(1<<(PhpParserVarName-182))|(1<<(PhpParserLabel-182)))) != 0) || (((_la-214)&-(0x1f+1)) == 0 && ((1<<uint((_la-214)))&((1<<(PhpParserOctal-214))|(1<<(PhpParserDecimal-214))|(1<<(PhpParserReal-214))|(1<<(PhpParserHex-214))|(1<<(PhpParserBinary-214))|(1<<(PhpParserBackQuoteString-214))|(1<<(PhpParserSingleQuoteString-214))|(1<<(PhpParserDoubleQuote-214))|(1<<(PhpParserStartNowDoc-214))|(1<<(PhpParserStartHereDoc-214)))) != 0) {
		{
			p.SetState(684)
			p.ExpressionList()
		}

	}
	{
		p.SetState(687)
		p.Match(PhpParserSemiColon)
	}
	p.SetState(689)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la-43)&-(0x1f+1)) == 0 && ((1<<uint((_la-43)))&((1<<(PhpParserAbstract-43))|(1<<(PhpParserArray-43))|(1<<(PhpParserAs-43))|(1<<(PhpParserBinaryCast-43))|(1<<(PhpParserBoolType-43))|(1<<(PhpParserBooleanConstant-43))|(1<<(PhpParserBreak-43))|(1<<(PhpParserCallable-43))|(1<<(PhpParserCase-43))|(1<<(PhpParserCatch-43))|(1<<(PhpParserClass-43))|(1<<(PhpParserClone-43))|(1<<(PhpParserConst-43))|(1<<(PhpParserContinue-43))|(1<<(PhpParserDeclare-43))|(1<<(PhpParserDefault-43))|(1<<(PhpParserDo-43))|(1<<(PhpParserDoubleCast-43))|(1<<(PhpParserDoubleType-43))|(1<<(PhpParserEcho-43))|(1<<(PhpParserElse-43))|(1<<(PhpParserElseIf-43))|(1<<(PhpParserEmpty-43))|(1<<(PhpParserEndDeclare-43))|(1<<(PhpParserEndFor-43))|(1<<(PhpParserEndForeach-43))|(1<<(PhpParserEndIf-43))|(1<<(PhpParserEndSwitch-43))|(1<<(PhpParserEndWhile-43))|(1<<(PhpParserEval-43))|(1<<(PhpParserExit-43))|(1<<(PhpParserExtends-43)))) != 0) || (((_la-75)&-(0x1f+1)) == 0 && ((1<<uint((_la-75)))&((1<<(PhpParserFinal-75))|(1<<(PhpParserFinally-75))|(1<<(PhpParserFloatCast-75))|(1<<(PhpParserFor-75))|(1<<(PhpParserForeach-75))|(1<<(PhpParserFunction-75))|(1<<(PhpParserGlobal-75))|(1<<(PhpParserGoto-75))|(1<<(PhpParserIf-75))|(1<<(PhpParserImplements-75))|(1<<(PhpParserImport-75))|(1<<(PhpParserInclude-75))|(1<<(PhpParserIncludeOnce-75))|(1<<(PhpParserInstanceOf-75))|(1<<(PhpParserInsteadOf-75))|(1<<(PhpParserInt8Cast-75))|(1<<(PhpParserInt16Cast-75))|(1<<(PhpParserInt64Type-75))|(1<<(PhpParserIntType-75))|(1<<(PhpParserInterface-75))|(1<<(PhpParserIsSet-75))|(1<<(PhpParserList-75))|(1<<(PhpParserLogicalAnd-75))|(1<<(PhpParserLogicalOr-75))|(1<<(PhpParserLogicalXor-75))|(1<<(PhpParserNamespace-75))|(1<<(PhpParserNew-75))|(1<<(PhpParserNull-75))|(1<<(PhpParserObjectType-75))|(1<<(PhpParserParent_-75))|(1<<(PhpParserPartial-75))|(1<<(PhpParserPrint-75)))) != 0) || (((_la-107)&-(0x1f+1)) == 0 && ((1<<uint((_la-107)))&((1<<(PhpParserPrivate-107))|(1<<(PhpParserProtected-107))|(1<<(PhpParserPublic-107))|(1<<(PhpParserRequire-107))|(1<<(PhpParserRequireOnce-107))|(1<<(PhpParserResource-107))|(1<<(PhpParserReturn-107))|(1<<(PhpParserStatic-107))|(1<<(PhpParserStringType-107))|(1<<(PhpParserSwitch-107))|(1<<(PhpParserThrow-107))|(1<<(PhpParserTrait-107))|(1<<(PhpParserTry-107))|(1<<(PhpParserTypeof-107))|(1<<(PhpParserUintCast-107))|(1<<(PhpParserUnicodeCast-107))|(1<<(PhpParserUnset-107))|(1<<(PhpParserUse-107))|(1<<(PhpParserVar-107))|(1<<(PhpParserWhile-107))|(1<<(PhpParserYield-107))|(1<<(PhpParserGet-107))|(1<<(PhpParserSet-107))|(1<<(PhpParserCall-107))|(1<<(PhpParserCallStatic-107))|(1<<(PhpParserConstructor-107))|(1<<(PhpParserDestruct-107))|(1<<(PhpParserWakeup-107))|(1<<(PhpParserSleep-107))|(1<<(PhpParserAutoload-107))|(1<<(PhpParserIsSet__-107))|(1<<(PhpParserUnset__-107)))) != 0) || (((_la-139)&-(0x1f+1)) == 0 && ((1<<uint((_la-139)))&((1<<(PhpParserToString__-139))|(1<<(PhpParserInvoke-139))|(1<<(PhpParserSetState-139))|(1<<(PhpParserClone__-139))|(1<<(PhpParserDebugInfo-139))|(1<<(PhpParserNamespace__-139))|(1<<(PhpParserClass__-139))|(1<<(PhpParserTraic__-139))|(1<<(PhpParserFunction__-139))|(1<<(PhpParserMethod__-139))|(1<<(PhpParserLine__-139))|(1<<(PhpParserFile__-139))|(1<<(PhpParserDir__-139))|(1<<(PhpParserInc-139))|(1<<(PhpParserDec-139)))) != 0) || (((_la-182)&-(0x1f+1)) == 0 && ((1<<uint((_la-182)))&((1<<(PhpParserNamespaceSeparator-182))|(1<<(PhpParserBang-182))|(1<<(PhpParserPlus-182))|(1<<(PhpParserMinus-182))|(1<<(PhpParserTilde-182))|(1<<(PhpParserSuppressWarnings-182))|(1<<(PhpParserDollar-182))|(1<<(PhpParserOpenRoundBracket-182))|(1<<(PhpParserOpenSquareBracket-182))|(1<<(PhpParserVarName-182))|(1<<(PhpParserLabel-182)))) != 0) || (((_la-214)&-(0x1f+1)) == 0 && ((1<<uint((_la-214)))&((1<<(PhpParserOctal-214))|(1<<(PhpParserDecimal-214))|(1<<(PhpParserReal-214))|(1<<(PhpParserHex-214))|(1<<(PhpParserBinary-214))|(1<<(PhpParserBackQuoteString-214))|(1<<(PhpParserSingleQuoteString-214))|(1<<(PhpParserDoubleQuote-214))|(1<<(PhpParserStartNowDoc-214))|(1<<(PhpParserStartHereDoc-214)))) != 0) {
		{
			p.SetState(688)
			p.ForUpdate()
		}

	}
	{
		p.SetState(691)
		p.Match(PhpParserCloseRoundBracket)
	}
	p.SetState(698)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PhpParserHtmlText, PhpParserXmlStart, PhpParserHtmlScriptOpen, PhpParserHtmlStyleOpen, PhpParserHtmlDtd, PhpParserHtmlOpen, PhpParserHtmlClose, PhpParserHtmlSlashClose, PhpParserHtmlSlash, PhpParserHtmlEquals, PhpParserHtmlStartQuoteString, PhpParserHtmlStartDoubleQuoteString, PhpParserHtmlHex, PhpParserHtmlDecimal, PhpParserHtmlName, PhpParserHtmlEndQuoteString, PhpParserHtmlQuoteString, PhpParserHtmlEndDoubleQuoteString, PhpParserHtmlDoubleQuoteString, PhpParserScriptText, PhpParserScriptClose, PhpParserStyleBody, PhpParserAbstract, PhpParserArray, PhpParserAs, PhpParserBinaryCast, PhpParserBoolType, PhpParserBooleanConstant, PhpParserBreak, PhpParserCallable, PhpParserCase, PhpParserCatch, PhpParserClass, PhpParserClone, PhpParserConst, PhpParserContinue, PhpParserDeclare, PhpParserDefault, PhpParserDo, PhpParserDoubleCast, PhpParserDoubleType, PhpParserEcho, PhpParserElse, PhpParserElseIf, PhpParserEmpty, PhpParserEndDeclare, PhpParserEndFor, PhpParserEndForeach, PhpParserEndIf, PhpParserEndSwitch, PhpParserEndWhile, PhpParserEval, PhpParserExit, PhpParserExtends, PhpParserFinal, PhpParserFinally, PhpParserFloatCast, PhpParserFor, PhpParserForeach, PhpParserFunction, PhpParserGlobal, PhpParserGoto, PhpParserIf, PhpParserImplements, PhpParserImport, PhpParserInclude, PhpParserIncludeOnce, PhpParserInstanceOf, PhpParserInsteadOf, PhpParserInt8Cast, PhpParserInt16Cast, PhpParserInt64Type, PhpParserIntType, PhpParserInterface, PhpParserIsSet, PhpParserList, PhpParserLogicalAnd, PhpParserLogicalOr, PhpParserLogicalXor, PhpParserNamespace, PhpParserNew, PhpParserNull, PhpParserObjectType, PhpParserParent_, PhpParserPartial, PhpParserPrint, PhpParserPrivate, PhpParserProtected, PhpParserPublic, PhpParserRequire, PhpParserRequireOnce, PhpParserResource, PhpParserReturn, PhpParserStatic, PhpParserStringType, PhpParserSwitch, PhpParserThrow, PhpParserTrait, PhpParserTry, PhpParserTypeof, PhpParserUintCast, PhpParserUnicodeCast, PhpParserUnset, PhpParserUse, PhpParserVar, PhpParserWhile, PhpParserYield, PhpParserGet, PhpParserSet, PhpParserCall, PhpParserCallStatic, PhpParserConstructor, PhpParserDestruct, PhpParserWakeup, PhpParserSleep, PhpParserAutoload, PhpParserIsSet__, PhpParserUnset__, PhpParserToString__, PhpParserInvoke, PhpParserSetState, PhpParserClone__, PhpParserDebugInfo, PhpParserNamespace__, PhpParserClass__, PhpParserTraic__, PhpParserFunction__, PhpParserMethod__, PhpParserLine__, PhpParserFile__, PhpParserDir__, PhpParserInc, PhpParserDec, PhpParserNamespaceSeparator, PhpParserBang, PhpParserPlus, PhpParserMinus, PhpParserTilde, PhpParserSuppressWarnings, PhpParserDollar, PhpParserOpenRoundBracket, PhpParserOpenSquareBracket, PhpParserOpenCurlyBracket, PhpParserSemiColon, PhpParserVarName, PhpParserLabel, PhpParserOctal, PhpParserDecimal, PhpParserReal, PhpParserHex, PhpParserBinary, PhpParserBackQuoteString, PhpParserSingleQuoteString, PhpParserDoubleQuote, PhpParserStartNowDoc, PhpParserStartHereDoc:
		{
			p.SetState(692)
			p.Statement()
		}

	case PhpParserColon:
		{
			p.SetState(693)
			p.Match(PhpParserColon)
		}
		{
			p.SetState(694)
			p.InnerStatementList()
		}
		{
			p.SetState(695)
			p.Match(PhpParserEndFor)
		}
		{
			p.SetState(696)
			p.Match(PhpParserSemiColon)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IForInitContext is an interface to support dynamic dispatch.
type IForInitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsForInitContext differentiates from other interfaces.
	IsForInitContext()
}

type ForInitContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForInitContext() *ForInitContext {
	var p = new(ForInitContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_forInit
	return p
}

func (*ForInitContext) IsForInitContext() {}

func NewForInitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForInitContext {
	var p = new(ForInitContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_forInit

	return p
}

func (s *ForInitContext) GetParser() antlr.Parser { return s.parser }

func (s *ForInitContext) ExpressionList() IExpressionListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *ForInitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForInitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForInitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterForInit(s)
	}
}

func (s *ForInitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitForInit(s)
	}
}

func (p *PhpParser) ForInit() (localctx IForInitContext) {
	localctx = NewForInitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, PhpParserRULE_forInit)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(700)
		p.ExpressionList()
	}

	return localctx
}

// IForUpdateContext is an interface to support dynamic dispatch.
type IForUpdateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsForUpdateContext differentiates from other interfaces.
	IsForUpdateContext()
}

type ForUpdateContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForUpdateContext() *ForUpdateContext {
	var p = new(ForUpdateContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_forUpdate
	return p
}

func (*ForUpdateContext) IsForUpdateContext() {}

func NewForUpdateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForUpdateContext {
	var p = new(ForUpdateContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_forUpdate

	return p
}

func (s *ForUpdateContext) GetParser() antlr.Parser { return s.parser }

func (s *ForUpdateContext) ExpressionList() IExpressionListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *ForUpdateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForUpdateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForUpdateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterForUpdate(s)
	}
}

func (s *ForUpdateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitForUpdate(s)
	}
}

func (p *PhpParser) ForUpdate() (localctx IForUpdateContext) {
	localctx = NewForUpdateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, PhpParserRULE_forUpdate)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(702)
		p.ExpressionList()
	}

	return localctx
}

// ISwitchStatementContext is an interface to support dynamic dispatch.
type ISwitchStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSwitchStatementContext differentiates from other interfaces.
	IsSwitchStatementContext()
}

type SwitchStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySwitchStatementContext() *SwitchStatementContext {
	var p = new(SwitchStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_switchStatement
	return p
}

func (*SwitchStatementContext) IsSwitchStatementContext() {}

func NewSwitchStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SwitchStatementContext {
	var p = new(SwitchStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_switchStatement

	return p
}

func (s *SwitchStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SwitchStatementContext) Switch() antlr.TerminalNode {
	return s.GetToken(PhpParserSwitch, 0)
}

func (s *SwitchStatementContext) Parenthesis() IParenthesisContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParenthesisContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParenthesisContext)
}

func (s *SwitchStatementContext) OpenCurlyBracket() antlr.TerminalNode {
	return s.GetToken(PhpParserOpenCurlyBracket, 0)
}

func (s *SwitchStatementContext) EndSwitch() antlr.TerminalNode {
	return s.GetToken(PhpParserEndSwitch, 0)
}

func (s *SwitchStatementContext) AllSwitchBlock() []ISwitchBlockContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISwitchBlockContext)(nil)).Elem())
	var tst = make([]ISwitchBlockContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISwitchBlockContext)
		}
	}

	return tst
}

func (s *SwitchStatementContext) SwitchBlock(i int) ISwitchBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISwitchBlockContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISwitchBlockContext)
}

func (s *SwitchStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SwitchStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SwitchStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterSwitchStatement(s)
	}
}

func (s *SwitchStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitSwitchStatement(s)
	}
}

func (p *PhpParser) SwitchStatement() (localctx ISwitchStatementContext) {
	localctx = NewSwitchStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, PhpParserRULE_switchStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(704)
		p.Match(PhpParserSwitch)
	}
	{
		p.SetState(705)
		p.Parenthesis()
	}
	p.SetState(729)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PhpParserOpenCurlyBracket:
		{
			p.SetState(706)
			p.Match(PhpParserOpenCurlyBracket)
		}
		p.SetState(708)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PhpParserSemiColon {
			{
				p.SetState(707)
				p.Match(PhpParserSemiColon)
			}

		}
		p.SetState(713)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == PhpParserCase || _la == PhpParserDefault {
			{
				p.SetState(710)
				p.SwitchBlock()
			}

			p.SetState(715)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(716)
			p.Match(PhpParserCloseCurlyBracket)
		}

	case PhpParserColon:
		{
			p.SetState(717)
			p.Match(PhpParserColon)
		}
		p.SetState(719)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PhpParserSemiColon {
			{
				p.SetState(718)
				p.Match(PhpParserSemiColon)
			}

		}
		p.SetState(724)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == PhpParserCase || _la == PhpParserDefault {
			{
				p.SetState(721)
				p.SwitchBlock()
			}

			p.SetState(726)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(727)
			p.Match(PhpParserEndSwitch)
		}
		{
			p.SetState(728)
			p.Match(PhpParserSemiColon)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISwitchBlockContext is an interface to support dynamic dispatch.
type ISwitchBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSwitchBlockContext differentiates from other interfaces.
	IsSwitchBlockContext()
}

type SwitchBlockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySwitchBlockContext() *SwitchBlockContext {
	var p = new(SwitchBlockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_switchBlock
	return p
}

func (*SwitchBlockContext) IsSwitchBlockContext() {}

func NewSwitchBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SwitchBlockContext {
	var p = new(SwitchBlockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_switchBlock

	return p
}

func (s *SwitchBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *SwitchBlockContext) InnerStatementList() IInnerStatementListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInnerStatementListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInnerStatementListContext)
}

func (s *SwitchBlockContext) AllCase() []antlr.TerminalNode {
	return s.GetTokens(PhpParserCase)
}

func (s *SwitchBlockContext) Case(i int) antlr.TerminalNode {
	return s.GetToken(PhpParserCase, i)
}

func (s *SwitchBlockContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *SwitchBlockContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SwitchBlockContext) AllDefault() []antlr.TerminalNode {
	return s.GetTokens(PhpParserDefault)
}

func (s *SwitchBlockContext) Default(i int) antlr.TerminalNode {
	return s.GetToken(PhpParserDefault, i)
}

func (s *SwitchBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SwitchBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SwitchBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterSwitchBlock(s)
	}
}

func (s *SwitchBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitSwitchBlock(s)
	}
}

func (p *PhpParser) SwitchBlock() (localctx ISwitchBlockContext) {
	localctx = NewSwitchBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, PhpParserRULE_switchBlock)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(737)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			p.SetState(734)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case PhpParserCase:
				{
					p.SetState(731)
					p.Match(PhpParserCase)
				}
				{
					p.SetState(732)
					p.expression(0)
				}

			case PhpParserDefault:
				{
					p.SetState(733)
					p.Match(PhpParserDefault)
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}
			{
				p.SetState(736)
				_la = p.GetTokenStream().LA(1)

				if !(_la == PhpParserColon || _la == PhpParserSemiColon) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(739)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 62, p.GetParserRuleContext())
	}
	{
		p.SetState(741)
		p.InnerStatementList()
	}

	return localctx
}

// IBreakStatementContext is an interface to support dynamic dispatch.
type IBreakStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBreakStatementContext differentiates from other interfaces.
	IsBreakStatementContext()
}

type BreakStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBreakStatementContext() *BreakStatementContext {
	var p = new(BreakStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_breakStatement
	return p
}

func (*BreakStatementContext) IsBreakStatementContext() {}

func NewBreakStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BreakStatementContext {
	var p = new(BreakStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_breakStatement

	return p
}

func (s *BreakStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *BreakStatementContext) Break() antlr.TerminalNode {
	return s.GetToken(PhpParserBreak, 0)
}

func (s *BreakStatementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *BreakStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BreakStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BreakStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterBreakStatement(s)
	}
}

func (s *BreakStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitBreakStatement(s)
	}
}

func (p *PhpParser) BreakStatement() (localctx IBreakStatementContext) {
	localctx = NewBreakStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, PhpParserRULE_breakStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(743)
		p.Match(PhpParserBreak)
	}
	p.SetState(745)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la-43)&-(0x1f+1)) == 0 && ((1<<uint((_la-43)))&((1<<(PhpParserAbstract-43))|(1<<(PhpParserArray-43))|(1<<(PhpParserAs-43))|(1<<(PhpParserBinaryCast-43))|(1<<(PhpParserBoolType-43))|(1<<(PhpParserBooleanConstant-43))|(1<<(PhpParserBreak-43))|(1<<(PhpParserCallable-43))|(1<<(PhpParserCase-43))|(1<<(PhpParserCatch-43))|(1<<(PhpParserClass-43))|(1<<(PhpParserClone-43))|(1<<(PhpParserConst-43))|(1<<(PhpParserContinue-43))|(1<<(PhpParserDeclare-43))|(1<<(PhpParserDefault-43))|(1<<(PhpParserDo-43))|(1<<(PhpParserDoubleCast-43))|(1<<(PhpParserDoubleType-43))|(1<<(PhpParserEcho-43))|(1<<(PhpParserElse-43))|(1<<(PhpParserElseIf-43))|(1<<(PhpParserEmpty-43))|(1<<(PhpParserEndDeclare-43))|(1<<(PhpParserEndFor-43))|(1<<(PhpParserEndForeach-43))|(1<<(PhpParserEndIf-43))|(1<<(PhpParserEndSwitch-43))|(1<<(PhpParserEndWhile-43))|(1<<(PhpParserEval-43))|(1<<(PhpParserExit-43))|(1<<(PhpParserExtends-43)))) != 0) || (((_la-75)&-(0x1f+1)) == 0 && ((1<<uint((_la-75)))&((1<<(PhpParserFinal-75))|(1<<(PhpParserFinally-75))|(1<<(PhpParserFloatCast-75))|(1<<(PhpParserFor-75))|(1<<(PhpParserForeach-75))|(1<<(PhpParserFunction-75))|(1<<(PhpParserGlobal-75))|(1<<(PhpParserGoto-75))|(1<<(PhpParserIf-75))|(1<<(PhpParserImplements-75))|(1<<(PhpParserImport-75))|(1<<(PhpParserInclude-75))|(1<<(PhpParserIncludeOnce-75))|(1<<(PhpParserInstanceOf-75))|(1<<(PhpParserInsteadOf-75))|(1<<(PhpParserInt8Cast-75))|(1<<(PhpParserInt16Cast-75))|(1<<(PhpParserInt64Type-75))|(1<<(PhpParserIntType-75))|(1<<(PhpParserInterface-75))|(1<<(PhpParserIsSet-75))|(1<<(PhpParserList-75))|(1<<(PhpParserLogicalAnd-75))|(1<<(PhpParserLogicalOr-75))|(1<<(PhpParserLogicalXor-75))|(1<<(PhpParserNamespace-75))|(1<<(PhpParserNew-75))|(1<<(PhpParserNull-75))|(1<<(PhpParserObjectType-75))|(1<<(PhpParserParent_-75))|(1<<(PhpParserPartial-75))|(1<<(PhpParserPrint-75)))) != 0) || (((_la-107)&-(0x1f+1)) == 0 && ((1<<uint((_la-107)))&((1<<(PhpParserPrivate-107))|(1<<(PhpParserProtected-107))|(1<<(PhpParserPublic-107))|(1<<(PhpParserRequire-107))|(1<<(PhpParserRequireOnce-107))|(1<<(PhpParserResource-107))|(1<<(PhpParserReturn-107))|(1<<(PhpParserStatic-107))|(1<<(PhpParserStringType-107))|(1<<(PhpParserSwitch-107))|(1<<(PhpParserThrow-107))|(1<<(PhpParserTrait-107))|(1<<(PhpParserTry-107))|(1<<(PhpParserTypeof-107))|(1<<(PhpParserUintCast-107))|(1<<(PhpParserUnicodeCast-107))|(1<<(PhpParserUnset-107))|(1<<(PhpParserUse-107))|(1<<(PhpParserVar-107))|(1<<(PhpParserWhile-107))|(1<<(PhpParserYield-107))|(1<<(PhpParserGet-107))|(1<<(PhpParserSet-107))|(1<<(PhpParserCall-107))|(1<<(PhpParserCallStatic-107))|(1<<(PhpParserConstructor-107))|(1<<(PhpParserDestruct-107))|(1<<(PhpParserWakeup-107))|(1<<(PhpParserSleep-107))|(1<<(PhpParserAutoload-107))|(1<<(PhpParserIsSet__-107))|(1<<(PhpParserUnset__-107)))) != 0) || (((_la-139)&-(0x1f+1)) == 0 && ((1<<uint((_la-139)))&((1<<(PhpParserToString__-139))|(1<<(PhpParserInvoke-139))|(1<<(PhpParserSetState-139))|(1<<(PhpParserClone__-139))|(1<<(PhpParserDebugInfo-139))|(1<<(PhpParserNamespace__-139))|(1<<(PhpParserClass__-139))|(1<<(PhpParserTraic__-139))|(1<<(PhpParserFunction__-139))|(1<<(PhpParserMethod__-139))|(1<<(PhpParserLine__-139))|(1<<(PhpParserFile__-139))|(1<<(PhpParserDir__-139))|(1<<(PhpParserInc-139))|(1<<(PhpParserDec-139)))) != 0) || (((_la-182)&-(0x1f+1)) == 0 && ((1<<uint((_la-182)))&((1<<(PhpParserNamespaceSeparator-182))|(1<<(PhpParserBang-182))|(1<<(PhpParserPlus-182))|(1<<(PhpParserMinus-182))|(1<<(PhpParserTilde-182))|(1<<(PhpParserSuppressWarnings-182))|(1<<(PhpParserDollar-182))|(1<<(PhpParserOpenRoundBracket-182))|(1<<(PhpParserOpenSquareBracket-182))|(1<<(PhpParserVarName-182))|(1<<(PhpParserLabel-182)))) != 0) || (((_la-214)&-(0x1f+1)) == 0 && ((1<<uint((_la-214)))&((1<<(PhpParserOctal-214))|(1<<(PhpParserDecimal-214))|(1<<(PhpParserReal-214))|(1<<(PhpParserHex-214))|(1<<(PhpParserBinary-214))|(1<<(PhpParserBackQuoteString-214))|(1<<(PhpParserSingleQuoteString-214))|(1<<(PhpParserDoubleQuote-214))|(1<<(PhpParserStartNowDoc-214))|(1<<(PhpParserStartHereDoc-214)))) != 0) {
		{
			p.SetState(744)
			p.expression(0)
		}

	}
	{
		p.SetState(747)
		p.Match(PhpParserSemiColon)
	}

	return localctx
}

// IContinueStatementContext is an interface to support dynamic dispatch.
type IContinueStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsContinueStatementContext differentiates from other interfaces.
	IsContinueStatementContext()
}

type ContinueStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyContinueStatementContext() *ContinueStatementContext {
	var p = new(ContinueStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_continueStatement
	return p
}

func (*ContinueStatementContext) IsContinueStatementContext() {}

func NewContinueStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ContinueStatementContext {
	var p = new(ContinueStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_continueStatement

	return p
}

func (s *ContinueStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ContinueStatementContext) Continue() antlr.TerminalNode {
	return s.GetToken(PhpParserContinue, 0)
}

func (s *ContinueStatementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ContinueStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ContinueStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ContinueStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterContinueStatement(s)
	}
}

func (s *ContinueStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitContinueStatement(s)
	}
}

func (p *PhpParser) ContinueStatement() (localctx IContinueStatementContext) {
	localctx = NewContinueStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, PhpParserRULE_continueStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(749)
		p.Match(PhpParserContinue)
	}
	p.SetState(751)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la-43)&-(0x1f+1)) == 0 && ((1<<uint((_la-43)))&((1<<(PhpParserAbstract-43))|(1<<(PhpParserArray-43))|(1<<(PhpParserAs-43))|(1<<(PhpParserBinaryCast-43))|(1<<(PhpParserBoolType-43))|(1<<(PhpParserBooleanConstant-43))|(1<<(PhpParserBreak-43))|(1<<(PhpParserCallable-43))|(1<<(PhpParserCase-43))|(1<<(PhpParserCatch-43))|(1<<(PhpParserClass-43))|(1<<(PhpParserClone-43))|(1<<(PhpParserConst-43))|(1<<(PhpParserContinue-43))|(1<<(PhpParserDeclare-43))|(1<<(PhpParserDefault-43))|(1<<(PhpParserDo-43))|(1<<(PhpParserDoubleCast-43))|(1<<(PhpParserDoubleType-43))|(1<<(PhpParserEcho-43))|(1<<(PhpParserElse-43))|(1<<(PhpParserElseIf-43))|(1<<(PhpParserEmpty-43))|(1<<(PhpParserEndDeclare-43))|(1<<(PhpParserEndFor-43))|(1<<(PhpParserEndForeach-43))|(1<<(PhpParserEndIf-43))|(1<<(PhpParserEndSwitch-43))|(1<<(PhpParserEndWhile-43))|(1<<(PhpParserEval-43))|(1<<(PhpParserExit-43))|(1<<(PhpParserExtends-43)))) != 0) || (((_la-75)&-(0x1f+1)) == 0 && ((1<<uint((_la-75)))&((1<<(PhpParserFinal-75))|(1<<(PhpParserFinally-75))|(1<<(PhpParserFloatCast-75))|(1<<(PhpParserFor-75))|(1<<(PhpParserForeach-75))|(1<<(PhpParserFunction-75))|(1<<(PhpParserGlobal-75))|(1<<(PhpParserGoto-75))|(1<<(PhpParserIf-75))|(1<<(PhpParserImplements-75))|(1<<(PhpParserImport-75))|(1<<(PhpParserInclude-75))|(1<<(PhpParserIncludeOnce-75))|(1<<(PhpParserInstanceOf-75))|(1<<(PhpParserInsteadOf-75))|(1<<(PhpParserInt8Cast-75))|(1<<(PhpParserInt16Cast-75))|(1<<(PhpParserInt64Type-75))|(1<<(PhpParserIntType-75))|(1<<(PhpParserInterface-75))|(1<<(PhpParserIsSet-75))|(1<<(PhpParserList-75))|(1<<(PhpParserLogicalAnd-75))|(1<<(PhpParserLogicalOr-75))|(1<<(PhpParserLogicalXor-75))|(1<<(PhpParserNamespace-75))|(1<<(PhpParserNew-75))|(1<<(PhpParserNull-75))|(1<<(PhpParserObjectType-75))|(1<<(PhpParserParent_-75))|(1<<(PhpParserPartial-75))|(1<<(PhpParserPrint-75)))) != 0) || (((_la-107)&-(0x1f+1)) == 0 && ((1<<uint((_la-107)))&((1<<(PhpParserPrivate-107))|(1<<(PhpParserProtected-107))|(1<<(PhpParserPublic-107))|(1<<(PhpParserRequire-107))|(1<<(PhpParserRequireOnce-107))|(1<<(PhpParserResource-107))|(1<<(PhpParserReturn-107))|(1<<(PhpParserStatic-107))|(1<<(PhpParserStringType-107))|(1<<(PhpParserSwitch-107))|(1<<(PhpParserThrow-107))|(1<<(PhpParserTrait-107))|(1<<(PhpParserTry-107))|(1<<(PhpParserTypeof-107))|(1<<(PhpParserUintCast-107))|(1<<(PhpParserUnicodeCast-107))|(1<<(PhpParserUnset-107))|(1<<(PhpParserUse-107))|(1<<(PhpParserVar-107))|(1<<(PhpParserWhile-107))|(1<<(PhpParserYield-107))|(1<<(PhpParserGet-107))|(1<<(PhpParserSet-107))|(1<<(PhpParserCall-107))|(1<<(PhpParserCallStatic-107))|(1<<(PhpParserConstructor-107))|(1<<(PhpParserDestruct-107))|(1<<(PhpParserWakeup-107))|(1<<(PhpParserSleep-107))|(1<<(PhpParserAutoload-107))|(1<<(PhpParserIsSet__-107))|(1<<(PhpParserUnset__-107)))) != 0) || (((_la-139)&-(0x1f+1)) == 0 && ((1<<uint((_la-139)))&((1<<(PhpParserToString__-139))|(1<<(PhpParserInvoke-139))|(1<<(PhpParserSetState-139))|(1<<(PhpParserClone__-139))|(1<<(PhpParserDebugInfo-139))|(1<<(PhpParserNamespace__-139))|(1<<(PhpParserClass__-139))|(1<<(PhpParserTraic__-139))|(1<<(PhpParserFunction__-139))|(1<<(PhpParserMethod__-139))|(1<<(PhpParserLine__-139))|(1<<(PhpParserFile__-139))|(1<<(PhpParserDir__-139))|(1<<(PhpParserInc-139))|(1<<(PhpParserDec-139)))) != 0) || (((_la-182)&-(0x1f+1)) == 0 && ((1<<uint((_la-182)))&((1<<(PhpParserNamespaceSeparator-182))|(1<<(PhpParserBang-182))|(1<<(PhpParserPlus-182))|(1<<(PhpParserMinus-182))|(1<<(PhpParserTilde-182))|(1<<(PhpParserSuppressWarnings-182))|(1<<(PhpParserDollar-182))|(1<<(PhpParserOpenRoundBracket-182))|(1<<(PhpParserOpenSquareBracket-182))|(1<<(PhpParserVarName-182))|(1<<(PhpParserLabel-182)))) != 0) || (((_la-214)&-(0x1f+1)) == 0 && ((1<<uint((_la-214)))&((1<<(PhpParserOctal-214))|(1<<(PhpParserDecimal-214))|(1<<(PhpParserReal-214))|(1<<(PhpParserHex-214))|(1<<(PhpParserBinary-214))|(1<<(PhpParserBackQuoteString-214))|(1<<(PhpParserSingleQuoteString-214))|(1<<(PhpParserDoubleQuote-214))|(1<<(PhpParserStartNowDoc-214))|(1<<(PhpParserStartHereDoc-214)))) != 0) {
		{
			p.SetState(750)
			p.expression(0)
		}

	}
	{
		p.SetState(753)
		p.Match(PhpParserSemiColon)
	}

	return localctx
}

// IReturnStatementContext is an interface to support dynamic dispatch.
type IReturnStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReturnStatementContext differentiates from other interfaces.
	IsReturnStatementContext()
}

type ReturnStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturnStatementContext() *ReturnStatementContext {
	var p = new(ReturnStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_returnStatement
	return p
}

func (*ReturnStatementContext) IsReturnStatementContext() {}

func NewReturnStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReturnStatementContext {
	var p = new(ReturnStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_returnStatement

	return p
}

func (s *ReturnStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnStatementContext) Return() antlr.TerminalNode {
	return s.GetToken(PhpParserReturn, 0)
}

func (s *ReturnStatementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ReturnStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReturnStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterReturnStatement(s)
	}
}

func (s *ReturnStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitReturnStatement(s)
	}
}

func (p *PhpParser) ReturnStatement() (localctx IReturnStatementContext) {
	localctx = NewReturnStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, PhpParserRULE_returnStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(755)
		p.Match(PhpParserReturn)
	}
	p.SetState(757)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la-43)&-(0x1f+1)) == 0 && ((1<<uint((_la-43)))&((1<<(PhpParserAbstract-43))|(1<<(PhpParserArray-43))|(1<<(PhpParserAs-43))|(1<<(PhpParserBinaryCast-43))|(1<<(PhpParserBoolType-43))|(1<<(PhpParserBooleanConstant-43))|(1<<(PhpParserBreak-43))|(1<<(PhpParserCallable-43))|(1<<(PhpParserCase-43))|(1<<(PhpParserCatch-43))|(1<<(PhpParserClass-43))|(1<<(PhpParserClone-43))|(1<<(PhpParserConst-43))|(1<<(PhpParserContinue-43))|(1<<(PhpParserDeclare-43))|(1<<(PhpParserDefault-43))|(1<<(PhpParserDo-43))|(1<<(PhpParserDoubleCast-43))|(1<<(PhpParserDoubleType-43))|(1<<(PhpParserEcho-43))|(1<<(PhpParserElse-43))|(1<<(PhpParserElseIf-43))|(1<<(PhpParserEmpty-43))|(1<<(PhpParserEndDeclare-43))|(1<<(PhpParserEndFor-43))|(1<<(PhpParserEndForeach-43))|(1<<(PhpParserEndIf-43))|(1<<(PhpParserEndSwitch-43))|(1<<(PhpParserEndWhile-43))|(1<<(PhpParserEval-43))|(1<<(PhpParserExit-43))|(1<<(PhpParserExtends-43)))) != 0) || (((_la-75)&-(0x1f+1)) == 0 && ((1<<uint((_la-75)))&((1<<(PhpParserFinal-75))|(1<<(PhpParserFinally-75))|(1<<(PhpParserFloatCast-75))|(1<<(PhpParserFor-75))|(1<<(PhpParserForeach-75))|(1<<(PhpParserFunction-75))|(1<<(PhpParserGlobal-75))|(1<<(PhpParserGoto-75))|(1<<(PhpParserIf-75))|(1<<(PhpParserImplements-75))|(1<<(PhpParserImport-75))|(1<<(PhpParserInclude-75))|(1<<(PhpParserIncludeOnce-75))|(1<<(PhpParserInstanceOf-75))|(1<<(PhpParserInsteadOf-75))|(1<<(PhpParserInt8Cast-75))|(1<<(PhpParserInt16Cast-75))|(1<<(PhpParserInt64Type-75))|(1<<(PhpParserIntType-75))|(1<<(PhpParserInterface-75))|(1<<(PhpParserIsSet-75))|(1<<(PhpParserList-75))|(1<<(PhpParserLogicalAnd-75))|(1<<(PhpParserLogicalOr-75))|(1<<(PhpParserLogicalXor-75))|(1<<(PhpParserNamespace-75))|(1<<(PhpParserNew-75))|(1<<(PhpParserNull-75))|(1<<(PhpParserObjectType-75))|(1<<(PhpParserParent_-75))|(1<<(PhpParserPartial-75))|(1<<(PhpParserPrint-75)))) != 0) || (((_la-107)&-(0x1f+1)) == 0 && ((1<<uint((_la-107)))&((1<<(PhpParserPrivate-107))|(1<<(PhpParserProtected-107))|(1<<(PhpParserPublic-107))|(1<<(PhpParserRequire-107))|(1<<(PhpParserRequireOnce-107))|(1<<(PhpParserResource-107))|(1<<(PhpParserReturn-107))|(1<<(PhpParserStatic-107))|(1<<(PhpParserStringType-107))|(1<<(PhpParserSwitch-107))|(1<<(PhpParserThrow-107))|(1<<(PhpParserTrait-107))|(1<<(PhpParserTry-107))|(1<<(PhpParserTypeof-107))|(1<<(PhpParserUintCast-107))|(1<<(PhpParserUnicodeCast-107))|(1<<(PhpParserUnset-107))|(1<<(PhpParserUse-107))|(1<<(PhpParserVar-107))|(1<<(PhpParserWhile-107))|(1<<(PhpParserYield-107))|(1<<(PhpParserGet-107))|(1<<(PhpParserSet-107))|(1<<(PhpParserCall-107))|(1<<(PhpParserCallStatic-107))|(1<<(PhpParserConstructor-107))|(1<<(PhpParserDestruct-107))|(1<<(PhpParserWakeup-107))|(1<<(PhpParserSleep-107))|(1<<(PhpParserAutoload-107))|(1<<(PhpParserIsSet__-107))|(1<<(PhpParserUnset__-107)))) != 0) || (((_la-139)&-(0x1f+1)) == 0 && ((1<<uint((_la-139)))&((1<<(PhpParserToString__-139))|(1<<(PhpParserInvoke-139))|(1<<(PhpParserSetState-139))|(1<<(PhpParserClone__-139))|(1<<(PhpParserDebugInfo-139))|(1<<(PhpParserNamespace__-139))|(1<<(PhpParserClass__-139))|(1<<(PhpParserTraic__-139))|(1<<(PhpParserFunction__-139))|(1<<(PhpParserMethod__-139))|(1<<(PhpParserLine__-139))|(1<<(PhpParserFile__-139))|(1<<(PhpParserDir__-139))|(1<<(PhpParserInc-139))|(1<<(PhpParserDec-139)))) != 0) || (((_la-182)&-(0x1f+1)) == 0 && ((1<<uint((_la-182)))&((1<<(PhpParserNamespaceSeparator-182))|(1<<(PhpParserBang-182))|(1<<(PhpParserPlus-182))|(1<<(PhpParserMinus-182))|(1<<(PhpParserTilde-182))|(1<<(PhpParserSuppressWarnings-182))|(1<<(PhpParserDollar-182))|(1<<(PhpParserOpenRoundBracket-182))|(1<<(PhpParserOpenSquareBracket-182))|(1<<(PhpParserVarName-182))|(1<<(PhpParserLabel-182)))) != 0) || (((_la-214)&-(0x1f+1)) == 0 && ((1<<uint((_la-214)))&((1<<(PhpParserOctal-214))|(1<<(PhpParserDecimal-214))|(1<<(PhpParserReal-214))|(1<<(PhpParserHex-214))|(1<<(PhpParserBinary-214))|(1<<(PhpParserBackQuoteString-214))|(1<<(PhpParserSingleQuoteString-214))|(1<<(PhpParserDoubleQuote-214))|(1<<(PhpParserStartNowDoc-214))|(1<<(PhpParserStartHereDoc-214)))) != 0) {
		{
			p.SetState(756)
			p.expression(0)
		}

	}
	{
		p.SetState(759)
		p.Match(PhpParserSemiColon)
	}

	return localctx
}

// IExpressionStatementContext is an interface to support dynamic dispatch.
type IExpressionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpressionStatementContext differentiates from other interfaces.
	IsExpressionStatementContext()
}

type ExpressionStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionStatementContext() *ExpressionStatementContext {
	var p = new(ExpressionStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_expressionStatement
	return p
}

func (*ExpressionStatementContext) IsExpressionStatementContext() {}

func NewExpressionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionStatementContext {
	var p = new(ExpressionStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_expressionStatement

	return p
}

func (s *ExpressionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionStatementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterExpressionStatement(s)
	}
}

func (s *ExpressionStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitExpressionStatement(s)
	}
}

func (p *PhpParser) ExpressionStatement() (localctx IExpressionStatementContext) {
	localctx = NewExpressionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, PhpParserRULE_expressionStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(761)
		p.expression(0)
	}
	{
		p.SetState(762)
		p.Match(PhpParserSemiColon)
	}

	return localctx
}

// IUnsetStatementContext is an interface to support dynamic dispatch.
type IUnsetStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnsetStatementContext differentiates from other interfaces.
	IsUnsetStatementContext()
}

type UnsetStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnsetStatementContext() *UnsetStatementContext {
	var p = new(UnsetStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_unsetStatement
	return p
}

func (*UnsetStatementContext) IsUnsetStatementContext() {}

func NewUnsetStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnsetStatementContext {
	var p = new(UnsetStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_unsetStatement

	return p
}

func (s *UnsetStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UnsetStatementContext) Unset() antlr.TerminalNode {
	return s.GetToken(PhpParserUnset, 0)
}

func (s *UnsetStatementContext) ChainList() IChainListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IChainListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IChainListContext)
}

func (s *UnsetStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnsetStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnsetStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterUnsetStatement(s)
	}
}

func (s *UnsetStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitUnsetStatement(s)
	}
}

func (p *PhpParser) UnsetStatement() (localctx IUnsetStatementContext) {
	localctx = NewUnsetStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, PhpParserRULE_unsetStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(764)
		p.Match(PhpParserUnset)
	}
	{
		p.SetState(765)
		p.Match(PhpParserOpenRoundBracket)
	}
	{
		p.SetState(766)
		p.ChainList()
	}
	{
		p.SetState(767)
		p.Match(PhpParserCloseRoundBracket)
	}
	{
		p.SetState(768)
		p.Match(PhpParserSemiColon)
	}

	return localctx
}

// IForeachStatementContext is an interface to support dynamic dispatch.
type IForeachStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsForeachStatementContext differentiates from other interfaces.
	IsForeachStatementContext()
}

type ForeachStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForeachStatementContext() *ForeachStatementContext {
	var p = new(ForeachStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_foreachStatement
	return p
}

func (*ForeachStatementContext) IsForeachStatementContext() {}

func NewForeachStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForeachStatementContext {
	var p = new(ForeachStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_foreachStatement

	return p
}

func (s *ForeachStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ForeachStatementContext) Foreach() antlr.TerminalNode {
	return s.GetToken(PhpParserForeach, 0)
}

func (s *ForeachStatementContext) AllChain() []IChainContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IChainContext)(nil)).Elem())
	var tst = make([]IChainContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IChainContext)
		}
	}

	return tst
}

func (s *ForeachStatementContext) Chain(i int) IChainContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IChainContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IChainContext)
}

func (s *ForeachStatementContext) As() antlr.TerminalNode {
	return s.GetToken(PhpParserAs, 0)
}

func (s *ForeachStatementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ForeachStatementContext) List() antlr.TerminalNode {
	return s.GetToken(PhpParserList, 0)
}

func (s *ForeachStatementContext) AssignmentList() IAssignmentListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignmentListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignmentListContext)
}

func (s *ForeachStatementContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *ForeachStatementContext) InnerStatementList() IInnerStatementListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInnerStatementListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInnerStatementListContext)
}

func (s *ForeachStatementContext) EndForeach() antlr.TerminalNode {
	return s.GetToken(PhpParserEndForeach, 0)
}

func (s *ForeachStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForeachStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForeachStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterForeachStatement(s)
	}
}

func (s *ForeachStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitForeachStatement(s)
	}
}

func (p *PhpParser) ForeachStatement() (localctx IForeachStatementContext) {
	localctx = NewForeachStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, PhpParserRULE_foreachStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(770)
		p.Match(PhpParserForeach)
	}
	p.SetState(809)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 71, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(771)
			p.Match(PhpParserOpenRoundBracket)
		}
		{
			p.SetState(772)
			p.Chain()
		}
		{
			p.SetState(773)
			p.Match(PhpParserAs)
		}
		p.SetState(775)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PhpParserAmpersand {
			{
				p.SetState(774)
				p.Match(PhpParserAmpersand)
			}

		}
		{
			p.SetState(777)
			p.Chain()
		}
		p.SetState(783)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PhpParserDoubleArrow {
			{
				p.SetState(778)
				p.Match(PhpParserDoubleArrow)
			}
			p.SetState(780)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == PhpParserAmpersand {
				{
					p.SetState(779)
					p.Match(PhpParserAmpersand)
				}

			}
			{
				p.SetState(782)
				p.Chain()
			}

		}
		{
			p.SetState(785)
			p.Match(PhpParserCloseRoundBracket)
		}

	case 2:
		{
			p.SetState(787)
			p.Match(PhpParserOpenRoundBracket)
		}
		{
			p.SetState(788)
			p.expression(0)
		}
		{
			p.SetState(789)
			p.Match(PhpParserAs)
		}
		{
			p.SetState(790)
			p.Chain()
		}
		p.SetState(796)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PhpParserDoubleArrow {
			{
				p.SetState(791)
				p.Match(PhpParserDoubleArrow)
			}
			p.SetState(793)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == PhpParserAmpersand {
				{
					p.SetState(792)
					p.Match(PhpParserAmpersand)
				}

			}
			{
				p.SetState(795)
				p.Chain()
			}

		}
		{
			p.SetState(798)
			p.Match(PhpParserCloseRoundBracket)
		}

	case 3:
		{
			p.SetState(800)
			p.Match(PhpParserOpenRoundBracket)
		}
		{
			p.SetState(801)
			p.Chain()
		}
		{
			p.SetState(802)
			p.Match(PhpParserAs)
		}
		{
			p.SetState(803)
			p.Match(PhpParserList)
		}
		{
			p.SetState(804)
			p.Match(PhpParserOpenRoundBracket)
		}
		{
			p.SetState(805)
			p.AssignmentList()
		}
		{
			p.SetState(806)
			p.Match(PhpParserCloseRoundBracket)
		}
		{
			p.SetState(807)
			p.Match(PhpParserCloseRoundBracket)
		}

	}
	p.SetState(817)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PhpParserHtmlText, PhpParserXmlStart, PhpParserHtmlScriptOpen, PhpParserHtmlStyleOpen, PhpParserHtmlDtd, PhpParserHtmlOpen, PhpParserHtmlClose, PhpParserHtmlSlashClose, PhpParserHtmlSlash, PhpParserHtmlEquals, PhpParserHtmlStartQuoteString, PhpParserHtmlStartDoubleQuoteString, PhpParserHtmlHex, PhpParserHtmlDecimal, PhpParserHtmlName, PhpParserHtmlEndQuoteString, PhpParserHtmlQuoteString, PhpParserHtmlEndDoubleQuoteString, PhpParserHtmlDoubleQuoteString, PhpParserScriptText, PhpParserScriptClose, PhpParserStyleBody, PhpParserAbstract, PhpParserArray, PhpParserAs, PhpParserBinaryCast, PhpParserBoolType, PhpParserBooleanConstant, PhpParserBreak, PhpParserCallable, PhpParserCase, PhpParserCatch, PhpParserClass, PhpParserClone, PhpParserConst, PhpParserContinue, PhpParserDeclare, PhpParserDefault, PhpParserDo, PhpParserDoubleCast, PhpParserDoubleType, PhpParserEcho, PhpParserElse, PhpParserElseIf, PhpParserEmpty, PhpParserEndDeclare, PhpParserEndFor, PhpParserEndForeach, PhpParserEndIf, PhpParserEndSwitch, PhpParserEndWhile, PhpParserEval, PhpParserExit, PhpParserExtends, PhpParserFinal, PhpParserFinally, PhpParserFloatCast, PhpParserFor, PhpParserForeach, PhpParserFunction, PhpParserGlobal, PhpParserGoto, PhpParserIf, PhpParserImplements, PhpParserImport, PhpParserInclude, PhpParserIncludeOnce, PhpParserInstanceOf, PhpParserInsteadOf, PhpParserInt8Cast, PhpParserInt16Cast, PhpParserInt64Type, PhpParserIntType, PhpParserInterface, PhpParserIsSet, PhpParserList, PhpParserLogicalAnd, PhpParserLogicalOr, PhpParserLogicalXor, PhpParserNamespace, PhpParserNew, PhpParserNull, PhpParserObjectType, PhpParserParent_, PhpParserPartial, PhpParserPrint, PhpParserPrivate, PhpParserProtected, PhpParserPublic, PhpParserRequire, PhpParserRequireOnce, PhpParserResource, PhpParserReturn, PhpParserStatic, PhpParserStringType, PhpParserSwitch, PhpParserThrow, PhpParserTrait, PhpParserTry, PhpParserTypeof, PhpParserUintCast, PhpParserUnicodeCast, PhpParserUnset, PhpParserUse, PhpParserVar, PhpParserWhile, PhpParserYield, PhpParserGet, PhpParserSet, PhpParserCall, PhpParserCallStatic, PhpParserConstructor, PhpParserDestruct, PhpParserWakeup, PhpParserSleep, PhpParserAutoload, PhpParserIsSet__, PhpParserUnset__, PhpParserToString__, PhpParserInvoke, PhpParserSetState, PhpParserClone__, PhpParserDebugInfo, PhpParserNamespace__, PhpParserClass__, PhpParserTraic__, PhpParserFunction__, PhpParserMethod__, PhpParserLine__, PhpParserFile__, PhpParserDir__, PhpParserInc, PhpParserDec, PhpParserNamespaceSeparator, PhpParserBang, PhpParserPlus, PhpParserMinus, PhpParserTilde, PhpParserSuppressWarnings, PhpParserDollar, PhpParserOpenRoundBracket, PhpParserOpenSquareBracket, PhpParserOpenCurlyBracket, PhpParserSemiColon, PhpParserVarName, PhpParserLabel, PhpParserOctal, PhpParserDecimal, PhpParserReal, PhpParserHex, PhpParserBinary, PhpParserBackQuoteString, PhpParserSingleQuoteString, PhpParserDoubleQuote, PhpParserStartNowDoc, PhpParserStartHereDoc:
		{
			p.SetState(811)
			p.Statement()
		}

	case PhpParserColon:
		{
			p.SetState(812)
			p.Match(PhpParserColon)
		}
		{
			p.SetState(813)
			p.InnerStatementList()
		}
		{
			p.SetState(814)
			p.Match(PhpParserEndForeach)
		}
		{
			p.SetState(815)
			p.Match(PhpParserSemiColon)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITryCatchFinallyContext is an interface to support dynamic dispatch.
type ITryCatchFinallyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTryCatchFinallyContext differentiates from other interfaces.
	IsTryCatchFinallyContext()
}

type TryCatchFinallyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTryCatchFinallyContext() *TryCatchFinallyContext {
	var p = new(TryCatchFinallyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_tryCatchFinally
	return p
}

func (*TryCatchFinallyContext) IsTryCatchFinallyContext() {}

func NewTryCatchFinallyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TryCatchFinallyContext {
	var p = new(TryCatchFinallyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_tryCatchFinally

	return p
}

func (s *TryCatchFinallyContext) GetParser() antlr.Parser { return s.parser }

func (s *TryCatchFinallyContext) Try() antlr.TerminalNode {
	return s.GetToken(PhpParserTry, 0)
}

func (s *TryCatchFinallyContext) BlockStatement() IBlockStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockStatementContext)
}

func (s *TryCatchFinallyContext) FinallyStatement() IFinallyStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFinallyStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFinallyStatementContext)
}

func (s *TryCatchFinallyContext) AllCatchClause() []ICatchClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICatchClauseContext)(nil)).Elem())
	var tst = make([]ICatchClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICatchClauseContext)
		}
	}

	return tst
}

func (s *TryCatchFinallyContext) CatchClause(i int) ICatchClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICatchClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICatchClauseContext)
}

func (s *TryCatchFinallyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TryCatchFinallyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TryCatchFinallyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterTryCatchFinally(s)
	}
}

func (s *TryCatchFinallyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitTryCatchFinally(s)
	}
}

func (p *PhpParser) TryCatchFinally() (localctx ITryCatchFinallyContext) {
	localctx = NewTryCatchFinallyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, PhpParserRULE_tryCatchFinally)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(819)
		p.Match(PhpParserTry)
	}
	{
		p.SetState(820)
		p.BlockStatement()
	}
	p.SetState(836)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 76, p.GetParserRuleContext()) {
	case 1:
		p.SetState(822)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(821)
					p.CatchClause()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(824)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 73, p.GetParserRuleContext())
		}
		p.SetState(827)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 74, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(826)
				p.FinallyStatement()
			}

		}

	case 2:
		p.SetState(832)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == PhpParserCatch {
			{
				p.SetState(829)
				p.CatchClause()
			}

			p.SetState(834)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(835)
			p.FinallyStatement()
		}

	}

	return localctx
}

// ICatchClauseContext is an interface to support dynamic dispatch.
type ICatchClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCatchClauseContext differentiates from other interfaces.
	IsCatchClauseContext()
}

type CatchClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCatchClauseContext() *CatchClauseContext {
	var p = new(CatchClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_catchClause
	return p
}

func (*CatchClauseContext) IsCatchClauseContext() {}

func NewCatchClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CatchClauseContext {
	var p = new(CatchClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_catchClause

	return p
}

func (s *CatchClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CatchClauseContext) Catch() antlr.TerminalNode {
	return s.GetToken(PhpParserCatch, 0)
}

func (s *CatchClauseContext) QualifiedStaticTypeRef() IQualifiedStaticTypeRefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedStaticTypeRefContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedStaticTypeRefContext)
}

func (s *CatchClauseContext) VarName() antlr.TerminalNode {
	return s.GetToken(PhpParserVarName, 0)
}

func (s *CatchClauseContext) BlockStatement() IBlockStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockStatementContext)
}

func (s *CatchClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CatchClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CatchClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterCatchClause(s)
	}
}

func (s *CatchClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitCatchClause(s)
	}
}

func (p *PhpParser) CatchClause() (localctx ICatchClauseContext) {
	localctx = NewCatchClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, PhpParserRULE_catchClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(838)
		p.Match(PhpParserCatch)
	}
	{
		p.SetState(839)
		p.Match(PhpParserOpenRoundBracket)
	}
	{
		p.SetState(840)
		p.QualifiedStaticTypeRef()
	}
	{
		p.SetState(841)
		p.Match(PhpParserVarName)
	}
	{
		p.SetState(842)
		p.Match(PhpParserCloseRoundBracket)
	}
	{
		p.SetState(843)
		p.BlockStatement()
	}

	return localctx
}

// IFinallyStatementContext is an interface to support dynamic dispatch.
type IFinallyStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFinallyStatementContext differentiates from other interfaces.
	IsFinallyStatementContext()
}

type FinallyStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFinallyStatementContext() *FinallyStatementContext {
	var p = new(FinallyStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_finallyStatement
	return p
}

func (*FinallyStatementContext) IsFinallyStatementContext() {}

func NewFinallyStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FinallyStatementContext {
	var p = new(FinallyStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_finallyStatement

	return p
}

func (s *FinallyStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *FinallyStatementContext) Finally() antlr.TerminalNode {
	return s.GetToken(PhpParserFinally, 0)
}

func (s *FinallyStatementContext) BlockStatement() IBlockStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockStatementContext)
}

func (s *FinallyStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FinallyStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FinallyStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterFinallyStatement(s)
	}
}

func (s *FinallyStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitFinallyStatement(s)
	}
}

func (p *PhpParser) FinallyStatement() (localctx IFinallyStatementContext) {
	localctx = NewFinallyStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, PhpParserRULE_finallyStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(845)
		p.Match(PhpParserFinally)
	}
	{
		p.SetState(846)
		p.BlockStatement()
	}

	return localctx
}

// IThrowStatementContext is an interface to support dynamic dispatch.
type IThrowStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsThrowStatementContext differentiates from other interfaces.
	IsThrowStatementContext()
}

type ThrowStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyThrowStatementContext() *ThrowStatementContext {
	var p = new(ThrowStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_throwStatement
	return p
}

func (*ThrowStatementContext) IsThrowStatementContext() {}

func NewThrowStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ThrowStatementContext {
	var p = new(ThrowStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_throwStatement

	return p
}

func (s *ThrowStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ThrowStatementContext) Throw() antlr.TerminalNode {
	return s.GetToken(PhpParserThrow, 0)
}

func (s *ThrowStatementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ThrowStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ThrowStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ThrowStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterThrowStatement(s)
	}
}

func (s *ThrowStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitThrowStatement(s)
	}
}

func (p *PhpParser) ThrowStatement() (localctx IThrowStatementContext) {
	localctx = NewThrowStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, PhpParserRULE_throwStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(848)
		p.Match(PhpParserThrow)
	}
	{
		p.SetState(849)
		p.expression(0)
	}
	{
		p.SetState(850)
		p.Match(PhpParserSemiColon)
	}

	return localctx
}

// IGotoStatementContext is an interface to support dynamic dispatch.
type IGotoStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGotoStatementContext differentiates from other interfaces.
	IsGotoStatementContext()
}

type GotoStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGotoStatementContext() *GotoStatementContext {
	var p = new(GotoStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_gotoStatement
	return p
}

func (*GotoStatementContext) IsGotoStatementContext() {}

func NewGotoStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GotoStatementContext {
	var p = new(GotoStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_gotoStatement

	return p
}

func (s *GotoStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *GotoStatementContext) Goto() antlr.TerminalNode {
	return s.GetToken(PhpParserGoto, 0)
}

func (s *GotoStatementContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *GotoStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GotoStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GotoStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterGotoStatement(s)
	}
}

func (s *GotoStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitGotoStatement(s)
	}
}

func (p *PhpParser) GotoStatement() (localctx IGotoStatementContext) {
	localctx = NewGotoStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, PhpParserRULE_gotoStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(852)
		p.Match(PhpParserGoto)
	}
	{
		p.SetState(853)
		p.Identifier()
	}
	{
		p.SetState(854)
		p.Match(PhpParserSemiColon)
	}

	return localctx
}

// IDeclareStatementContext is an interface to support dynamic dispatch.
type IDeclareStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDeclareStatementContext differentiates from other interfaces.
	IsDeclareStatementContext()
}

type DeclareStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclareStatementContext() *DeclareStatementContext {
	var p = new(DeclareStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_declareStatement
	return p
}

func (*DeclareStatementContext) IsDeclareStatementContext() {}

func NewDeclareStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclareStatementContext {
	var p = new(DeclareStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_declareStatement

	return p
}

func (s *DeclareStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclareStatementContext) Declare() antlr.TerminalNode {
	return s.GetToken(PhpParserDeclare, 0)
}

func (s *DeclareStatementContext) DeclareList() IDeclareListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclareListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclareListContext)
}

func (s *DeclareStatementContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *DeclareStatementContext) InnerStatementList() IInnerStatementListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInnerStatementListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInnerStatementListContext)
}

func (s *DeclareStatementContext) EndDeclare() antlr.TerminalNode {
	return s.GetToken(PhpParserEndDeclare, 0)
}

func (s *DeclareStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclareStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeclareStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterDeclareStatement(s)
	}
}

func (s *DeclareStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitDeclareStatement(s)
	}
}

func (p *PhpParser) DeclareStatement() (localctx IDeclareStatementContext) {
	localctx = NewDeclareStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, PhpParserRULE_declareStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(856)
		p.Match(PhpParserDeclare)
	}
	{
		p.SetState(857)
		p.Match(PhpParserOpenRoundBracket)
	}
	{
		p.SetState(858)
		p.DeclareList()
	}
	{
		p.SetState(859)
		p.Match(PhpParserCloseRoundBracket)
	}
	p.SetState(866)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PhpParserHtmlText, PhpParserXmlStart, PhpParserHtmlScriptOpen, PhpParserHtmlStyleOpen, PhpParserHtmlDtd, PhpParserHtmlOpen, PhpParserHtmlClose, PhpParserHtmlSlashClose, PhpParserHtmlSlash, PhpParserHtmlEquals, PhpParserHtmlStartQuoteString, PhpParserHtmlStartDoubleQuoteString, PhpParserHtmlHex, PhpParserHtmlDecimal, PhpParserHtmlName, PhpParserHtmlEndQuoteString, PhpParserHtmlQuoteString, PhpParserHtmlEndDoubleQuoteString, PhpParserHtmlDoubleQuoteString, PhpParserScriptText, PhpParserScriptClose, PhpParserStyleBody, PhpParserAbstract, PhpParserArray, PhpParserAs, PhpParserBinaryCast, PhpParserBoolType, PhpParserBooleanConstant, PhpParserBreak, PhpParserCallable, PhpParserCase, PhpParserCatch, PhpParserClass, PhpParserClone, PhpParserConst, PhpParserContinue, PhpParserDeclare, PhpParserDefault, PhpParserDo, PhpParserDoubleCast, PhpParserDoubleType, PhpParserEcho, PhpParserElse, PhpParserElseIf, PhpParserEmpty, PhpParserEndDeclare, PhpParserEndFor, PhpParserEndForeach, PhpParserEndIf, PhpParserEndSwitch, PhpParserEndWhile, PhpParserEval, PhpParserExit, PhpParserExtends, PhpParserFinal, PhpParserFinally, PhpParserFloatCast, PhpParserFor, PhpParserForeach, PhpParserFunction, PhpParserGlobal, PhpParserGoto, PhpParserIf, PhpParserImplements, PhpParserImport, PhpParserInclude, PhpParserIncludeOnce, PhpParserInstanceOf, PhpParserInsteadOf, PhpParserInt8Cast, PhpParserInt16Cast, PhpParserInt64Type, PhpParserIntType, PhpParserInterface, PhpParserIsSet, PhpParserList, PhpParserLogicalAnd, PhpParserLogicalOr, PhpParserLogicalXor, PhpParserNamespace, PhpParserNew, PhpParserNull, PhpParserObjectType, PhpParserParent_, PhpParserPartial, PhpParserPrint, PhpParserPrivate, PhpParserProtected, PhpParserPublic, PhpParserRequire, PhpParserRequireOnce, PhpParserResource, PhpParserReturn, PhpParserStatic, PhpParserStringType, PhpParserSwitch, PhpParserThrow, PhpParserTrait, PhpParserTry, PhpParserTypeof, PhpParserUintCast, PhpParserUnicodeCast, PhpParserUnset, PhpParserUse, PhpParserVar, PhpParserWhile, PhpParserYield, PhpParserGet, PhpParserSet, PhpParserCall, PhpParserCallStatic, PhpParserConstructor, PhpParserDestruct, PhpParserWakeup, PhpParserSleep, PhpParserAutoload, PhpParserIsSet__, PhpParserUnset__, PhpParserToString__, PhpParserInvoke, PhpParserSetState, PhpParserClone__, PhpParserDebugInfo, PhpParserNamespace__, PhpParserClass__, PhpParserTraic__, PhpParserFunction__, PhpParserMethod__, PhpParserLine__, PhpParserFile__, PhpParserDir__, PhpParserInc, PhpParserDec, PhpParserNamespaceSeparator, PhpParserBang, PhpParserPlus, PhpParserMinus, PhpParserTilde, PhpParserSuppressWarnings, PhpParserDollar, PhpParserOpenRoundBracket, PhpParserOpenSquareBracket, PhpParserOpenCurlyBracket, PhpParserSemiColon, PhpParserVarName, PhpParserLabel, PhpParserOctal, PhpParserDecimal, PhpParserReal, PhpParserHex, PhpParserBinary, PhpParserBackQuoteString, PhpParserSingleQuoteString, PhpParserDoubleQuote, PhpParserStartNowDoc, PhpParserStartHereDoc:
		{
			p.SetState(860)
			p.Statement()
		}

	case PhpParserColon:
		{
			p.SetState(861)
			p.Match(PhpParserColon)
		}
		{
			p.SetState(862)
			p.InnerStatementList()
		}
		{
			p.SetState(863)
			p.Match(PhpParserEndDeclare)
		}
		{
			p.SetState(864)
			p.Match(PhpParserSemiColon)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IInlineHtmlStatementContext is an interface to support dynamic dispatch.
type IInlineHtmlStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInlineHtmlStatementContext differentiates from other interfaces.
	IsInlineHtmlStatementContext()
}

type InlineHtmlStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInlineHtmlStatementContext() *InlineHtmlStatementContext {
	var p = new(InlineHtmlStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_inlineHtmlStatement
	return p
}

func (*InlineHtmlStatementContext) IsInlineHtmlStatementContext() {}

func NewInlineHtmlStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InlineHtmlStatementContext {
	var p = new(InlineHtmlStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_inlineHtmlStatement

	return p
}

func (s *InlineHtmlStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *InlineHtmlStatementContext) AllInlineHtml() []IInlineHtmlContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInlineHtmlContext)(nil)).Elem())
	var tst = make([]IInlineHtmlContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInlineHtmlContext)
		}
	}

	return tst
}

func (s *InlineHtmlStatementContext) InlineHtml(i int) IInlineHtmlContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInlineHtmlContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInlineHtmlContext)
}

func (s *InlineHtmlStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InlineHtmlStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InlineHtmlStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterInlineHtmlStatement(s)
	}
}

func (s *InlineHtmlStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitInlineHtmlStatement(s)
	}
}

func (p *PhpParser) InlineHtmlStatement() (localctx IInlineHtmlStatementContext) {
	localctx = NewInlineHtmlStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, PhpParserRULE_inlineHtmlStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(869)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(868)
				p.InlineHtml()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(871)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 78, p.GetParserRuleContext())
	}

	return localctx
}

// IInlineHtmlContext is an interface to support dynamic dispatch.
type IInlineHtmlContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInlineHtmlContext differentiates from other interfaces.
	IsInlineHtmlContext()
}

type InlineHtmlContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInlineHtmlContext() *InlineHtmlContext {
	var p = new(InlineHtmlContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_inlineHtml
	return p
}

func (*InlineHtmlContext) IsInlineHtmlContext() {}

func NewInlineHtmlContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InlineHtmlContext {
	var p = new(InlineHtmlContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_inlineHtml

	return p
}

func (s *InlineHtmlContext) GetParser() antlr.Parser { return s.parser }

func (s *InlineHtmlContext) HtmlElements() IHtmlElementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHtmlElementsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHtmlElementsContext)
}

func (s *InlineHtmlContext) ScriptTextPart() IScriptTextPartContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScriptTextPartContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IScriptTextPartContext)
}

func (s *InlineHtmlContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InlineHtmlContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InlineHtmlContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterInlineHtml(s)
	}
}

func (s *InlineHtmlContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitInlineHtml(s)
	}
}

func (p *PhpParser) InlineHtml() (localctx IInlineHtmlContext) {
	localctx = NewInlineHtmlContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, PhpParserRULE_inlineHtml)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(875)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PhpParserHtmlText, PhpParserXmlStart, PhpParserHtmlScriptOpen, PhpParserHtmlStyleOpen, PhpParserHtmlDtd, PhpParserHtmlOpen, PhpParserHtmlClose, PhpParserHtmlSlashClose, PhpParserHtmlSlash, PhpParserHtmlEquals, PhpParserHtmlStartQuoteString, PhpParserHtmlStartDoubleQuoteString, PhpParserHtmlHex, PhpParserHtmlDecimal, PhpParserHtmlName, PhpParserHtmlEndQuoteString, PhpParserHtmlQuoteString, PhpParserHtmlEndDoubleQuoteString, PhpParserHtmlDoubleQuoteString, PhpParserScriptClose, PhpParserStyleBody:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(873)
			p.HtmlElements()
		}

	case PhpParserScriptText:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(874)
			p.ScriptTextPart()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IDeclareListContext is an interface to support dynamic dispatch.
type IDeclareListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDeclareListContext differentiates from other interfaces.
	IsDeclareListContext()
}

type DeclareListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclareListContext() *DeclareListContext {
	var p = new(DeclareListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_declareList
	return p
}

func (*DeclareListContext) IsDeclareListContext() {}

func NewDeclareListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclareListContext {
	var p = new(DeclareListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_declareList

	return p
}

func (s *DeclareListContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclareListContext) AllIdentifierInititalizer() []IIdentifierInititalizerContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierInititalizerContext)(nil)).Elem())
	var tst = make([]IIdentifierInititalizerContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierInititalizerContext)
		}
	}

	return tst
}

func (s *DeclareListContext) IdentifierInititalizer(i int) IIdentifierInititalizerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierInititalizerContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierInititalizerContext)
}

func (s *DeclareListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclareListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeclareListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterDeclareList(s)
	}
}

func (s *DeclareListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitDeclareList(s)
	}
}

func (p *PhpParser) DeclareList() (localctx IDeclareListContext) {
	localctx = NewDeclareListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, PhpParserRULE_declareList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(877)
		p.IdentifierInititalizer()
	}
	p.SetState(882)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PhpParserComma {
		{
			p.SetState(878)
			p.Match(PhpParserComma)
		}
		{
			p.SetState(879)
			p.IdentifierInititalizer()
		}

		p.SetState(884)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IFormalParameterListContext is an interface to support dynamic dispatch.
type IFormalParameterListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFormalParameterListContext differentiates from other interfaces.
	IsFormalParameterListContext()
}

type FormalParameterListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFormalParameterListContext() *FormalParameterListContext {
	var p = new(FormalParameterListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_formalParameterList
	return p
}

func (*FormalParameterListContext) IsFormalParameterListContext() {}

func NewFormalParameterListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FormalParameterListContext {
	var p = new(FormalParameterListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_formalParameterList

	return p
}

func (s *FormalParameterListContext) GetParser() antlr.Parser { return s.parser }

func (s *FormalParameterListContext) AllFormalParameter() []IFormalParameterContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFormalParameterContext)(nil)).Elem())
	var tst = make([]IFormalParameterContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFormalParameterContext)
		}
	}

	return tst
}

func (s *FormalParameterListContext) FormalParameter(i int) IFormalParameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFormalParameterContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFormalParameterContext)
}

func (s *FormalParameterListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FormalParameterListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FormalParameterListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterFormalParameterList(s)
	}
}

func (s *FormalParameterListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitFormalParameterList(s)
	}
}

func (p *PhpParser) FormalParameterList() (localctx IFormalParameterListContext) {
	localctx = NewFormalParameterListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, PhpParserRULE_formalParameterList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(886)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la-43)&-(0x1f+1)) == 0 && ((1<<uint((_la-43)))&((1<<(PhpParserAbstract-43))|(1<<(PhpParserArray-43))|(1<<(PhpParserAs-43))|(1<<(PhpParserBinaryCast-43))|(1<<(PhpParserBoolType-43))|(1<<(PhpParserBooleanConstant-43))|(1<<(PhpParserBreak-43))|(1<<(PhpParserCallable-43))|(1<<(PhpParserCase-43))|(1<<(PhpParserCatch-43))|(1<<(PhpParserClass-43))|(1<<(PhpParserClone-43))|(1<<(PhpParserConst-43))|(1<<(PhpParserContinue-43))|(1<<(PhpParserDeclare-43))|(1<<(PhpParserDefault-43))|(1<<(PhpParserDo-43))|(1<<(PhpParserDoubleCast-43))|(1<<(PhpParserDoubleType-43))|(1<<(PhpParserEcho-43))|(1<<(PhpParserElse-43))|(1<<(PhpParserElseIf-43))|(1<<(PhpParserEmpty-43))|(1<<(PhpParserEndDeclare-43))|(1<<(PhpParserEndFor-43))|(1<<(PhpParserEndForeach-43))|(1<<(PhpParserEndIf-43))|(1<<(PhpParserEndSwitch-43))|(1<<(PhpParserEndWhile-43))|(1<<(PhpParserEval-43))|(1<<(PhpParserExit-43))|(1<<(PhpParserExtends-43)))) != 0) || (((_la-75)&-(0x1f+1)) == 0 && ((1<<uint((_la-75)))&((1<<(PhpParserFinal-75))|(1<<(PhpParserFinally-75))|(1<<(PhpParserFloatCast-75))|(1<<(PhpParserFor-75))|(1<<(PhpParserForeach-75))|(1<<(PhpParserFunction-75))|(1<<(PhpParserGlobal-75))|(1<<(PhpParserGoto-75))|(1<<(PhpParserIf-75))|(1<<(PhpParserImplements-75))|(1<<(PhpParserImport-75))|(1<<(PhpParserInclude-75))|(1<<(PhpParserIncludeOnce-75))|(1<<(PhpParserInstanceOf-75))|(1<<(PhpParserInsteadOf-75))|(1<<(PhpParserInt8Cast-75))|(1<<(PhpParserInt16Cast-75))|(1<<(PhpParserInt64Type-75))|(1<<(PhpParserIntType-75))|(1<<(PhpParserInterface-75))|(1<<(PhpParserIsSet-75))|(1<<(PhpParserList-75))|(1<<(PhpParserLogicalAnd-75))|(1<<(PhpParserLogicalOr-75))|(1<<(PhpParserLogicalXor-75))|(1<<(PhpParserNamespace-75))|(1<<(PhpParserNew-75))|(1<<(PhpParserNull-75))|(1<<(PhpParserObjectType-75))|(1<<(PhpParserParent_-75))|(1<<(PhpParserPartial-75))|(1<<(PhpParserPrint-75)))) != 0) || (((_la-107)&-(0x1f+1)) == 0 && ((1<<uint((_la-107)))&((1<<(PhpParserPrivate-107))|(1<<(PhpParserProtected-107))|(1<<(PhpParserPublic-107))|(1<<(PhpParserRequire-107))|(1<<(PhpParserRequireOnce-107))|(1<<(PhpParserResource-107))|(1<<(PhpParserReturn-107))|(1<<(PhpParserStatic-107))|(1<<(PhpParserStringType-107))|(1<<(PhpParserSwitch-107))|(1<<(PhpParserThrow-107))|(1<<(PhpParserTrait-107))|(1<<(PhpParserTry-107))|(1<<(PhpParserTypeof-107))|(1<<(PhpParserUintCast-107))|(1<<(PhpParserUnicodeCast-107))|(1<<(PhpParserUnset-107))|(1<<(PhpParserUse-107))|(1<<(PhpParserVar-107))|(1<<(PhpParserWhile-107))|(1<<(PhpParserYield-107))|(1<<(PhpParserGet-107))|(1<<(PhpParserSet-107))|(1<<(PhpParserCall-107))|(1<<(PhpParserCallStatic-107))|(1<<(PhpParserConstructor-107))|(1<<(PhpParserDestruct-107))|(1<<(PhpParserWakeup-107))|(1<<(PhpParserSleep-107))|(1<<(PhpParserAutoload-107))|(1<<(PhpParserIsSet__-107))|(1<<(PhpParserUnset__-107)))) != 0) || (((_la-139)&-(0x1f+1)) == 0 && ((1<<uint((_la-139)))&((1<<(PhpParserToString__-139))|(1<<(PhpParserInvoke-139))|(1<<(PhpParserSetState-139))|(1<<(PhpParserClone__-139))|(1<<(PhpParserDebugInfo-139))|(1<<(PhpParserNamespace__-139))|(1<<(PhpParserClass__-139))|(1<<(PhpParserTraic__-139))|(1<<(PhpParserFunction__-139))|(1<<(PhpParserMethod__-139))|(1<<(PhpParserLine__-139))|(1<<(PhpParserFile__-139))|(1<<(PhpParserDir__-139)))) != 0) || (((_la-182)&-(0x1f+1)) == 0 && ((1<<uint((_la-182)))&((1<<(PhpParserNamespaceSeparator-182))|(1<<(PhpParserEllipsis-182))|(1<<(PhpParserAmpersand-182))|(1<<(PhpParserOpenSquareBracket-182))|(1<<(PhpParserVarName-182))|(1<<(PhpParserLabel-182)))) != 0) {
		{
			p.SetState(885)
			p.FormalParameter()
		}

	}
	p.SetState(892)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PhpParserComma {
		{
			p.SetState(888)
			p.Match(PhpParserComma)
		}
		{
			p.SetState(889)
			p.FormalParameter()
		}

		p.SetState(894)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IFormalParameterContext is an interface to support dynamic dispatch.
type IFormalParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFormalParameterContext differentiates from other interfaces.
	IsFormalParameterContext()
}

type FormalParameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFormalParameterContext() *FormalParameterContext {
	var p = new(FormalParameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_formalParameter
	return p
}

func (*FormalParameterContext) IsFormalParameterContext() {}

func NewFormalParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FormalParameterContext {
	var p = new(FormalParameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_formalParameter

	return p
}

func (s *FormalParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *FormalParameterContext) Attributes() IAttributesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttributesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttributesContext)
}

func (s *FormalParameterContext) VariableInitializer() IVariableInitializerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableInitializerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableInitializerContext)
}

func (s *FormalParameterContext) TypeHint() ITypeHintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeHintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeHintContext)
}

func (s *FormalParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FormalParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FormalParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterFormalParameter(s)
	}
}

func (s *FormalParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitFormalParameter(s)
	}
}

func (p *PhpParser) FormalParameter() (localctx IFormalParameterContext) {
	localctx = NewFormalParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, PhpParserRULE_formalParameter)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(895)
		p.Attributes()
	}
	p.SetState(897)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la-43)&-(0x1f+1)) == 0 && ((1<<uint((_la-43)))&((1<<(PhpParserAbstract-43))|(1<<(PhpParserArray-43))|(1<<(PhpParserAs-43))|(1<<(PhpParserBinaryCast-43))|(1<<(PhpParserBoolType-43))|(1<<(PhpParserBooleanConstant-43))|(1<<(PhpParserBreak-43))|(1<<(PhpParserCallable-43))|(1<<(PhpParserCase-43))|(1<<(PhpParserCatch-43))|(1<<(PhpParserClass-43))|(1<<(PhpParserClone-43))|(1<<(PhpParserConst-43))|(1<<(PhpParserContinue-43))|(1<<(PhpParserDeclare-43))|(1<<(PhpParserDefault-43))|(1<<(PhpParserDo-43))|(1<<(PhpParserDoubleCast-43))|(1<<(PhpParserDoubleType-43))|(1<<(PhpParserEcho-43))|(1<<(PhpParserElse-43))|(1<<(PhpParserElseIf-43))|(1<<(PhpParserEmpty-43))|(1<<(PhpParserEndDeclare-43))|(1<<(PhpParserEndFor-43))|(1<<(PhpParserEndForeach-43))|(1<<(PhpParserEndIf-43))|(1<<(PhpParserEndSwitch-43))|(1<<(PhpParserEndWhile-43))|(1<<(PhpParserEval-43))|(1<<(PhpParserExit-43))|(1<<(PhpParserExtends-43)))) != 0) || (((_la-75)&-(0x1f+1)) == 0 && ((1<<uint((_la-75)))&((1<<(PhpParserFinal-75))|(1<<(PhpParserFinally-75))|(1<<(PhpParserFloatCast-75))|(1<<(PhpParserFor-75))|(1<<(PhpParserForeach-75))|(1<<(PhpParserFunction-75))|(1<<(PhpParserGlobal-75))|(1<<(PhpParserGoto-75))|(1<<(PhpParserIf-75))|(1<<(PhpParserImplements-75))|(1<<(PhpParserImport-75))|(1<<(PhpParserInclude-75))|(1<<(PhpParserIncludeOnce-75))|(1<<(PhpParserInstanceOf-75))|(1<<(PhpParserInsteadOf-75))|(1<<(PhpParserInt8Cast-75))|(1<<(PhpParserInt16Cast-75))|(1<<(PhpParserInt64Type-75))|(1<<(PhpParserIntType-75))|(1<<(PhpParserInterface-75))|(1<<(PhpParserIsSet-75))|(1<<(PhpParserList-75))|(1<<(PhpParserLogicalAnd-75))|(1<<(PhpParserLogicalOr-75))|(1<<(PhpParserLogicalXor-75))|(1<<(PhpParserNamespace-75))|(1<<(PhpParserNew-75))|(1<<(PhpParserNull-75))|(1<<(PhpParserObjectType-75))|(1<<(PhpParserParent_-75))|(1<<(PhpParserPartial-75))|(1<<(PhpParserPrint-75)))) != 0) || (((_la-107)&-(0x1f+1)) == 0 && ((1<<uint((_la-107)))&((1<<(PhpParserPrivate-107))|(1<<(PhpParserProtected-107))|(1<<(PhpParserPublic-107))|(1<<(PhpParserRequire-107))|(1<<(PhpParserRequireOnce-107))|(1<<(PhpParserResource-107))|(1<<(PhpParserReturn-107))|(1<<(PhpParserStatic-107))|(1<<(PhpParserStringType-107))|(1<<(PhpParserSwitch-107))|(1<<(PhpParserThrow-107))|(1<<(PhpParserTrait-107))|(1<<(PhpParserTry-107))|(1<<(PhpParserTypeof-107))|(1<<(PhpParserUintCast-107))|(1<<(PhpParserUnicodeCast-107))|(1<<(PhpParserUnset-107))|(1<<(PhpParserUse-107))|(1<<(PhpParserVar-107))|(1<<(PhpParserWhile-107))|(1<<(PhpParserYield-107))|(1<<(PhpParserGet-107))|(1<<(PhpParserSet-107))|(1<<(PhpParserCall-107))|(1<<(PhpParserCallStatic-107))|(1<<(PhpParserConstructor-107))|(1<<(PhpParserDestruct-107))|(1<<(PhpParserWakeup-107))|(1<<(PhpParserSleep-107))|(1<<(PhpParserAutoload-107))|(1<<(PhpParserIsSet__-107))|(1<<(PhpParserUnset__-107)))) != 0) || (((_la-139)&-(0x1f+1)) == 0 && ((1<<uint((_la-139)))&((1<<(PhpParserToString__-139))|(1<<(PhpParserInvoke-139))|(1<<(PhpParserSetState-139))|(1<<(PhpParserClone__-139))|(1<<(PhpParserDebugInfo-139))|(1<<(PhpParserNamespace__-139))|(1<<(PhpParserClass__-139))|(1<<(PhpParserTraic__-139))|(1<<(PhpParserFunction__-139))|(1<<(PhpParserMethod__-139))|(1<<(PhpParserLine__-139))|(1<<(PhpParserFile__-139))|(1<<(PhpParserDir__-139)))) != 0) || _la == PhpParserNamespaceSeparator || _la == PhpParserLabel {
		{
			p.SetState(896)
			p.TypeHint()
		}

	}
	p.SetState(900)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PhpParserAmpersand {
		{
			p.SetState(899)
			p.Match(PhpParserAmpersand)
		}

	}
	p.SetState(903)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PhpParserEllipsis {
		{
			p.SetState(902)
			p.Match(PhpParserEllipsis)
		}

	}
	{
		p.SetState(905)
		p.VariableInitializer()
	}

	return localctx
}

// ITypeHintContext is an interface to support dynamic dispatch.
type ITypeHintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeHintContext differentiates from other interfaces.
	IsTypeHintContext()
}

type TypeHintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeHintContext() *TypeHintContext {
	var p = new(TypeHintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_typeHint
	return p
}

func (*TypeHintContext) IsTypeHintContext() {}

func NewTypeHintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeHintContext {
	var p = new(TypeHintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_typeHint

	return p
}

func (s *TypeHintContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeHintContext) QualifiedStaticTypeRef() IQualifiedStaticTypeRefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedStaticTypeRefContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedStaticTypeRefContext)
}

func (s *TypeHintContext) Callable() antlr.TerminalNode {
	return s.GetToken(PhpParserCallable, 0)
}

func (s *TypeHintContext) PrimitiveType() IPrimitiveTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimitiveTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimitiveTypeContext)
}

func (s *TypeHintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeHintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeHintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterTypeHint(s)
	}
}

func (s *TypeHintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitTypeHint(s)
	}
}

func (p *PhpParser) TypeHint() (localctx ITypeHintContext) {
	localctx = NewTypeHintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, PhpParserRULE_typeHint)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(910)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 86, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(907)
			p.QualifiedStaticTypeRef()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(908)
			p.Match(PhpParserCallable)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(909)
			p.PrimitiveType()
		}

	}

	return localctx
}

// IGlobalStatementContext is an interface to support dynamic dispatch.
type IGlobalStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGlobalStatementContext differentiates from other interfaces.
	IsGlobalStatementContext()
}

type GlobalStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGlobalStatementContext() *GlobalStatementContext {
	var p = new(GlobalStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_globalStatement
	return p
}

func (*GlobalStatementContext) IsGlobalStatementContext() {}

func NewGlobalStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GlobalStatementContext {
	var p = new(GlobalStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_globalStatement

	return p
}

func (s *GlobalStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *GlobalStatementContext) Global() antlr.TerminalNode {
	return s.GetToken(PhpParserGlobal, 0)
}

func (s *GlobalStatementContext) AllGlobalVar() []IGlobalVarContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IGlobalVarContext)(nil)).Elem())
	var tst = make([]IGlobalVarContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IGlobalVarContext)
		}
	}

	return tst
}

func (s *GlobalStatementContext) GlobalVar(i int) IGlobalVarContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGlobalVarContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IGlobalVarContext)
}

func (s *GlobalStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GlobalStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GlobalStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterGlobalStatement(s)
	}
}

func (s *GlobalStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitGlobalStatement(s)
	}
}

func (p *PhpParser) GlobalStatement() (localctx IGlobalStatementContext) {
	localctx = NewGlobalStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, PhpParserRULE_globalStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(912)
		p.Match(PhpParserGlobal)
	}
	{
		p.SetState(913)
		p.GlobalVar()
	}
	p.SetState(918)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PhpParserComma {
		{
			p.SetState(914)
			p.Match(PhpParserComma)
		}
		{
			p.SetState(915)
			p.GlobalVar()
		}

		p.SetState(920)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(921)
		p.Match(PhpParserSemiColon)
	}

	return localctx
}

// IGlobalVarContext is an interface to support dynamic dispatch.
type IGlobalVarContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGlobalVarContext differentiates from other interfaces.
	IsGlobalVarContext()
}

type GlobalVarContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGlobalVarContext() *GlobalVarContext {
	var p = new(GlobalVarContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_globalVar
	return p
}

func (*GlobalVarContext) IsGlobalVarContext() {}

func NewGlobalVarContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GlobalVarContext {
	var p = new(GlobalVarContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_globalVar

	return p
}

func (s *GlobalVarContext) GetParser() antlr.Parser { return s.parser }

func (s *GlobalVarContext) VarName() antlr.TerminalNode {
	return s.GetToken(PhpParserVarName, 0)
}

func (s *GlobalVarContext) Dollar() antlr.TerminalNode {
	return s.GetToken(PhpParserDollar, 0)
}

func (s *GlobalVarContext) Chain() IChainContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IChainContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IChainContext)
}

func (s *GlobalVarContext) OpenCurlyBracket() antlr.TerminalNode {
	return s.GetToken(PhpParserOpenCurlyBracket, 0)
}

func (s *GlobalVarContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *GlobalVarContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GlobalVarContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GlobalVarContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterGlobalVar(s)
	}
}

func (s *GlobalVarContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitGlobalVar(s)
	}
}

func (p *PhpParser) GlobalVar() (localctx IGlobalVarContext) {
	localctx = NewGlobalVarContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, PhpParserRULE_globalVar)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(931)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 88, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(923)
			p.Match(PhpParserVarName)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(924)
			p.Match(PhpParserDollar)
		}
		{
			p.SetState(925)
			p.Chain()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(926)
			p.Match(PhpParserDollar)
		}
		{
			p.SetState(927)
			p.Match(PhpParserOpenCurlyBracket)
		}
		{
			p.SetState(928)
			p.expression(0)
		}
		{
			p.SetState(929)
			p.Match(PhpParserCloseCurlyBracket)
		}

	}

	return localctx
}

// IEchoStatementContext is an interface to support dynamic dispatch.
type IEchoStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEchoStatementContext differentiates from other interfaces.
	IsEchoStatementContext()
}

type EchoStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEchoStatementContext() *EchoStatementContext {
	var p = new(EchoStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_echoStatement
	return p
}

func (*EchoStatementContext) IsEchoStatementContext() {}

func NewEchoStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EchoStatementContext {
	var p = new(EchoStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_echoStatement

	return p
}

func (s *EchoStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *EchoStatementContext) Echo() antlr.TerminalNode {
	return s.GetToken(PhpParserEcho, 0)
}

func (s *EchoStatementContext) ExpressionList() IExpressionListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *EchoStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EchoStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EchoStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterEchoStatement(s)
	}
}

func (s *EchoStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitEchoStatement(s)
	}
}

func (p *PhpParser) EchoStatement() (localctx IEchoStatementContext) {
	localctx = NewEchoStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, PhpParserRULE_echoStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(933)
		p.Match(PhpParserEcho)
	}
	{
		p.SetState(934)
		p.ExpressionList()
	}
	{
		p.SetState(935)
		p.Match(PhpParserSemiColon)
	}

	return localctx
}

// IStaticVariableStatementContext is an interface to support dynamic dispatch.
type IStaticVariableStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStaticVariableStatementContext differentiates from other interfaces.
	IsStaticVariableStatementContext()
}

type StaticVariableStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStaticVariableStatementContext() *StaticVariableStatementContext {
	var p = new(StaticVariableStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_staticVariableStatement
	return p
}

func (*StaticVariableStatementContext) IsStaticVariableStatementContext() {}

func NewStaticVariableStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StaticVariableStatementContext {
	var p = new(StaticVariableStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_staticVariableStatement

	return p
}

func (s *StaticVariableStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StaticVariableStatementContext) Static() antlr.TerminalNode {
	return s.GetToken(PhpParserStatic, 0)
}

func (s *StaticVariableStatementContext) AllVariableInitializer() []IVariableInitializerContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVariableInitializerContext)(nil)).Elem())
	var tst = make([]IVariableInitializerContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVariableInitializerContext)
		}
	}

	return tst
}

func (s *StaticVariableStatementContext) VariableInitializer(i int) IVariableInitializerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableInitializerContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVariableInitializerContext)
}

func (s *StaticVariableStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StaticVariableStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StaticVariableStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterStaticVariableStatement(s)
	}
}

func (s *StaticVariableStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitStaticVariableStatement(s)
	}
}

func (p *PhpParser) StaticVariableStatement() (localctx IStaticVariableStatementContext) {
	localctx = NewStaticVariableStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, PhpParserRULE_staticVariableStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(937)
		p.Match(PhpParserStatic)
	}
	{
		p.SetState(938)
		p.VariableInitializer()
	}
	p.SetState(943)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PhpParserComma {
		{
			p.SetState(939)
			p.Match(PhpParserComma)
		}
		{
			p.SetState(940)
			p.VariableInitializer()
		}

		p.SetState(945)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(946)
		p.Match(PhpParserSemiColon)
	}

	return localctx
}

// IClassStatementContext is an interface to support dynamic dispatch.
type IClassStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassStatementContext differentiates from other interfaces.
	IsClassStatementContext()
}

type ClassStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassStatementContext() *ClassStatementContext {
	var p = new(ClassStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_classStatement
	return p
}

func (*ClassStatementContext) IsClassStatementContext() {}

func NewClassStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassStatementContext {
	var p = new(ClassStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_classStatement

	return p
}

func (s *ClassStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassStatementContext) Attributes() IAttributesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttributesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttributesContext)
}

func (s *ClassStatementContext) PropertyModifiers() IPropertyModifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPropertyModifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPropertyModifiersContext)
}

func (s *ClassStatementContext) AllVariableInitializer() []IVariableInitializerContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVariableInitializerContext)(nil)).Elem())
	var tst = make([]IVariableInitializerContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVariableInitializerContext)
		}
	}

	return tst
}

func (s *ClassStatementContext) VariableInitializer(i int) IVariableInitializerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableInitializerContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVariableInitializerContext)
}

func (s *ClassStatementContext) Const() antlr.TerminalNode {
	return s.GetToken(PhpParserConst, 0)
}

func (s *ClassStatementContext) AllIdentifierInititalizer() []IIdentifierInititalizerContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierInititalizerContext)(nil)).Elem())
	var tst = make([]IIdentifierInititalizerContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierInititalizerContext)
		}
	}

	return tst
}

func (s *ClassStatementContext) IdentifierInititalizer(i int) IIdentifierInititalizerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierInititalizerContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierInititalizerContext)
}

func (s *ClassStatementContext) Function() antlr.TerminalNode {
	return s.GetToken(PhpParserFunction, 0)
}

func (s *ClassStatementContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ClassStatementContext) FormalParameterList() IFormalParameterListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFormalParameterListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *ClassStatementContext) MethodBody() IMethodBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMethodBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMethodBodyContext)
}

func (s *ClassStatementContext) MemberModifiers() IMemberModifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMemberModifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMemberModifiersContext)
}

func (s *ClassStatementContext) TypeParameterListInBrackets() ITypeParameterListInBracketsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeParameterListInBracketsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeParameterListInBracketsContext)
}

func (s *ClassStatementContext) BaseCtorCall() IBaseCtorCallContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBaseCtorCallContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBaseCtorCallContext)
}

func (s *ClassStatementContext) Use() antlr.TerminalNode {
	return s.GetToken(PhpParserUse, 0)
}

func (s *ClassStatementContext) QualifiedNamespaceNameList() IQualifiedNamespaceNameListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNamespaceNameListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNamespaceNameListContext)
}

func (s *ClassStatementContext) TraitAdaptations() ITraitAdaptationsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITraitAdaptationsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITraitAdaptationsContext)
}

func (s *ClassStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterClassStatement(s)
	}
}

func (s *ClassStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitClassStatement(s)
	}
}

func (p *PhpParser) ClassStatement() (localctx IClassStatementContext) {
	localctx = NewClassStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, PhpParserRULE_classStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(996)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 96, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(948)
			p.Attributes()
		}
		{
			p.SetState(949)
			p.PropertyModifiers()
		}
		{
			p.SetState(950)
			p.VariableInitializer()
		}
		p.SetState(955)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == PhpParserComma {
			{
				p.SetState(951)
				p.Match(PhpParserComma)
			}
			{
				p.SetState(952)
				p.VariableInitializer()
			}

			p.SetState(957)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(958)
			p.Match(PhpParserSemiColon)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(960)
			p.Attributes()
		}
		{
			p.SetState(961)
			p.Match(PhpParserConst)
		}
		{
			p.SetState(962)
			p.IdentifierInititalizer()
		}
		p.SetState(967)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == PhpParserComma {
			{
				p.SetState(963)
				p.Match(PhpParserComma)
			}
			{
				p.SetState(964)
				p.IdentifierInititalizer()
			}

			p.SetState(969)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(970)
			p.Match(PhpParserSemiColon)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(972)
			p.Attributes()
		}
		p.SetState(974)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PhpParserAbstract || _la == PhpParserFinal || (((_la-107)&-(0x1f+1)) == 0 && ((1<<uint((_la-107)))&((1<<(PhpParserPrivate-107))|(1<<(PhpParserProtected-107))|(1<<(PhpParserPublic-107))|(1<<(PhpParserStatic-107)))) != 0) {
			{
				p.SetState(973)
				p.MemberModifiers()
			}

		}
		{
			p.SetState(976)
			p.Match(PhpParserFunction)
		}
		p.SetState(978)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PhpParserAmpersand {
			{
				p.SetState(977)
				p.Match(PhpParserAmpersand)
			}

		}
		{
			p.SetState(980)
			p.Identifier()
		}
		p.SetState(982)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PhpParserLgeneric {
			{
				p.SetState(981)
				p.TypeParameterListInBrackets()
			}

		}
		{
			p.SetState(984)
			p.Match(PhpParserOpenRoundBracket)
		}
		{
			p.SetState(985)
			p.FormalParameterList()
		}
		{
			p.SetState(986)
			p.Match(PhpParserCloseRoundBracket)
		}
		p.SetState(988)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PhpParserColon {
			{
				p.SetState(987)
				p.BaseCtorCall()
			}

		}
		{
			p.SetState(990)
			p.MethodBody()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(992)
			p.Match(PhpParserUse)
		}
		{
			p.SetState(993)
			p.QualifiedNamespaceNameList()
		}
		{
			p.SetState(994)
			p.TraitAdaptations()
		}

	}

	return localctx
}

// ITraitAdaptationsContext is an interface to support dynamic dispatch.
type ITraitAdaptationsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTraitAdaptationsContext differentiates from other interfaces.
	IsTraitAdaptationsContext()
}

type TraitAdaptationsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTraitAdaptationsContext() *TraitAdaptationsContext {
	var p = new(TraitAdaptationsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_traitAdaptations
	return p
}

func (*TraitAdaptationsContext) IsTraitAdaptationsContext() {}

func NewTraitAdaptationsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TraitAdaptationsContext {
	var p = new(TraitAdaptationsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_traitAdaptations

	return p
}

func (s *TraitAdaptationsContext) GetParser() antlr.Parser { return s.parser }

func (s *TraitAdaptationsContext) OpenCurlyBracket() antlr.TerminalNode {
	return s.GetToken(PhpParserOpenCurlyBracket, 0)
}

func (s *TraitAdaptationsContext) AllTraitAdaptationStatement() []ITraitAdaptationStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITraitAdaptationStatementContext)(nil)).Elem())
	var tst = make([]ITraitAdaptationStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITraitAdaptationStatementContext)
		}
	}

	return tst
}

func (s *TraitAdaptationsContext) TraitAdaptationStatement(i int) ITraitAdaptationStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITraitAdaptationStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITraitAdaptationStatementContext)
}

func (s *TraitAdaptationsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TraitAdaptationsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TraitAdaptationsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterTraitAdaptations(s)
	}
}

func (s *TraitAdaptationsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitTraitAdaptations(s)
	}
}

func (p *PhpParser) TraitAdaptations() (localctx ITraitAdaptationsContext) {
	localctx = NewTraitAdaptationsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, PhpParserRULE_traitAdaptations)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1007)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PhpParserSemiColon:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(998)
			p.Match(PhpParserSemiColon)
		}

	case PhpParserOpenCurlyBracket:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(999)
			p.Match(PhpParserOpenCurlyBracket)
		}
		p.SetState(1003)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for (((_la-43)&-(0x1f+1)) == 0 && ((1<<uint((_la-43)))&((1<<(PhpParserAbstract-43))|(1<<(PhpParserArray-43))|(1<<(PhpParserAs-43))|(1<<(PhpParserBinaryCast-43))|(1<<(PhpParserBoolType-43))|(1<<(PhpParserBooleanConstant-43))|(1<<(PhpParserBreak-43))|(1<<(PhpParserCallable-43))|(1<<(PhpParserCase-43))|(1<<(PhpParserCatch-43))|(1<<(PhpParserClass-43))|(1<<(PhpParserClone-43))|(1<<(PhpParserConst-43))|(1<<(PhpParserContinue-43))|(1<<(PhpParserDeclare-43))|(1<<(PhpParserDefault-43))|(1<<(PhpParserDo-43))|(1<<(PhpParserDoubleCast-43))|(1<<(PhpParserDoubleType-43))|(1<<(PhpParserEcho-43))|(1<<(PhpParserElse-43))|(1<<(PhpParserElseIf-43))|(1<<(PhpParserEmpty-43))|(1<<(PhpParserEndDeclare-43))|(1<<(PhpParserEndFor-43))|(1<<(PhpParserEndForeach-43))|(1<<(PhpParserEndIf-43))|(1<<(PhpParserEndSwitch-43))|(1<<(PhpParserEndWhile-43))|(1<<(PhpParserEval-43))|(1<<(PhpParserExit-43))|(1<<(PhpParserExtends-43)))) != 0) || (((_la-75)&-(0x1f+1)) == 0 && ((1<<uint((_la-75)))&((1<<(PhpParserFinal-75))|(1<<(PhpParserFinally-75))|(1<<(PhpParserFloatCast-75))|(1<<(PhpParserFor-75))|(1<<(PhpParserForeach-75))|(1<<(PhpParserFunction-75))|(1<<(PhpParserGlobal-75))|(1<<(PhpParserGoto-75))|(1<<(PhpParserIf-75))|(1<<(PhpParserImplements-75))|(1<<(PhpParserImport-75))|(1<<(PhpParserInclude-75))|(1<<(PhpParserIncludeOnce-75))|(1<<(PhpParserInstanceOf-75))|(1<<(PhpParserInsteadOf-75))|(1<<(PhpParserInt8Cast-75))|(1<<(PhpParserInt16Cast-75))|(1<<(PhpParserInt64Type-75))|(1<<(PhpParserIntType-75))|(1<<(PhpParserInterface-75))|(1<<(PhpParserIsSet-75))|(1<<(PhpParserList-75))|(1<<(PhpParserLogicalAnd-75))|(1<<(PhpParserLogicalOr-75))|(1<<(PhpParserLogicalXor-75))|(1<<(PhpParserNamespace-75))|(1<<(PhpParserNew-75))|(1<<(PhpParserNull-75))|(1<<(PhpParserObjectType-75))|(1<<(PhpParserParent_-75))|(1<<(PhpParserPartial-75))|(1<<(PhpParserPrint-75)))) != 0) || (((_la-107)&-(0x1f+1)) == 0 && ((1<<uint((_la-107)))&((1<<(PhpParserPrivate-107))|(1<<(PhpParserProtected-107))|(1<<(PhpParserPublic-107))|(1<<(PhpParserRequire-107))|(1<<(PhpParserRequireOnce-107))|(1<<(PhpParserResource-107))|(1<<(PhpParserReturn-107))|(1<<(PhpParserStatic-107))|(1<<(PhpParserStringType-107))|(1<<(PhpParserSwitch-107))|(1<<(PhpParserThrow-107))|(1<<(PhpParserTrait-107))|(1<<(PhpParserTry-107))|(1<<(PhpParserTypeof-107))|(1<<(PhpParserUintCast-107))|(1<<(PhpParserUnicodeCast-107))|(1<<(PhpParserUnset-107))|(1<<(PhpParserUse-107))|(1<<(PhpParserVar-107))|(1<<(PhpParserWhile-107))|(1<<(PhpParserYield-107))|(1<<(PhpParserGet-107))|(1<<(PhpParserSet-107))|(1<<(PhpParserCall-107))|(1<<(PhpParserCallStatic-107))|(1<<(PhpParserConstructor-107))|(1<<(PhpParserDestruct-107))|(1<<(PhpParserWakeup-107))|(1<<(PhpParserSleep-107))|(1<<(PhpParserAutoload-107))|(1<<(PhpParserIsSet__-107))|(1<<(PhpParserUnset__-107)))) != 0) || (((_la-139)&-(0x1f+1)) == 0 && ((1<<uint((_la-139)))&((1<<(PhpParserToString__-139))|(1<<(PhpParserInvoke-139))|(1<<(PhpParserSetState-139))|(1<<(PhpParserClone__-139))|(1<<(PhpParserDebugInfo-139))|(1<<(PhpParserNamespace__-139))|(1<<(PhpParserClass__-139))|(1<<(PhpParserTraic__-139))|(1<<(PhpParserFunction__-139))|(1<<(PhpParserMethod__-139))|(1<<(PhpParserLine__-139))|(1<<(PhpParserFile__-139))|(1<<(PhpParserDir__-139)))) != 0) || _la == PhpParserNamespaceSeparator || _la == PhpParserLabel {
			{
				p.SetState(1000)
				p.TraitAdaptationStatement()
			}

			p.SetState(1005)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1006)
			p.Match(PhpParserCloseCurlyBracket)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITraitAdaptationStatementContext is an interface to support dynamic dispatch.
type ITraitAdaptationStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTraitAdaptationStatementContext differentiates from other interfaces.
	IsTraitAdaptationStatementContext()
}

type TraitAdaptationStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTraitAdaptationStatementContext() *TraitAdaptationStatementContext {
	var p = new(TraitAdaptationStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_traitAdaptationStatement
	return p
}

func (*TraitAdaptationStatementContext) IsTraitAdaptationStatementContext() {}

func NewTraitAdaptationStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TraitAdaptationStatementContext {
	var p = new(TraitAdaptationStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_traitAdaptationStatement

	return p
}

func (s *TraitAdaptationStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *TraitAdaptationStatementContext) TraitPrecedence() ITraitPrecedenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITraitPrecedenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITraitPrecedenceContext)
}

func (s *TraitAdaptationStatementContext) TraitAlias() ITraitAliasContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITraitAliasContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITraitAliasContext)
}

func (s *TraitAdaptationStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TraitAdaptationStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TraitAdaptationStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterTraitAdaptationStatement(s)
	}
}

func (s *TraitAdaptationStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitTraitAdaptationStatement(s)
	}
}

func (p *PhpParser) TraitAdaptationStatement() (localctx ITraitAdaptationStatementContext) {
	localctx = NewTraitAdaptationStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, PhpParserRULE_traitAdaptationStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1011)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 99, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1009)
			p.TraitPrecedence()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1010)
			p.TraitAlias()
		}

	}

	return localctx
}

// ITraitPrecedenceContext is an interface to support dynamic dispatch.
type ITraitPrecedenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTraitPrecedenceContext differentiates from other interfaces.
	IsTraitPrecedenceContext()
}

type TraitPrecedenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTraitPrecedenceContext() *TraitPrecedenceContext {
	var p = new(TraitPrecedenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_traitPrecedence
	return p
}

func (*TraitPrecedenceContext) IsTraitPrecedenceContext() {}

func NewTraitPrecedenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TraitPrecedenceContext {
	var p = new(TraitPrecedenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_traitPrecedence

	return p
}

func (s *TraitPrecedenceContext) GetParser() antlr.Parser { return s.parser }

func (s *TraitPrecedenceContext) QualifiedNamespaceName() IQualifiedNamespaceNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNamespaceNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNamespaceNameContext)
}

func (s *TraitPrecedenceContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TraitPrecedenceContext) InsteadOf() antlr.TerminalNode {
	return s.GetToken(PhpParserInsteadOf, 0)
}

func (s *TraitPrecedenceContext) QualifiedNamespaceNameList() IQualifiedNamespaceNameListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNamespaceNameListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNamespaceNameListContext)
}

func (s *TraitPrecedenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TraitPrecedenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TraitPrecedenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterTraitPrecedence(s)
	}
}

func (s *TraitPrecedenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitTraitPrecedence(s)
	}
}

func (p *PhpParser) TraitPrecedence() (localctx ITraitPrecedenceContext) {
	localctx = NewTraitPrecedenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, PhpParserRULE_traitPrecedence)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1013)
		p.QualifiedNamespaceName()
	}
	{
		p.SetState(1014)
		p.Match(PhpParserDoubleColon)
	}
	{
		p.SetState(1015)
		p.Identifier()
	}
	{
		p.SetState(1016)
		p.Match(PhpParserInsteadOf)
	}
	{
		p.SetState(1017)
		p.QualifiedNamespaceNameList()
	}
	{
		p.SetState(1018)
		p.Match(PhpParserSemiColon)
	}

	return localctx
}

// ITraitAliasContext is an interface to support dynamic dispatch.
type ITraitAliasContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTraitAliasContext differentiates from other interfaces.
	IsTraitAliasContext()
}

type TraitAliasContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTraitAliasContext() *TraitAliasContext {
	var p = new(TraitAliasContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_traitAlias
	return p
}

func (*TraitAliasContext) IsTraitAliasContext() {}

func NewTraitAliasContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TraitAliasContext {
	var p = new(TraitAliasContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_traitAlias

	return p
}

func (s *TraitAliasContext) GetParser() antlr.Parser { return s.parser }

func (s *TraitAliasContext) TraitMethodReference() ITraitMethodReferenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITraitMethodReferenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITraitMethodReferenceContext)
}

func (s *TraitAliasContext) As() antlr.TerminalNode {
	return s.GetToken(PhpParserAs, 0)
}

func (s *TraitAliasContext) MemberModifier() IMemberModifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMemberModifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMemberModifierContext)
}

func (s *TraitAliasContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TraitAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TraitAliasContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TraitAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterTraitAlias(s)
	}
}

func (s *TraitAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitTraitAlias(s)
	}
}

func (p *PhpParser) TraitAlias() (localctx ITraitAliasContext) {
	localctx = NewTraitAliasContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, PhpParserRULE_traitAlias)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1020)
		p.TraitMethodReference()
	}
	{
		p.SetState(1021)
		p.Match(PhpParserAs)
	}
	p.SetState(1027)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 101, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1022)
			p.MemberModifier()
		}

	case 2:
		p.SetState(1024)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 100, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1023)
				p.MemberModifier()
			}

		}
		{
			p.SetState(1026)
			p.Identifier()
		}

	}
	{
		p.SetState(1029)
		p.Match(PhpParserSemiColon)
	}

	return localctx
}

// ITraitMethodReferenceContext is an interface to support dynamic dispatch.
type ITraitMethodReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTraitMethodReferenceContext differentiates from other interfaces.
	IsTraitMethodReferenceContext()
}

type TraitMethodReferenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTraitMethodReferenceContext() *TraitMethodReferenceContext {
	var p = new(TraitMethodReferenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_traitMethodReference
	return p
}

func (*TraitMethodReferenceContext) IsTraitMethodReferenceContext() {}

func NewTraitMethodReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TraitMethodReferenceContext {
	var p = new(TraitMethodReferenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_traitMethodReference

	return p
}

func (s *TraitMethodReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *TraitMethodReferenceContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TraitMethodReferenceContext) QualifiedNamespaceName() IQualifiedNamespaceNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNamespaceNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNamespaceNameContext)
}

func (s *TraitMethodReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TraitMethodReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TraitMethodReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterTraitMethodReference(s)
	}
}

func (s *TraitMethodReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitTraitMethodReference(s)
	}
}

func (p *PhpParser) TraitMethodReference() (localctx ITraitMethodReferenceContext) {
	localctx = NewTraitMethodReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, PhpParserRULE_traitMethodReference)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1034)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 102, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1031)
			p.QualifiedNamespaceName()
		}
		{
			p.SetState(1032)
			p.Match(PhpParserDoubleColon)
		}

	}
	{
		p.SetState(1036)
		p.Identifier()
	}

	return localctx
}

// IBaseCtorCallContext is an interface to support dynamic dispatch.
type IBaseCtorCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBaseCtorCallContext differentiates from other interfaces.
	IsBaseCtorCallContext()
}

type BaseCtorCallContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBaseCtorCallContext() *BaseCtorCallContext {
	var p = new(BaseCtorCallContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_baseCtorCall
	return p
}

func (*BaseCtorCallContext) IsBaseCtorCallContext() {}

func NewBaseCtorCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BaseCtorCallContext {
	var p = new(BaseCtorCallContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_baseCtorCall

	return p
}

func (s *BaseCtorCallContext) GetParser() antlr.Parser { return s.parser }

func (s *BaseCtorCallContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *BaseCtorCallContext) Arguments() IArgumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArgumentsContext)
}

func (s *BaseCtorCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BaseCtorCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BaseCtorCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterBaseCtorCall(s)
	}
}

func (s *BaseCtorCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitBaseCtorCall(s)
	}
}

func (p *PhpParser) BaseCtorCall() (localctx IBaseCtorCallContext) {
	localctx = NewBaseCtorCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, PhpParserRULE_baseCtorCall)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1038)
		p.Match(PhpParserColon)
	}
	{
		p.SetState(1039)
		p.Identifier()
	}
	{
		p.SetState(1040)
		p.Arguments()
	}

	return localctx
}

// IMethodBodyContext is an interface to support dynamic dispatch.
type IMethodBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMethodBodyContext differentiates from other interfaces.
	IsMethodBodyContext()
}

type MethodBodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethodBodyContext() *MethodBodyContext {
	var p = new(MethodBodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_methodBody
	return p
}

func (*MethodBodyContext) IsMethodBodyContext() {}

func NewMethodBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodBodyContext {
	var p = new(MethodBodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_methodBody

	return p
}

func (s *MethodBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodBodyContext) BlockStatement() IBlockStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockStatementContext)
}

func (s *MethodBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MethodBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterMethodBody(s)
	}
}

func (s *MethodBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitMethodBody(s)
	}
}

func (p *PhpParser) MethodBody() (localctx IMethodBodyContext) {
	localctx = NewMethodBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, PhpParserRULE_methodBody)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1044)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PhpParserSemiColon:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1042)
			p.Match(PhpParserSemiColon)
		}

	case PhpParserOpenCurlyBracket:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1043)
			p.BlockStatement()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IPropertyModifiersContext is an interface to support dynamic dispatch.
type IPropertyModifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPropertyModifiersContext differentiates from other interfaces.
	IsPropertyModifiersContext()
}

type PropertyModifiersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyModifiersContext() *PropertyModifiersContext {
	var p = new(PropertyModifiersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_propertyModifiers
	return p
}

func (*PropertyModifiersContext) IsPropertyModifiersContext() {}

func NewPropertyModifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyModifiersContext {
	var p = new(PropertyModifiersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_propertyModifiers

	return p
}

func (s *PropertyModifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyModifiersContext) MemberModifiers() IMemberModifiersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMemberModifiersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMemberModifiersContext)
}

func (s *PropertyModifiersContext) Var() antlr.TerminalNode {
	return s.GetToken(PhpParserVar, 0)
}

func (s *PropertyModifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyModifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyModifiersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterPropertyModifiers(s)
	}
}

func (s *PropertyModifiersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitPropertyModifiers(s)
	}
}

func (p *PhpParser) PropertyModifiers() (localctx IPropertyModifiersContext) {
	localctx = NewPropertyModifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, PhpParserRULE_propertyModifiers)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1048)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PhpParserAbstract, PhpParserFinal, PhpParserPrivate, PhpParserProtected, PhpParserPublic, PhpParserStatic:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1046)
			p.MemberModifiers()
		}

	case PhpParserVar:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1047)
			p.Match(PhpParserVar)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IMemberModifiersContext is an interface to support dynamic dispatch.
type IMemberModifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMemberModifiersContext differentiates from other interfaces.
	IsMemberModifiersContext()
}

type MemberModifiersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMemberModifiersContext() *MemberModifiersContext {
	var p = new(MemberModifiersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_memberModifiers
	return p
}

func (*MemberModifiersContext) IsMemberModifiersContext() {}

func NewMemberModifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MemberModifiersContext {
	var p = new(MemberModifiersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_memberModifiers

	return p
}

func (s *MemberModifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *MemberModifiersContext) AllMemberModifier() []IMemberModifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMemberModifierContext)(nil)).Elem())
	var tst = make([]IMemberModifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMemberModifierContext)
		}
	}

	return tst
}

func (s *MemberModifiersContext) MemberModifier(i int) IMemberModifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMemberModifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMemberModifierContext)
}

func (s *MemberModifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MemberModifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MemberModifiersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterMemberModifiers(s)
	}
}

func (s *MemberModifiersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitMemberModifiers(s)
	}
}

func (p *PhpParser) MemberModifiers() (localctx IMemberModifiersContext) {
	localctx = NewMemberModifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, PhpParserRULE_memberModifiers)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1051)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == PhpParserAbstract || _la == PhpParserFinal || (((_la-107)&-(0x1f+1)) == 0 && ((1<<uint((_la-107)))&((1<<(PhpParserPrivate-107))|(1<<(PhpParserProtected-107))|(1<<(PhpParserPublic-107))|(1<<(PhpParserStatic-107)))) != 0) {
		{
			p.SetState(1050)
			p.MemberModifier()
		}

		p.SetState(1053)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IVariableInitializerContext is an interface to support dynamic dispatch.
type IVariableInitializerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariableInitializerContext differentiates from other interfaces.
	IsVariableInitializerContext()
}

type VariableInitializerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableInitializerContext() *VariableInitializerContext {
	var p = new(VariableInitializerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_variableInitializer
	return p
}

func (*VariableInitializerContext) IsVariableInitializerContext() {}

func NewVariableInitializerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableInitializerContext {
	var p = new(VariableInitializerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_variableInitializer

	return p
}

func (s *VariableInitializerContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableInitializerContext) VarName() antlr.TerminalNode {
	return s.GetToken(PhpParserVarName, 0)
}

func (s *VariableInitializerContext) Eq() antlr.TerminalNode {
	return s.GetToken(PhpParserEq, 0)
}

func (s *VariableInitializerContext) ConstantInititalizer() IConstantInititalizerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstantInititalizerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstantInititalizerContext)
}

func (s *VariableInitializerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableInitializerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableInitializerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterVariableInitializer(s)
	}
}

func (s *VariableInitializerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitVariableInitializer(s)
	}
}

func (p *PhpParser) VariableInitializer() (localctx IVariableInitializerContext) {
	localctx = NewVariableInitializerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, PhpParserRULE_variableInitializer)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1055)
		p.Match(PhpParserVarName)
	}
	p.SetState(1058)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PhpParserEq {
		{
			p.SetState(1056)
			p.Match(PhpParserEq)
		}
		{
			p.SetState(1057)
			p.ConstantInititalizer()
		}

	}

	return localctx
}

// IIdentifierInititalizerContext is an interface to support dynamic dispatch.
type IIdentifierInititalizerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIdentifierInititalizerContext differentiates from other interfaces.
	IsIdentifierInititalizerContext()
}

type IdentifierInititalizerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierInititalizerContext() *IdentifierInititalizerContext {
	var p = new(IdentifierInititalizerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_identifierInititalizer
	return p
}

func (*IdentifierInititalizerContext) IsIdentifierInititalizerContext() {}

func NewIdentifierInititalizerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierInititalizerContext {
	var p = new(IdentifierInititalizerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_identifierInititalizer

	return p
}

func (s *IdentifierInititalizerContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierInititalizerContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *IdentifierInititalizerContext) Eq() antlr.TerminalNode {
	return s.GetToken(PhpParserEq, 0)
}

func (s *IdentifierInititalizerContext) ConstantInititalizer() IConstantInititalizerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstantInititalizerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstantInititalizerContext)
}

func (s *IdentifierInititalizerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierInititalizerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierInititalizerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterIdentifierInititalizer(s)
	}
}

func (s *IdentifierInititalizerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitIdentifierInititalizer(s)
	}
}

func (p *PhpParser) IdentifierInititalizer() (localctx IIdentifierInititalizerContext) {
	localctx = NewIdentifierInititalizerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, PhpParserRULE_identifierInititalizer)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1060)
		p.Identifier()
	}
	{
		p.SetState(1061)
		p.Match(PhpParserEq)
	}
	{
		p.SetState(1062)
		p.ConstantInititalizer()
	}

	return localctx
}

// IGlobalConstantDeclarationContext is an interface to support dynamic dispatch.
type IGlobalConstantDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGlobalConstantDeclarationContext differentiates from other interfaces.
	IsGlobalConstantDeclarationContext()
}

type GlobalConstantDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGlobalConstantDeclarationContext() *GlobalConstantDeclarationContext {
	var p = new(GlobalConstantDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_globalConstantDeclaration
	return p
}

func (*GlobalConstantDeclarationContext) IsGlobalConstantDeclarationContext() {}

func NewGlobalConstantDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GlobalConstantDeclarationContext {
	var p = new(GlobalConstantDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_globalConstantDeclaration

	return p
}

func (s *GlobalConstantDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *GlobalConstantDeclarationContext) Attributes() IAttributesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttributesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttributesContext)
}

func (s *GlobalConstantDeclarationContext) Const() antlr.TerminalNode {
	return s.GetToken(PhpParserConst, 0)
}

func (s *GlobalConstantDeclarationContext) AllIdentifierInititalizer() []IIdentifierInititalizerContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierInititalizerContext)(nil)).Elem())
	var tst = make([]IIdentifierInititalizerContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierInititalizerContext)
		}
	}

	return tst
}

func (s *GlobalConstantDeclarationContext) IdentifierInititalizer(i int) IIdentifierInititalizerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierInititalizerContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierInititalizerContext)
}

func (s *GlobalConstantDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GlobalConstantDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GlobalConstantDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterGlobalConstantDeclaration(s)
	}
}

func (s *GlobalConstantDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitGlobalConstantDeclaration(s)
	}
}

func (p *PhpParser) GlobalConstantDeclaration() (localctx IGlobalConstantDeclarationContext) {
	localctx = NewGlobalConstantDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, PhpParserRULE_globalConstantDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1064)
		p.Attributes()
	}
	{
		p.SetState(1065)
		p.Match(PhpParserConst)
	}
	{
		p.SetState(1066)
		p.IdentifierInititalizer()
	}
	p.SetState(1071)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PhpParserComma {
		{
			p.SetState(1067)
			p.Match(PhpParserComma)
		}
		{
			p.SetState(1068)
			p.IdentifierInititalizer()
		}

		p.SetState(1073)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1074)
		p.Match(PhpParserSemiColon)
	}

	return localctx
}

// IExpressionListContext is an interface to support dynamic dispatch.
type IExpressionListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpressionListContext differentiates from other interfaces.
	IsExpressionListContext()
}

type ExpressionListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionListContext() *ExpressionListContext {
	var p = new(ExpressionListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_expressionList
	return p
}

func (*ExpressionListContext) IsExpressionListContext() {}

func NewExpressionListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionListContext {
	var p = new(ExpressionListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_expressionList

	return p
}

func (s *ExpressionListContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionListContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *ExpressionListContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterExpressionList(s)
	}
}

func (s *ExpressionListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitExpressionList(s)
	}
}

func (p *PhpParser) ExpressionList() (localctx IExpressionListContext) {
	localctx = NewExpressionListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, PhpParserRULE_expressionList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1076)
		p.expression(0)
	}
	p.SetState(1081)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PhpParserComma {
		{
			p.SetState(1077)
			p.Match(PhpParserComma)
		}
		{
			p.SetState(1078)
			p.expression(0)
		}

		p.SetState(1083)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IParenthesisContext is an interface to support dynamic dispatch.
type IParenthesisContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParenthesisContext differentiates from other interfaces.
	IsParenthesisContext()
}

type ParenthesisContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParenthesisContext() *ParenthesisContext {
	var p = new(ParenthesisContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_parenthesis
	return p
}

func (*ParenthesisContext) IsParenthesisContext() {}

func NewParenthesisContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParenthesisContext {
	var p = new(ParenthesisContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_parenthesis

	return p
}

func (s *ParenthesisContext) GetParser() antlr.Parser { return s.parser }

func (s *ParenthesisContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ParenthesisContext) YieldExpression() IYieldExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IYieldExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IYieldExpressionContext)
}

func (s *ParenthesisContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenthesisContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParenthesisContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterParenthesis(s)
	}
}

func (s *ParenthesisContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitParenthesis(s)
	}
}

func (p *PhpParser) Parenthesis() (localctx IParenthesisContext) {
	localctx = NewParenthesisContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, PhpParserRULE_parenthesis)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1084)
		p.Match(PhpParserOpenRoundBracket)
	}
	p.SetState(1087)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 109, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1085)
			p.expression(0)
		}

	case 2:
		{
			p.SetState(1086)
			p.YieldExpression()
		}

	}
	{
		p.SetState(1089)
		p.Match(PhpParserCloseRoundBracket)
	}

	return localctx
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_expression
	return p
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) CopyFrom(ctx *ExpressionContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ChainExpressionContext struct {
	*ExpressionContext
}

func NewChainExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ChainExpressionContext {
	var p = new(ChainExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *ChainExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ChainExpressionContext) Chain() IChainContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IChainContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IChainContext)
}

func (s *ChainExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterChainExpression(s)
	}
}

func (s *ChainExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitChainExpression(s)
	}
}

type UnaryOperatorExpressionContext struct {
	*ExpressionContext
}

func NewUnaryOperatorExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnaryOperatorExpressionContext {
	var p = new(UnaryOperatorExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *UnaryOperatorExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryOperatorExpressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *UnaryOperatorExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterUnaryOperatorExpression(s)
	}
}

func (s *UnaryOperatorExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitUnaryOperatorExpression(s)
	}
}

type SpecialWordExpressionContext struct {
	*ExpressionContext
}

func NewSpecialWordExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SpecialWordExpressionContext {
	var p = new(SpecialWordExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *SpecialWordExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpecialWordExpressionContext) Yield() antlr.TerminalNode {
	return s.GetToken(PhpParserYield, 0)
}

func (s *SpecialWordExpressionContext) List() antlr.TerminalNode {
	return s.GetToken(PhpParserList, 0)
}

func (s *SpecialWordExpressionContext) AssignmentList() IAssignmentListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignmentListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignmentListContext)
}

func (s *SpecialWordExpressionContext) Eq() antlr.TerminalNode {
	return s.GetToken(PhpParserEq, 0)
}

func (s *SpecialWordExpressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SpecialWordExpressionContext) IsSet() antlr.TerminalNode {
	return s.GetToken(PhpParserIsSet, 0)
}

func (s *SpecialWordExpressionContext) ChainList() IChainListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IChainListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IChainListContext)
}

func (s *SpecialWordExpressionContext) Empty() antlr.TerminalNode {
	return s.GetToken(PhpParserEmpty, 0)
}

func (s *SpecialWordExpressionContext) Chain() IChainContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IChainContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IChainContext)
}

func (s *SpecialWordExpressionContext) Eval() antlr.TerminalNode {
	return s.GetToken(PhpParserEval, 0)
}

func (s *SpecialWordExpressionContext) Exit() antlr.TerminalNode {
	return s.GetToken(PhpParserExit, 0)
}

func (s *SpecialWordExpressionContext) Parenthesis() IParenthesisContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParenthesisContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParenthesisContext)
}

func (s *SpecialWordExpressionContext) Include() antlr.TerminalNode {
	return s.GetToken(PhpParserInclude, 0)
}

func (s *SpecialWordExpressionContext) IncludeOnce() antlr.TerminalNode {
	return s.GetToken(PhpParserIncludeOnce, 0)
}

func (s *SpecialWordExpressionContext) Require() antlr.TerminalNode {
	return s.GetToken(PhpParserRequire, 0)
}

func (s *SpecialWordExpressionContext) RequireOnce() antlr.TerminalNode {
	return s.GetToken(PhpParserRequireOnce, 0)
}

func (s *SpecialWordExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterSpecialWordExpression(s)
	}
}

func (s *SpecialWordExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitSpecialWordExpression(s)
	}
}

type ArrayCreationExpressionContext struct {
	*ExpressionContext
}

func NewArrayCreationExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArrayCreationExpressionContext {
	var p = new(ArrayCreationExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *ArrayCreationExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayCreationExpressionContext) Array() antlr.TerminalNode {
	return s.GetToken(PhpParserArray, 0)
}

func (s *ArrayCreationExpressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ArrayCreationExpressionContext) ArrayItemList() IArrayItemListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArrayItemListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArrayItemListContext)
}

func (s *ArrayCreationExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterArrayCreationExpression(s)
	}
}

func (s *ArrayCreationExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitArrayCreationExpression(s)
	}
}

type ParenthesisExpressionContext struct {
	*ExpressionContext
}

func NewParenthesisExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ParenthesisExpressionContext {
	var p = new(ParenthesisExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *ParenthesisExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenthesisExpressionContext) Parenthesis() IParenthesisContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParenthesisContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParenthesisContext)
}

func (s *ParenthesisExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterParenthesisExpression(s)
	}
}

func (s *ParenthesisExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitParenthesisExpression(s)
	}
}

type BackQuoteStringExpressionContext struct {
	*ExpressionContext
}

func NewBackQuoteStringExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BackQuoteStringExpressionContext {
	var p = new(BackQuoteStringExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *BackQuoteStringExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BackQuoteStringExpressionContext) BackQuoteString() antlr.TerminalNode {
	return s.GetToken(PhpParserBackQuoteString, 0)
}

func (s *BackQuoteStringExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterBackQuoteStringExpression(s)
	}
}

func (s *BackQuoteStringExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitBackQuoteStringExpression(s)
	}
}

type ConditionalExpressionContext struct {
	*ExpressionContext
	op antlr.Token
}

func NewConditionalExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ConditionalExpressionContext {
	var p = new(ConditionalExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *ConditionalExpressionContext) GetOp() antlr.Token { return s.op }

func (s *ConditionalExpressionContext) SetOp(v antlr.Token) { s.op = v }

func (s *ConditionalExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConditionalExpressionContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *ConditionalExpressionContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ConditionalExpressionContext) QuestionMark() antlr.TerminalNode {
	return s.GetToken(PhpParserQuestionMark, 0)
}

func (s *ConditionalExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterConditionalExpression(s)
	}
}

func (s *ConditionalExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitConditionalExpression(s)
	}
}

type NewExprClauseContext struct {
	*ExpressionContext
}

func NewNewExprClauseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NewExprClauseContext {
	var p = new(NewExprClauseContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *NewExprClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NewExprClauseContext) NewExpr() INewExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INewExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INewExprContext)
}

func (s *NewExprClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterNewExprClause(s)
	}
}

func (s *NewExprClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitNewExprClause(s)
	}
}

type ArithmeticExpressionContext struct {
	*ExpressionContext
	op antlr.Token
}

func NewArithmeticExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArithmeticExpressionContext {
	var p = new(ArithmeticExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *ArithmeticExpressionContext) GetOp() antlr.Token { return s.op }

func (s *ArithmeticExpressionContext) SetOp(v antlr.Token) { s.op = v }

func (s *ArithmeticExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArithmeticExpressionContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *ArithmeticExpressionContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ArithmeticExpressionContext) Divide() antlr.TerminalNode {
	return s.GetToken(PhpParserDivide, 0)
}

func (s *ArithmeticExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterArithmeticExpression(s)
	}
}

func (s *ArithmeticExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitArithmeticExpression(s)
	}
}

type IndexerExpressionContext struct {
	*ExpressionContext
}

func NewIndexerExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IndexerExpressionContext {
	var p = new(IndexerExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *IndexerExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexerExpressionContext) StringConstant() IStringConstantContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStringConstantContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStringConstantContext)
}

func (s *IndexerExpressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IndexerExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterIndexerExpression(s)
	}
}

func (s *IndexerExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitIndexerExpression(s)
	}
}

type ScalarExpressionContext struct {
	*ExpressionContext
}

func NewScalarExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ScalarExpressionContext {
	var p = new(ScalarExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *ScalarExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScalarExpressionContext) Constant() IConstantContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstantContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *ScalarExpressionContext) Str() IStrContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStrContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStrContext)
}

func (s *ScalarExpressionContext) Label() antlr.TerminalNode {
	return s.GetToken(PhpParserLabel, 0)
}

func (s *ScalarExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterScalarExpression(s)
	}
}

func (s *ScalarExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitScalarExpression(s)
	}
}

type PrefixIncDecExpressionContext struct {
	*ExpressionContext
}

func NewPrefixIncDecExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PrefixIncDecExpressionContext {
	var p = new(PrefixIncDecExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *PrefixIncDecExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrefixIncDecExpressionContext) Chain() IChainContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IChainContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IChainContext)
}

func (s *PrefixIncDecExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterPrefixIncDecExpression(s)
	}
}

func (s *PrefixIncDecExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitPrefixIncDecExpression(s)
	}
}

type ComparisonExpressionContext struct {
	*ExpressionContext
	op antlr.Token
}

func NewComparisonExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ComparisonExpressionContext {
	var p = new(ComparisonExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *ComparisonExpressionContext) GetOp() antlr.Token { return s.op }

func (s *ComparisonExpressionContext) SetOp(v antlr.Token) { s.op = v }

func (s *ComparisonExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonExpressionContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *ComparisonExpressionContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ComparisonExpressionContext) Less() antlr.TerminalNode {
	return s.GetToken(PhpParserLess, 0)
}

func (s *ComparisonExpressionContext) Greater() antlr.TerminalNode {
	return s.GetToken(PhpParserGreater, 0)
}

func (s *ComparisonExpressionContext) IsNotEq() antlr.TerminalNode {
	return s.GetToken(PhpParserIsNotEq, 0)
}

func (s *ComparisonExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterComparisonExpression(s)
	}
}

func (s *ComparisonExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitComparisonExpression(s)
	}
}

type LogicalExpressionContext struct {
	*ExpressionContext
	op antlr.Token
}

func NewLogicalExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LogicalExpressionContext {
	var p = new(LogicalExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *LogicalExpressionContext) GetOp() antlr.Token { return s.op }

func (s *LogicalExpressionContext) SetOp(v antlr.Token) { s.op = v }

func (s *LogicalExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalExpressionContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *LogicalExpressionContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LogicalExpressionContext) LogicalAnd() antlr.TerminalNode {
	return s.GetToken(PhpParserLogicalAnd, 0)
}

func (s *LogicalExpressionContext) LogicalXor() antlr.TerminalNode {
	return s.GetToken(PhpParserLogicalXor, 0)
}

func (s *LogicalExpressionContext) LogicalOr() antlr.TerminalNode {
	return s.GetToken(PhpParserLogicalOr, 0)
}

func (s *LogicalExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterLogicalExpression(s)
	}
}

func (s *LogicalExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitLogicalExpression(s)
	}
}

type PrintExpressionContext struct {
	*ExpressionContext
}

func NewPrintExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PrintExpressionContext {
	var p = new(PrintExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *PrintExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrintExpressionContext) Print() antlr.TerminalNode {
	return s.GetToken(PhpParserPrint, 0)
}

func (s *PrintExpressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PrintExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterPrintExpression(s)
	}
}

func (s *PrintExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitPrintExpression(s)
	}
}

type AssignmentExpressionContext struct {
	*ExpressionContext
}

func NewAssignmentExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AssignmentExpressionContext {
	var p = new(AssignmentExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *AssignmentExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentExpressionContext) AllChain() []IChainContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IChainContext)(nil)).Elem())
	var tst = make([]IChainContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IChainContext)
		}
	}

	return tst
}

func (s *AssignmentExpressionContext) Chain(i int) IChainContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IChainContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IChainContext)
}

func (s *AssignmentExpressionContext) AssignmentOperator() IAssignmentOperatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignmentOperatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignmentOperatorContext)
}

func (s *AssignmentExpressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AssignmentExpressionContext) Eq() antlr.TerminalNode {
	return s.GetToken(PhpParserEq, 0)
}

func (s *AssignmentExpressionContext) NewExpr() INewExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INewExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INewExprContext)
}

func (s *AssignmentExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterAssignmentExpression(s)
	}
}

func (s *AssignmentExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitAssignmentExpression(s)
	}
}

type PostfixIncDecExpressionContext struct {
	*ExpressionContext
}

func NewPostfixIncDecExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PostfixIncDecExpressionContext {
	var p = new(PostfixIncDecExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *PostfixIncDecExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PostfixIncDecExpressionContext) Chain() IChainContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IChainContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IChainContext)
}

func (s *PostfixIncDecExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterPostfixIncDecExpression(s)
	}
}

func (s *PostfixIncDecExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitPostfixIncDecExpression(s)
	}
}

type CastExpressionContext struct {
	*ExpressionContext
}

func NewCastExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CastExpressionContext {
	var p = new(CastExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *CastExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CastExpressionContext) CastOperation() ICastOperationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICastOperationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICastOperationContext)
}

func (s *CastExpressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CastExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterCastExpression(s)
	}
}

func (s *CastExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitCastExpression(s)
	}
}

type InstanceOfExpressionContext struct {
	*ExpressionContext
}

func NewInstanceOfExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InstanceOfExpressionContext {
	var p = new(InstanceOfExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *InstanceOfExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InstanceOfExpressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *InstanceOfExpressionContext) InstanceOf() antlr.TerminalNode {
	return s.GetToken(PhpParserInstanceOf, 0)
}

func (s *InstanceOfExpressionContext) TypeRef() ITypeRefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeRefContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeRefContext)
}

func (s *InstanceOfExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterInstanceOfExpression(s)
	}
}

func (s *InstanceOfExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitInstanceOfExpression(s)
	}
}

type LambdaFunctionExpressionContext struct {
	*ExpressionContext
}

func NewLambdaFunctionExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LambdaFunctionExpressionContext {
	var p = new(LambdaFunctionExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *LambdaFunctionExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdaFunctionExpressionContext) Function() antlr.TerminalNode {
	return s.GetToken(PhpParserFunction, 0)
}

func (s *LambdaFunctionExpressionContext) FormalParameterList() IFormalParameterListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFormalParameterListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *LambdaFunctionExpressionContext) BlockStatement() IBlockStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockStatementContext)
}

func (s *LambdaFunctionExpressionContext) Static() antlr.TerminalNode {
	return s.GetToken(PhpParserStatic, 0)
}

func (s *LambdaFunctionExpressionContext) LambdaFunctionUseVars() ILambdaFunctionUseVarsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILambdaFunctionUseVarsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILambdaFunctionUseVarsContext)
}

func (s *LambdaFunctionExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterLambdaFunctionExpression(s)
	}
}

func (s *LambdaFunctionExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitLambdaFunctionExpression(s)
	}
}

type BitwiseExpressionContext struct {
	*ExpressionContext
	op antlr.Token
}

func NewBitwiseExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BitwiseExpressionContext {
	var p = new(BitwiseExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *BitwiseExpressionContext) GetOp() antlr.Token { return s.op }

func (s *BitwiseExpressionContext) SetOp(v antlr.Token) { s.op = v }

func (s *BitwiseExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitwiseExpressionContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *BitwiseExpressionContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *BitwiseExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterBitwiseExpression(s)
	}
}

func (s *BitwiseExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitBitwiseExpression(s)
	}
}

type CloneExpressionContext struct {
	*ExpressionContext
}

func NewCloneExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CloneExpressionContext {
	var p = new(CloneExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *CloneExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CloneExpressionContext) Clone() antlr.TerminalNode {
	return s.GetToken(PhpParserClone, 0)
}

func (s *CloneExpressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CloneExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterCloneExpression(s)
	}
}

func (s *CloneExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitCloneExpression(s)
	}
}

func (p *PhpParser) Expression() (localctx IExpressionContext) {
	return p.expression(0)
}

func (p *PhpParser) expression(_p int) (localctx IExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 166
	p.EnterRecursionRule(localctx, 166, PhpParserRULE_expression, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1200)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 119, p.GetParserRuleContext()) {
	case 1:
		localctx = NewCloneExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(1092)
			p.Match(PhpParserClone)
		}
		{
			p.SetState(1093)
			p.expression(43)
		}

	case 2:
		localctx = NewNewExprClauseContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1094)
			p.NewExpr()
		}

	case 3:
		localctx = NewIndexerExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1095)
			p.StringConstant()
		}
		{
			p.SetState(1096)
			p.Match(PhpParserOpenSquareBracket)
		}
		{
			p.SetState(1097)
			p.expression(0)
		}
		{
			p.SetState(1098)
			p.Match(PhpParserCloseSquareBracket)
		}

	case 4:
		localctx = NewCastExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1100)
			p.Match(PhpParserOpenRoundBracket)
		}
		{
			p.SetState(1101)
			p.CastOperation()
		}
		{
			p.SetState(1102)
			p.Match(PhpParserCloseRoundBracket)
		}
		{
			p.SetState(1103)
			p.expression(40)
		}

	case 5:
		localctx = NewUnaryOperatorExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1105)
			_la = p.GetTokenStream().LA(1)

			if !(_la == PhpParserTilde || _la == PhpParserSuppressWarnings) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1106)
			p.expression(39)
		}

	case 6:
		localctx = NewUnaryOperatorExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1107)
			_la = p.GetTokenStream().LA(1)

			if !(((_la-188)&-(0x1f+1)) == 0 && ((1<<uint((_la-188)))&((1<<(PhpParserBang-188))|(1<<(PhpParserPlus-188))|(1<<(PhpParserMinus-188)))) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1108)
			p.expression(38)
		}

	case 7:
		localctx = NewPrefixIncDecExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1109)
			_la = p.GetTokenStream().LA(1)

			if !(_la == PhpParserInc || _la == PhpParserDec) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1110)
			p.Chain()
		}

	case 8:
		localctx = NewPostfixIncDecExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1111)
			p.Chain()
		}
		{
			p.SetState(1112)
			_la = p.GetTokenStream().LA(1)

			if !(_la == PhpParserInc || _la == PhpParserDec) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 9:
		localctx = NewPrintExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1114)
			p.Match(PhpParserPrint)
		}
		{
			p.SetState(1115)
			p.expression(35)
		}

	case 10:
		localctx = NewChainExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1116)
			p.Chain()
		}

	case 11:
		localctx = NewScalarExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1117)
			p.Constant()
		}

	case 12:
		localctx = NewScalarExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1118)
			p.Str()
		}

	case 13:
		localctx = NewScalarExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1119)
			p.Match(PhpParserLabel)
		}

	case 14:
		localctx = NewBackQuoteStringExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1120)
			p.Match(PhpParserBackQuoteString)
		}

	case 15:
		localctx = NewParenthesisExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1121)
			p.Parenthesis()
		}

	case 16:
		localctx = NewArrayCreationExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		p.SetState(1133)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case PhpParserArray:
			{
				p.SetState(1122)
				p.Match(PhpParserArray)
			}
			{
				p.SetState(1123)
				p.Match(PhpParserOpenRoundBracket)
			}
			p.SetState(1125)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if (((_la-43)&-(0x1f+1)) == 0 && ((1<<uint((_la-43)))&((1<<(PhpParserAbstract-43))|(1<<(PhpParserArray-43))|(1<<(PhpParserAs-43))|(1<<(PhpParserBinaryCast-43))|(1<<(PhpParserBoolType-43))|(1<<(PhpParserBooleanConstant-43))|(1<<(PhpParserBreak-43))|(1<<(PhpParserCallable-43))|(1<<(PhpParserCase-43))|(1<<(PhpParserCatch-43))|(1<<(PhpParserClass-43))|(1<<(PhpParserClone-43))|(1<<(PhpParserConst-43))|(1<<(PhpParserContinue-43))|(1<<(PhpParserDeclare-43))|(1<<(PhpParserDefault-43))|(1<<(PhpParserDo-43))|(1<<(PhpParserDoubleCast-43))|(1<<(PhpParserDoubleType-43))|(1<<(PhpParserEcho-43))|(1<<(PhpParserElse-43))|(1<<(PhpParserElseIf-43))|(1<<(PhpParserEmpty-43))|(1<<(PhpParserEndDeclare-43))|(1<<(PhpParserEndFor-43))|(1<<(PhpParserEndForeach-43))|(1<<(PhpParserEndIf-43))|(1<<(PhpParserEndSwitch-43))|(1<<(PhpParserEndWhile-43))|(1<<(PhpParserEval-43))|(1<<(PhpParserExit-43))|(1<<(PhpParserExtends-43)))) != 0) || (((_la-75)&-(0x1f+1)) == 0 && ((1<<uint((_la-75)))&((1<<(PhpParserFinal-75))|(1<<(PhpParserFinally-75))|(1<<(PhpParserFloatCast-75))|(1<<(PhpParserFor-75))|(1<<(PhpParserForeach-75))|(1<<(PhpParserFunction-75))|(1<<(PhpParserGlobal-75))|(1<<(PhpParserGoto-75))|(1<<(PhpParserIf-75))|(1<<(PhpParserImplements-75))|(1<<(PhpParserImport-75))|(1<<(PhpParserInclude-75))|(1<<(PhpParserIncludeOnce-75))|(1<<(PhpParserInstanceOf-75))|(1<<(PhpParserInsteadOf-75))|(1<<(PhpParserInt8Cast-75))|(1<<(PhpParserInt16Cast-75))|(1<<(PhpParserInt64Type-75))|(1<<(PhpParserIntType-75))|(1<<(PhpParserInterface-75))|(1<<(PhpParserIsSet-75))|(1<<(PhpParserList-75))|(1<<(PhpParserLogicalAnd-75))|(1<<(PhpParserLogicalOr-75))|(1<<(PhpParserLogicalXor-75))|(1<<(PhpParserNamespace-75))|(1<<(PhpParserNew-75))|(1<<(PhpParserNull-75))|(1<<(PhpParserObjectType-75))|(1<<(PhpParserParent_-75))|(1<<(PhpParserPartial-75))|(1<<(PhpParserPrint-75)))) != 0) || (((_la-107)&-(0x1f+1)) == 0 && ((1<<uint((_la-107)))&((1<<(PhpParserPrivate-107))|(1<<(PhpParserProtected-107))|(1<<(PhpParserPublic-107))|(1<<(PhpParserRequire-107))|(1<<(PhpParserRequireOnce-107))|(1<<(PhpParserResource-107))|(1<<(PhpParserReturn-107))|(1<<(PhpParserStatic-107))|(1<<(PhpParserStringType-107))|(1<<(PhpParserSwitch-107))|(1<<(PhpParserThrow-107))|(1<<(PhpParserTrait-107))|(1<<(PhpParserTry-107))|(1<<(PhpParserTypeof-107))|(1<<(PhpParserUintCast-107))|(1<<(PhpParserUnicodeCast-107))|(1<<(PhpParserUnset-107))|(1<<(PhpParserUse-107))|(1<<(PhpParserVar-107))|(1<<(PhpParserWhile-107))|(1<<(PhpParserYield-107))|(1<<(PhpParserGet-107))|(1<<(PhpParserSet-107))|(1<<(PhpParserCall-107))|(1<<(PhpParserCallStatic-107))|(1<<(PhpParserConstructor-107))|(1<<(PhpParserDestruct-107))|(1<<(PhpParserWakeup-107))|(1<<(PhpParserSleep-107))|(1<<(PhpParserAutoload-107))|(1<<(PhpParserIsSet__-107))|(1<<(PhpParserUnset__-107)))) != 0) || (((_la-139)&-(0x1f+1)) == 0 && ((1<<uint((_la-139)))&((1<<(PhpParserToString__-139))|(1<<(PhpParserInvoke-139))|(1<<(PhpParserSetState-139))|(1<<(PhpParserClone__-139))|(1<<(PhpParserDebugInfo-139))|(1<<(PhpParserNamespace__-139))|(1<<(PhpParserClass__-139))|(1<<(PhpParserTraic__-139))|(1<<(PhpParserFunction__-139))|(1<<(PhpParserMethod__-139))|(1<<(PhpParserLine__-139))|(1<<(PhpParserFile__-139))|(1<<(PhpParserDir__-139))|(1<<(PhpParserInc-139))|(1<<(PhpParserDec-139)))) != 0) || (((_la-182)&-(0x1f+1)) == 0 && ((1<<uint((_la-182)))&((1<<(PhpParserNamespaceSeparator-182))|(1<<(PhpParserAmpersand-182))|(1<<(PhpParserBang-182))|(1<<(PhpParserPlus-182))|(1<<(PhpParserMinus-182))|(1<<(PhpParserTilde-182))|(1<<(PhpParserSuppressWarnings-182))|(1<<(PhpParserDollar-182))|(1<<(PhpParserOpenRoundBracket-182))|(1<<(PhpParserOpenSquareBracket-182))|(1<<(PhpParserVarName-182))|(1<<(PhpParserLabel-182)))) != 0) || (((_la-214)&-(0x1f+1)) == 0 && ((1<<uint((_la-214)))&((1<<(PhpParserOctal-214))|(1<<(PhpParserDecimal-214))|(1<<(PhpParserReal-214))|(1<<(PhpParserHex-214))|(1<<(PhpParserBinary-214))|(1<<(PhpParserBackQuoteString-214))|(1<<(PhpParserSingleQuoteString-214))|(1<<(PhpParserDoubleQuote-214))|(1<<(PhpParserStartNowDoc-214))|(1<<(PhpParserStartHereDoc-214)))) != 0) {
				{
					p.SetState(1124)
					p.ArrayItemList()
				}

			}
			{
				p.SetState(1127)
				p.Match(PhpParserCloseRoundBracket)
			}

		case PhpParserOpenSquareBracket:
			{
				p.SetState(1128)
				p.Match(PhpParserOpenSquareBracket)
			}
			p.SetState(1130)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if (((_la-43)&-(0x1f+1)) == 0 && ((1<<uint((_la-43)))&((1<<(PhpParserAbstract-43))|(1<<(PhpParserArray-43))|(1<<(PhpParserAs-43))|(1<<(PhpParserBinaryCast-43))|(1<<(PhpParserBoolType-43))|(1<<(PhpParserBooleanConstant-43))|(1<<(PhpParserBreak-43))|(1<<(PhpParserCallable-43))|(1<<(PhpParserCase-43))|(1<<(PhpParserCatch-43))|(1<<(PhpParserClass-43))|(1<<(PhpParserClone-43))|(1<<(PhpParserConst-43))|(1<<(PhpParserContinue-43))|(1<<(PhpParserDeclare-43))|(1<<(PhpParserDefault-43))|(1<<(PhpParserDo-43))|(1<<(PhpParserDoubleCast-43))|(1<<(PhpParserDoubleType-43))|(1<<(PhpParserEcho-43))|(1<<(PhpParserElse-43))|(1<<(PhpParserElseIf-43))|(1<<(PhpParserEmpty-43))|(1<<(PhpParserEndDeclare-43))|(1<<(PhpParserEndFor-43))|(1<<(PhpParserEndForeach-43))|(1<<(PhpParserEndIf-43))|(1<<(PhpParserEndSwitch-43))|(1<<(PhpParserEndWhile-43))|(1<<(PhpParserEval-43))|(1<<(PhpParserExit-43))|(1<<(PhpParserExtends-43)))) != 0) || (((_la-75)&-(0x1f+1)) == 0 && ((1<<uint((_la-75)))&((1<<(PhpParserFinal-75))|(1<<(PhpParserFinally-75))|(1<<(PhpParserFloatCast-75))|(1<<(PhpParserFor-75))|(1<<(PhpParserForeach-75))|(1<<(PhpParserFunction-75))|(1<<(PhpParserGlobal-75))|(1<<(PhpParserGoto-75))|(1<<(PhpParserIf-75))|(1<<(PhpParserImplements-75))|(1<<(PhpParserImport-75))|(1<<(PhpParserInclude-75))|(1<<(PhpParserIncludeOnce-75))|(1<<(PhpParserInstanceOf-75))|(1<<(PhpParserInsteadOf-75))|(1<<(PhpParserInt8Cast-75))|(1<<(PhpParserInt16Cast-75))|(1<<(PhpParserInt64Type-75))|(1<<(PhpParserIntType-75))|(1<<(PhpParserInterface-75))|(1<<(PhpParserIsSet-75))|(1<<(PhpParserList-75))|(1<<(PhpParserLogicalAnd-75))|(1<<(PhpParserLogicalOr-75))|(1<<(PhpParserLogicalXor-75))|(1<<(PhpParserNamespace-75))|(1<<(PhpParserNew-75))|(1<<(PhpParserNull-75))|(1<<(PhpParserObjectType-75))|(1<<(PhpParserParent_-75))|(1<<(PhpParserPartial-75))|(1<<(PhpParserPrint-75)))) != 0) || (((_la-107)&-(0x1f+1)) == 0 && ((1<<uint((_la-107)))&((1<<(PhpParserPrivate-107))|(1<<(PhpParserProtected-107))|(1<<(PhpParserPublic-107))|(1<<(PhpParserRequire-107))|(1<<(PhpParserRequireOnce-107))|(1<<(PhpParserResource-107))|(1<<(PhpParserReturn-107))|(1<<(PhpParserStatic-107))|(1<<(PhpParserStringType-107))|(1<<(PhpParserSwitch-107))|(1<<(PhpParserThrow-107))|(1<<(PhpParserTrait-107))|(1<<(PhpParserTry-107))|(1<<(PhpParserTypeof-107))|(1<<(PhpParserUintCast-107))|(1<<(PhpParserUnicodeCast-107))|(1<<(PhpParserUnset-107))|(1<<(PhpParserUse-107))|(1<<(PhpParserVar-107))|(1<<(PhpParserWhile-107))|(1<<(PhpParserYield-107))|(1<<(PhpParserGet-107))|(1<<(PhpParserSet-107))|(1<<(PhpParserCall-107))|(1<<(PhpParserCallStatic-107))|(1<<(PhpParserConstructor-107))|(1<<(PhpParserDestruct-107))|(1<<(PhpParserWakeup-107))|(1<<(PhpParserSleep-107))|(1<<(PhpParserAutoload-107))|(1<<(PhpParserIsSet__-107))|(1<<(PhpParserUnset__-107)))) != 0) || (((_la-139)&-(0x1f+1)) == 0 && ((1<<uint((_la-139)))&((1<<(PhpParserToString__-139))|(1<<(PhpParserInvoke-139))|(1<<(PhpParserSetState-139))|(1<<(PhpParserClone__-139))|(1<<(PhpParserDebugInfo-139))|(1<<(PhpParserNamespace__-139))|(1<<(PhpParserClass__-139))|(1<<(PhpParserTraic__-139))|(1<<(PhpParserFunction__-139))|(1<<(PhpParserMethod__-139))|(1<<(PhpParserLine__-139))|(1<<(PhpParserFile__-139))|(1<<(PhpParserDir__-139))|(1<<(PhpParserInc-139))|(1<<(PhpParserDec-139)))) != 0) || (((_la-182)&-(0x1f+1)) == 0 && ((1<<uint((_la-182)))&((1<<(PhpParserNamespaceSeparator-182))|(1<<(PhpParserAmpersand-182))|(1<<(PhpParserBang-182))|(1<<(PhpParserPlus-182))|(1<<(PhpParserMinus-182))|(1<<(PhpParserTilde-182))|(1<<(PhpParserSuppressWarnings-182))|(1<<(PhpParserDollar-182))|(1<<(PhpParserOpenRoundBracket-182))|(1<<(PhpParserOpenSquareBracket-182))|(1<<(PhpParserVarName-182))|(1<<(PhpParserLabel-182)))) != 0) || (((_la-214)&-(0x1f+1)) == 0 && ((1<<uint((_la-214)))&((1<<(PhpParserOctal-214))|(1<<(PhpParserDecimal-214))|(1<<(PhpParserReal-214))|(1<<(PhpParserHex-214))|(1<<(PhpParserBinary-214))|(1<<(PhpParserBackQuoteString-214))|(1<<(PhpParserSingleQuoteString-214))|(1<<(PhpParserDoubleQuote-214))|(1<<(PhpParserStartNowDoc-214))|(1<<(PhpParserStartHereDoc-214)))) != 0) {
				{
					p.SetState(1129)
					p.ArrayItemList()
				}

			}
			{
				p.SetState(1132)
				p.Match(PhpParserCloseSquareBracket)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		p.SetState(1139)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 113, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1135)
				p.Match(PhpParserOpenSquareBracket)
			}
			{
				p.SetState(1136)
				p.expression(0)
			}
			{
				p.SetState(1137)
				p.Match(PhpParserCloseSquareBracket)
			}

		}

	case 17:
		localctx = NewSpecialWordExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1141)
			p.Match(PhpParserYield)
		}

	case 18:
		localctx = NewSpecialWordExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1142)
			p.Match(PhpParserList)
		}
		{
			p.SetState(1143)
			p.Match(PhpParserOpenRoundBracket)
		}
		{
			p.SetState(1144)
			p.AssignmentList()
		}
		{
			p.SetState(1145)
			p.Match(PhpParserCloseRoundBracket)
		}
		{
			p.SetState(1146)
			p.Match(PhpParserEq)
		}
		{
			p.SetState(1147)
			p.expression(26)
		}

	case 19:
		localctx = NewSpecialWordExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1149)
			p.Match(PhpParserIsSet)
		}
		{
			p.SetState(1150)
			p.Match(PhpParserOpenRoundBracket)
		}
		{
			p.SetState(1151)
			p.ChainList()
		}
		{
			p.SetState(1152)
			p.Match(PhpParserCloseRoundBracket)
		}

	case 20:
		localctx = NewSpecialWordExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1154)
			p.Match(PhpParserEmpty)
		}
		{
			p.SetState(1155)
			p.Match(PhpParserOpenRoundBracket)
		}
		{
			p.SetState(1156)
			p.Chain()
		}
		{
			p.SetState(1157)
			p.Match(PhpParserCloseRoundBracket)
		}

	case 21:
		localctx = NewSpecialWordExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1159)
			p.Match(PhpParserEval)
		}
		{
			p.SetState(1160)
			p.Match(PhpParserOpenRoundBracket)
		}
		{
			p.SetState(1161)
			p.expression(0)
		}
		{
			p.SetState(1162)
			p.Match(PhpParserCloseRoundBracket)
		}

	case 22:
		localctx = NewSpecialWordExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1164)
			p.Match(PhpParserExit)
		}
		p.SetState(1168)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 114, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1165)
				p.Match(PhpParserOpenRoundBracket)
			}
			{
				p.SetState(1166)
				p.Match(PhpParserCloseRoundBracket)
			}

		} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 114, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(1167)
				p.Parenthesis()
			}

		}

	case 23:
		localctx = NewSpecialWordExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1170)
			_la = p.GetTokenStream().LA(1)

			if !(_la == PhpParserInclude || _la == PhpParserIncludeOnce) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1171)
			p.expression(21)
		}

	case 24:
		localctx = NewSpecialWordExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1172)
			_la = p.GetTokenStream().LA(1)

			if !(_la == PhpParserRequire || _la == PhpParserRequireOnce) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1173)
			p.expression(20)
		}

	case 25:
		localctx = NewLambdaFunctionExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		p.SetState(1175)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PhpParserStatic {
			{
				p.SetState(1174)
				p.Match(PhpParserStatic)
			}

		}
		{
			p.SetState(1177)
			p.Match(PhpParserFunction)
		}
		p.SetState(1179)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PhpParserAmpersand {
			{
				p.SetState(1178)
				p.Match(PhpParserAmpersand)
			}

		}
		{
			p.SetState(1181)
			p.Match(PhpParserOpenRoundBracket)
		}
		{
			p.SetState(1182)
			p.FormalParameterList()
		}
		{
			p.SetState(1183)
			p.Match(PhpParserCloseRoundBracket)
		}
		p.SetState(1185)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PhpParserUse {
			{
				p.SetState(1184)
				p.LambdaFunctionUseVars()
			}

		}
		{
			p.SetState(1187)
			p.BlockStatement()
		}

	case 26:
		localctx = NewAssignmentExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1189)
			p.Chain()
		}
		{
			p.SetState(1190)
			p.AssignmentOperator()
		}
		{
			p.SetState(1191)
			p.expression(5)
		}

	case 27:
		localctx = NewAssignmentExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1193)
			p.Chain()
		}
		{
			p.SetState(1194)
			p.Match(PhpParserEq)
		}
		{
			p.SetState(1195)
			p.Match(PhpParserAmpersand)
		}
		p.SetState(1198)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 118, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1196)
				p.Chain()
			}

		case 2:
			{
				p.SetState(1197)
				p.NewExpr()
			}

		}

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1256)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 122, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(1254)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 121, p.GetParserRuleContext()) {
			case 1:
				localctx = NewArithmeticExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, PhpParserRULE_expression)
				p.SetState(1202)

				if !(p.Precpred(p.GetParserRuleContext(), 18)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 18)", ""))
				}
				{
					p.SetState(1203)
					p.Match(PhpParserPow)
				}
				{
					p.SetState(1204)
					p.expression(18)
				}

			case 2:
				localctx = NewArithmeticExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, PhpParserRULE_expression)
				p.SetState(1205)

				if !(p.Precpred(p.GetParserRuleContext(), 16)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 16)", ""))
				}
				{
					p.SetState(1206)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ArithmeticExpressionContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(((_la-192)&-(0x1f+1)) == 0 && ((1<<uint((_la-192)))&((1<<(PhpParserAsterisk-192))|(1<<(PhpParserPercent-192))|(1<<(PhpParserDivide-192)))) != 0) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ArithmeticExpressionContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1207)
					p.expression(17)
				}

			case 3:
				localctx = NewArithmeticExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, PhpParserRULE_expression)
				p.SetState(1208)

				if !(p.Precpred(p.GetParserRuleContext(), 15)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 15)", ""))
				}
				{
					p.SetState(1209)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ArithmeticExpressionContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(((_la-190)&-(0x1f+1)) == 0 && ((1<<uint((_la-190)))&((1<<(PhpParserPlus-190))|(1<<(PhpParserMinus-190))|(1<<(PhpParserDot-190)))) != 0) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ArithmeticExpressionContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1210)
					p.expression(16)
				}

			case 4:
				localctx = NewComparisonExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, PhpParserRULE_expression)
				p.SetState(1211)

				if !(p.Precpred(p.GetParserRuleContext(), 14)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 14)", ""))
				}
				{
					p.SetState(1212)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ComparisonExpressionContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == PhpParserShiftLeft || _la == PhpParserShiftRight) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ComparisonExpressionContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1213)
					p.expression(15)
				}

			case 5:
				localctx = NewComparisonExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, PhpParserRULE_expression)
				p.SetState(1214)

				if !(p.Precpred(p.GetParserRuleContext(), 13)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 13)", ""))
				}
				{
					p.SetState(1215)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ComparisonExpressionContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(((_la-161)&-(0x1f+1)) == 0 && ((1<<uint((_la-161)))&((1<<(PhpParserIsSmallerOrEqual-161))|(1<<(PhpParserIsGreaterOrEqual-161))|(1<<(PhpParserLess-161))|(1<<(PhpParserGreater-161)))) != 0) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ComparisonExpressionContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1216)
					p.expression(14)
				}

			case 6:
				localctx = NewComparisonExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, PhpParserRULE_expression)
				p.SetState(1217)

				if !(p.Precpred(p.GetParserRuleContext(), 12)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 12)", ""))
				}
				{
					p.SetState(1218)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ComparisonExpressionContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(((_la-157)&-(0x1f+1)) == 0 && ((1<<uint((_la-157)))&((1<<(PhpParserIsIdentical-157))|(1<<(PhpParserIsNoidentical-157))|(1<<(PhpParserIsEqual-157))|(1<<(PhpParserIsNotEq-157)))) != 0) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ComparisonExpressionContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1219)
					p.expression(13)
				}

			case 7:
				localctx = NewBitwiseExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, PhpParserRULE_expression)
				p.SetState(1220)

				if !(p.Precpred(p.GetParserRuleContext(), 11)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 11)", ""))
				}
				{
					p.SetState(1221)

					var _m = p.Match(PhpParserAmpersand)

					localctx.(*BitwiseExpressionContext).op = _m
				}
				{
					p.SetState(1222)
					p.expression(12)
				}

			case 8:
				localctx = NewBitwiseExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, PhpParserRULE_expression)
				p.SetState(1223)

				if !(p.Precpred(p.GetParserRuleContext(), 10)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 10)", ""))
				}
				{
					p.SetState(1224)

					var _m = p.Match(PhpParserCaret)

					localctx.(*BitwiseExpressionContext).op = _m
				}
				{
					p.SetState(1225)
					p.expression(11)
				}

			case 9:
				localctx = NewBitwiseExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, PhpParserRULE_expression)
				p.SetState(1226)

				if !(p.Precpred(p.GetParserRuleContext(), 9)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 9)", ""))
				}
				{
					p.SetState(1227)

					var _m = p.Match(PhpParserPipe)

					localctx.(*BitwiseExpressionContext).op = _m
				}
				{
					p.SetState(1228)
					p.expression(10)
				}

			case 10:
				localctx = NewBitwiseExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, PhpParserRULE_expression)
				p.SetState(1229)

				if !(p.Precpred(p.GetParserRuleContext(), 8)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 8)", ""))
				}
				{
					p.SetState(1230)

					var _m = p.Match(PhpParserBooleanAnd)

					localctx.(*BitwiseExpressionContext).op = _m
				}
				{
					p.SetState(1231)
					p.expression(9)
				}

			case 11:
				localctx = NewBitwiseExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, PhpParserRULE_expression)
				p.SetState(1232)

				if !(p.Precpred(p.GetParserRuleContext(), 7)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 7)", ""))
				}
				{
					p.SetState(1233)

					var _m = p.Match(PhpParserBooleanOr)

					localctx.(*BitwiseExpressionContext).op = _m
				}
				{
					p.SetState(1234)
					p.expression(8)
				}

			case 12:
				localctx = NewConditionalExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, PhpParserRULE_expression)
				p.SetState(1235)

				if !(p.Precpred(p.GetParserRuleContext(), 6)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 6)", ""))
				}
				{
					p.SetState(1236)

					var _m = p.Match(PhpParserQuestionMark)

					localctx.(*ConditionalExpressionContext).op = _m
				}
				p.SetState(1238)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if (((_la-43)&-(0x1f+1)) == 0 && ((1<<uint((_la-43)))&((1<<(PhpParserAbstract-43))|(1<<(PhpParserArray-43))|(1<<(PhpParserAs-43))|(1<<(PhpParserBinaryCast-43))|(1<<(PhpParserBoolType-43))|(1<<(PhpParserBooleanConstant-43))|(1<<(PhpParserBreak-43))|(1<<(PhpParserCallable-43))|(1<<(PhpParserCase-43))|(1<<(PhpParserCatch-43))|(1<<(PhpParserClass-43))|(1<<(PhpParserClone-43))|(1<<(PhpParserConst-43))|(1<<(PhpParserContinue-43))|(1<<(PhpParserDeclare-43))|(1<<(PhpParserDefault-43))|(1<<(PhpParserDo-43))|(1<<(PhpParserDoubleCast-43))|(1<<(PhpParserDoubleType-43))|(1<<(PhpParserEcho-43))|(1<<(PhpParserElse-43))|(1<<(PhpParserElseIf-43))|(1<<(PhpParserEmpty-43))|(1<<(PhpParserEndDeclare-43))|(1<<(PhpParserEndFor-43))|(1<<(PhpParserEndForeach-43))|(1<<(PhpParserEndIf-43))|(1<<(PhpParserEndSwitch-43))|(1<<(PhpParserEndWhile-43))|(1<<(PhpParserEval-43))|(1<<(PhpParserExit-43))|(1<<(PhpParserExtends-43)))) != 0) || (((_la-75)&-(0x1f+1)) == 0 && ((1<<uint((_la-75)))&((1<<(PhpParserFinal-75))|(1<<(PhpParserFinally-75))|(1<<(PhpParserFloatCast-75))|(1<<(PhpParserFor-75))|(1<<(PhpParserForeach-75))|(1<<(PhpParserFunction-75))|(1<<(PhpParserGlobal-75))|(1<<(PhpParserGoto-75))|(1<<(PhpParserIf-75))|(1<<(PhpParserImplements-75))|(1<<(PhpParserImport-75))|(1<<(PhpParserInclude-75))|(1<<(PhpParserIncludeOnce-75))|(1<<(PhpParserInstanceOf-75))|(1<<(PhpParserInsteadOf-75))|(1<<(PhpParserInt8Cast-75))|(1<<(PhpParserInt16Cast-75))|(1<<(PhpParserInt64Type-75))|(1<<(PhpParserIntType-75))|(1<<(PhpParserInterface-75))|(1<<(PhpParserIsSet-75))|(1<<(PhpParserList-75))|(1<<(PhpParserLogicalAnd-75))|(1<<(PhpParserLogicalOr-75))|(1<<(PhpParserLogicalXor-75))|(1<<(PhpParserNamespace-75))|(1<<(PhpParserNew-75))|(1<<(PhpParserNull-75))|(1<<(PhpParserObjectType-75))|(1<<(PhpParserParent_-75))|(1<<(PhpParserPartial-75))|(1<<(PhpParserPrint-75)))) != 0) || (((_la-107)&-(0x1f+1)) == 0 && ((1<<uint((_la-107)))&((1<<(PhpParserPrivate-107))|(1<<(PhpParserProtected-107))|(1<<(PhpParserPublic-107))|(1<<(PhpParserRequire-107))|(1<<(PhpParserRequireOnce-107))|(1<<(PhpParserResource-107))|(1<<(PhpParserReturn-107))|(1<<(PhpParserStatic-107))|(1<<(PhpParserStringType-107))|(1<<(PhpParserSwitch-107))|(1<<(PhpParserThrow-107))|(1<<(PhpParserTrait-107))|(1<<(PhpParserTry-107))|(1<<(PhpParserTypeof-107))|(1<<(PhpParserUintCast-107))|(1<<(PhpParserUnicodeCast-107))|(1<<(PhpParserUnset-107))|(1<<(PhpParserUse-107))|(1<<(PhpParserVar-107))|(1<<(PhpParserWhile-107))|(1<<(PhpParserYield-107))|(1<<(PhpParserGet-107))|(1<<(PhpParserSet-107))|(1<<(PhpParserCall-107))|(1<<(PhpParserCallStatic-107))|(1<<(PhpParserConstructor-107))|(1<<(PhpParserDestruct-107))|(1<<(PhpParserWakeup-107))|(1<<(PhpParserSleep-107))|(1<<(PhpParserAutoload-107))|(1<<(PhpParserIsSet__-107))|(1<<(PhpParserUnset__-107)))) != 0) || (((_la-139)&-(0x1f+1)) == 0 && ((1<<uint((_la-139)))&((1<<(PhpParserToString__-139))|(1<<(PhpParserInvoke-139))|(1<<(PhpParserSetState-139))|(1<<(PhpParserClone__-139))|(1<<(PhpParserDebugInfo-139))|(1<<(PhpParserNamespace__-139))|(1<<(PhpParserClass__-139))|(1<<(PhpParserTraic__-139))|(1<<(PhpParserFunction__-139))|(1<<(PhpParserMethod__-139))|(1<<(PhpParserLine__-139))|(1<<(PhpParserFile__-139))|(1<<(PhpParserDir__-139))|(1<<(PhpParserInc-139))|(1<<(PhpParserDec-139)))) != 0) || (((_la-182)&-(0x1f+1)) == 0 && ((1<<uint((_la-182)))&((1<<(PhpParserNamespaceSeparator-182))|(1<<(PhpParserBang-182))|(1<<(PhpParserPlus-182))|(1<<(PhpParserMinus-182))|(1<<(PhpParserTilde-182))|(1<<(PhpParserSuppressWarnings-182))|(1<<(PhpParserDollar-182))|(1<<(PhpParserOpenRoundBracket-182))|(1<<(PhpParserOpenSquareBracket-182))|(1<<(PhpParserVarName-182))|(1<<(PhpParserLabel-182)))) != 0) || (((_la-214)&-(0x1f+1)) == 0 && ((1<<uint((_la-214)))&((1<<(PhpParserOctal-214))|(1<<(PhpParserDecimal-214))|(1<<(PhpParserReal-214))|(1<<(PhpParserHex-214))|(1<<(PhpParserBinary-214))|(1<<(PhpParserBackQuoteString-214))|(1<<(PhpParserSingleQuoteString-214))|(1<<(PhpParserDoubleQuote-214))|(1<<(PhpParserStartNowDoc-214))|(1<<(PhpParserStartHereDoc-214)))) != 0) {
					{
						p.SetState(1237)
						p.expression(0)
					}

				}
				{
					p.SetState(1240)
					p.Match(PhpParserColon)
				}
				{
					p.SetState(1241)
					p.expression(7)
				}

			case 13:
				localctx = NewLogicalExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, PhpParserRULE_expression)
				p.SetState(1242)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
				}
				{
					p.SetState(1243)

					var _m = p.Match(PhpParserLogicalAnd)

					localctx.(*LogicalExpressionContext).op = _m
				}
				{
					p.SetState(1244)
					p.expression(4)
				}

			case 14:
				localctx = NewLogicalExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, PhpParserRULE_expression)
				p.SetState(1245)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				}
				{
					p.SetState(1246)

					var _m = p.Match(PhpParserLogicalXor)

					localctx.(*LogicalExpressionContext).op = _m
				}
				{
					p.SetState(1247)
					p.expression(3)
				}

			case 15:
				localctx = NewLogicalExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, PhpParserRULE_expression)
				p.SetState(1248)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				}
				{
					p.SetState(1249)

					var _m = p.Match(PhpParserLogicalOr)

					localctx.(*LogicalExpressionContext).op = _m
				}
				{
					p.SetState(1250)
					p.expression(2)
				}

			case 16:
				localctx = NewInstanceOfExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, PhpParserRULE_expression)
				p.SetState(1251)

				if !(p.Precpred(p.GetParserRuleContext(), 17)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 17)", ""))
				}
				{
					p.SetState(1252)
					p.Match(PhpParserInstanceOf)
				}
				{
					p.SetState(1253)
					p.TypeRef()
				}

			}

		}
		p.SetState(1258)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 122, p.GetParserRuleContext())
	}

	return localctx
}

// INewExprContext is an interface to support dynamic dispatch.
type INewExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNewExprContext differentiates from other interfaces.
	IsNewExprContext()
}

type NewExprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNewExprContext() *NewExprContext {
	var p = new(NewExprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_newExpr
	return p
}

func (*NewExprContext) IsNewExprContext() {}

func NewNewExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NewExprContext {
	var p = new(NewExprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_newExpr

	return p
}

func (s *NewExprContext) GetParser() antlr.Parser { return s.parser }

func (s *NewExprContext) New() antlr.TerminalNode {
	return s.GetToken(PhpParserNew, 0)
}

func (s *NewExprContext) TypeRef() ITypeRefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeRefContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeRefContext)
}

func (s *NewExprContext) Arguments() IArgumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArgumentsContext)
}

func (s *NewExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NewExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NewExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterNewExpr(s)
	}
}

func (s *NewExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitNewExpr(s)
	}
}

func (p *PhpParser) NewExpr() (localctx INewExprContext) {
	localctx = NewNewExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, PhpParserRULE_newExpr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1259)
		p.Match(PhpParserNew)
	}
	{
		p.SetState(1260)
		p.TypeRef()
	}
	p.SetState(1262)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 123, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1261)
			p.Arguments()
		}

	}

	return localctx
}

// IAssignmentOperatorContext is an interface to support dynamic dispatch.
type IAssignmentOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssignmentOperatorContext differentiates from other interfaces.
	IsAssignmentOperatorContext()
}

type AssignmentOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentOperatorContext() *AssignmentOperatorContext {
	var p = new(AssignmentOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_assignmentOperator
	return p
}

func (*AssignmentOperatorContext) IsAssignmentOperatorContext() {}

func NewAssignmentOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentOperatorContext {
	var p = new(AssignmentOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_assignmentOperator

	return p
}

func (s *AssignmentOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentOperatorContext) Eq() antlr.TerminalNode {
	return s.GetToken(PhpParserEq, 0)
}

func (s *AssignmentOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterAssignmentOperator(s)
	}
}

func (s *AssignmentOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitAssignmentOperator(s)
	}
}

func (p *PhpParser) AssignmentOperator() (localctx IAssignmentOperatorContext) {
	localctx = NewAssignmentOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, PhpParserRULE_assignmentOperator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1264)
		_la = p.GetTokenStream().LA(1)

		if !((((_la-163)&-(0x1f+1)) == 0 && ((1<<uint((_la-163)))&((1<<(PhpParserPlusEqual-163))|(1<<(PhpParserMinusEqual-163))|(1<<(PhpParserMulEqual-163))|(1<<(PhpParserPowEqual-163))|(1<<(PhpParserDivEqual-163))|(1<<(PhpParserConcaequal-163))|(1<<(PhpParserModEqual-163))|(1<<(PhpParserShiftLeftEqual-163))|(1<<(PhpParserShiftRightEqual-163))|(1<<(PhpParserAndEqual-163))|(1<<(PhpParserOrEqual-163))|(1<<(PhpParserXorEqual-163)))) != 0) || _la == PhpParserEq) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IYieldExpressionContext is an interface to support dynamic dispatch.
type IYieldExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsYieldExpressionContext differentiates from other interfaces.
	IsYieldExpressionContext()
}

type YieldExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyYieldExpressionContext() *YieldExpressionContext {
	var p = new(YieldExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_yieldExpression
	return p
}

func (*YieldExpressionContext) IsYieldExpressionContext() {}

func NewYieldExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *YieldExpressionContext {
	var p = new(YieldExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_yieldExpression

	return p
}

func (s *YieldExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *YieldExpressionContext) Yield() antlr.TerminalNode {
	return s.GetToken(PhpParserYield, 0)
}

func (s *YieldExpressionContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *YieldExpressionContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *YieldExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *YieldExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *YieldExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterYieldExpression(s)
	}
}

func (s *YieldExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitYieldExpression(s)
	}
}

func (p *PhpParser) YieldExpression() (localctx IYieldExpressionContext) {
	localctx = NewYieldExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, PhpParserRULE_yieldExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1266)
		p.Match(PhpParserYield)
	}
	{
		p.SetState(1267)
		p.expression(0)
	}
	p.SetState(1270)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PhpParserDoubleArrow {
		{
			p.SetState(1268)
			p.Match(PhpParserDoubleArrow)
		}
		{
			p.SetState(1269)
			p.expression(0)
		}

	}

	return localctx
}

// IArrayItemListContext is an interface to support dynamic dispatch.
type IArrayItemListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArrayItemListContext differentiates from other interfaces.
	IsArrayItemListContext()
}

type ArrayItemListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayItemListContext() *ArrayItemListContext {
	var p = new(ArrayItemListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_arrayItemList
	return p
}

func (*ArrayItemListContext) IsArrayItemListContext() {}

func NewArrayItemListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayItemListContext {
	var p = new(ArrayItemListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_arrayItemList

	return p
}

func (s *ArrayItemListContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayItemListContext) AllArrayItem() []IArrayItemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IArrayItemContext)(nil)).Elem())
	var tst = make([]IArrayItemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IArrayItemContext)
		}
	}

	return tst
}

func (s *ArrayItemListContext) ArrayItem(i int) IArrayItemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArrayItemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IArrayItemContext)
}

func (s *ArrayItemListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayItemListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayItemListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterArrayItemList(s)
	}
}

func (s *ArrayItemListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitArrayItemList(s)
	}
}

func (p *PhpParser) ArrayItemList() (localctx IArrayItemListContext) {
	localctx = NewArrayItemListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, PhpParserRULE_arrayItemList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1272)
		p.ArrayItem()
	}
	p.SetState(1277)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 125, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1273)
				p.Match(PhpParserComma)
			}
			{
				p.SetState(1274)
				p.ArrayItem()
			}

		}
		p.SetState(1279)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 125, p.GetParserRuleContext())
	}
	p.SetState(1281)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PhpParserComma {
		{
			p.SetState(1280)
			p.Match(PhpParserComma)
		}

	}

	return localctx
}

// IArrayItemContext is an interface to support dynamic dispatch.
type IArrayItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArrayItemContext differentiates from other interfaces.
	IsArrayItemContext()
}

type ArrayItemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayItemContext() *ArrayItemContext {
	var p = new(ArrayItemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_arrayItem
	return p
}

func (*ArrayItemContext) IsArrayItemContext() {}

func NewArrayItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayItemContext {
	var p = new(ArrayItemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_arrayItem

	return p
}

func (s *ArrayItemContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayItemContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *ArrayItemContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ArrayItemContext) Chain() IChainContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IChainContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IChainContext)
}

func (s *ArrayItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterArrayItem(s)
	}
}

func (s *ArrayItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitArrayItem(s)
	}
}

func (p *PhpParser) ArrayItem() (localctx IArrayItemContext) {
	localctx = NewArrayItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, PhpParserRULE_arrayItem)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1295)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 129, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1283)
			p.expression(0)
		}
		p.SetState(1286)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PhpParserDoubleArrow {
			{
				p.SetState(1284)
				p.Match(PhpParserDoubleArrow)
			}
			{
				p.SetState(1285)
				p.expression(0)
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1291)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la-43)&-(0x1f+1)) == 0 && ((1<<uint((_la-43)))&((1<<(PhpParserAbstract-43))|(1<<(PhpParserArray-43))|(1<<(PhpParserAs-43))|(1<<(PhpParserBinaryCast-43))|(1<<(PhpParserBoolType-43))|(1<<(PhpParserBooleanConstant-43))|(1<<(PhpParserBreak-43))|(1<<(PhpParserCallable-43))|(1<<(PhpParserCase-43))|(1<<(PhpParserCatch-43))|(1<<(PhpParserClass-43))|(1<<(PhpParserClone-43))|(1<<(PhpParserConst-43))|(1<<(PhpParserContinue-43))|(1<<(PhpParserDeclare-43))|(1<<(PhpParserDefault-43))|(1<<(PhpParserDo-43))|(1<<(PhpParserDoubleCast-43))|(1<<(PhpParserDoubleType-43))|(1<<(PhpParserEcho-43))|(1<<(PhpParserElse-43))|(1<<(PhpParserElseIf-43))|(1<<(PhpParserEmpty-43))|(1<<(PhpParserEndDeclare-43))|(1<<(PhpParserEndFor-43))|(1<<(PhpParserEndForeach-43))|(1<<(PhpParserEndIf-43))|(1<<(PhpParserEndSwitch-43))|(1<<(PhpParserEndWhile-43))|(1<<(PhpParserEval-43))|(1<<(PhpParserExit-43))|(1<<(PhpParserExtends-43)))) != 0) || (((_la-75)&-(0x1f+1)) == 0 && ((1<<uint((_la-75)))&((1<<(PhpParserFinal-75))|(1<<(PhpParserFinally-75))|(1<<(PhpParserFloatCast-75))|(1<<(PhpParserFor-75))|(1<<(PhpParserForeach-75))|(1<<(PhpParserFunction-75))|(1<<(PhpParserGlobal-75))|(1<<(PhpParserGoto-75))|(1<<(PhpParserIf-75))|(1<<(PhpParserImplements-75))|(1<<(PhpParserImport-75))|(1<<(PhpParserInclude-75))|(1<<(PhpParserIncludeOnce-75))|(1<<(PhpParserInstanceOf-75))|(1<<(PhpParserInsteadOf-75))|(1<<(PhpParserInt8Cast-75))|(1<<(PhpParserInt16Cast-75))|(1<<(PhpParserInt64Type-75))|(1<<(PhpParserIntType-75))|(1<<(PhpParserInterface-75))|(1<<(PhpParserIsSet-75))|(1<<(PhpParserList-75))|(1<<(PhpParserLogicalAnd-75))|(1<<(PhpParserLogicalOr-75))|(1<<(PhpParserLogicalXor-75))|(1<<(PhpParserNamespace-75))|(1<<(PhpParserNew-75))|(1<<(PhpParserNull-75))|(1<<(PhpParserObjectType-75))|(1<<(PhpParserParent_-75))|(1<<(PhpParserPartial-75))|(1<<(PhpParserPrint-75)))) != 0) || (((_la-107)&-(0x1f+1)) == 0 && ((1<<uint((_la-107)))&((1<<(PhpParserPrivate-107))|(1<<(PhpParserProtected-107))|(1<<(PhpParserPublic-107))|(1<<(PhpParserRequire-107))|(1<<(PhpParserRequireOnce-107))|(1<<(PhpParserResource-107))|(1<<(PhpParserReturn-107))|(1<<(PhpParserStatic-107))|(1<<(PhpParserStringType-107))|(1<<(PhpParserSwitch-107))|(1<<(PhpParserThrow-107))|(1<<(PhpParserTrait-107))|(1<<(PhpParserTry-107))|(1<<(PhpParserTypeof-107))|(1<<(PhpParserUintCast-107))|(1<<(PhpParserUnicodeCast-107))|(1<<(PhpParserUnset-107))|(1<<(PhpParserUse-107))|(1<<(PhpParserVar-107))|(1<<(PhpParserWhile-107))|(1<<(PhpParserYield-107))|(1<<(PhpParserGet-107))|(1<<(PhpParserSet-107))|(1<<(PhpParserCall-107))|(1<<(PhpParserCallStatic-107))|(1<<(PhpParserConstructor-107))|(1<<(PhpParserDestruct-107))|(1<<(PhpParserWakeup-107))|(1<<(PhpParserSleep-107))|(1<<(PhpParserAutoload-107))|(1<<(PhpParserIsSet__-107))|(1<<(PhpParserUnset__-107)))) != 0) || (((_la-139)&-(0x1f+1)) == 0 && ((1<<uint((_la-139)))&((1<<(PhpParserToString__-139))|(1<<(PhpParserInvoke-139))|(1<<(PhpParserSetState-139))|(1<<(PhpParserClone__-139))|(1<<(PhpParserDebugInfo-139))|(1<<(PhpParserNamespace__-139))|(1<<(PhpParserClass__-139))|(1<<(PhpParserTraic__-139))|(1<<(PhpParserFunction__-139))|(1<<(PhpParserMethod__-139))|(1<<(PhpParserLine__-139))|(1<<(PhpParserFile__-139))|(1<<(PhpParserDir__-139))|(1<<(PhpParserInc-139))|(1<<(PhpParserDec-139)))) != 0) || (((_la-182)&-(0x1f+1)) == 0 && ((1<<uint((_la-182)))&((1<<(PhpParserNamespaceSeparator-182))|(1<<(PhpParserBang-182))|(1<<(PhpParserPlus-182))|(1<<(PhpParserMinus-182))|(1<<(PhpParserTilde-182))|(1<<(PhpParserSuppressWarnings-182))|(1<<(PhpParserDollar-182))|(1<<(PhpParserOpenRoundBracket-182))|(1<<(PhpParserOpenSquareBracket-182))|(1<<(PhpParserVarName-182))|(1<<(PhpParserLabel-182)))) != 0) || (((_la-214)&-(0x1f+1)) == 0 && ((1<<uint((_la-214)))&((1<<(PhpParserOctal-214))|(1<<(PhpParserDecimal-214))|(1<<(PhpParserReal-214))|(1<<(PhpParserHex-214))|(1<<(PhpParserBinary-214))|(1<<(PhpParserBackQuoteString-214))|(1<<(PhpParserSingleQuoteString-214))|(1<<(PhpParserDoubleQuote-214))|(1<<(PhpParserStartNowDoc-214))|(1<<(PhpParserStartHereDoc-214)))) != 0) {
			{
				p.SetState(1288)
				p.expression(0)
			}
			{
				p.SetState(1289)
				p.Match(PhpParserDoubleArrow)
			}

		}
		{
			p.SetState(1293)
			p.Match(PhpParserAmpersand)
		}
		{
			p.SetState(1294)
			p.Chain()
		}

	}

	return localctx
}

// ILambdaFunctionUseVarsContext is an interface to support dynamic dispatch.
type ILambdaFunctionUseVarsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLambdaFunctionUseVarsContext differentiates from other interfaces.
	IsLambdaFunctionUseVarsContext()
}

type LambdaFunctionUseVarsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLambdaFunctionUseVarsContext() *LambdaFunctionUseVarsContext {
	var p = new(LambdaFunctionUseVarsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_lambdaFunctionUseVars
	return p
}

func (*LambdaFunctionUseVarsContext) IsLambdaFunctionUseVarsContext() {}

func NewLambdaFunctionUseVarsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LambdaFunctionUseVarsContext {
	var p = new(LambdaFunctionUseVarsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_lambdaFunctionUseVars

	return p
}

func (s *LambdaFunctionUseVarsContext) GetParser() antlr.Parser { return s.parser }

func (s *LambdaFunctionUseVarsContext) Use() antlr.TerminalNode {
	return s.GetToken(PhpParserUse, 0)
}

func (s *LambdaFunctionUseVarsContext) AllLambdaFunctionUseVar() []ILambdaFunctionUseVarContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILambdaFunctionUseVarContext)(nil)).Elem())
	var tst = make([]ILambdaFunctionUseVarContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILambdaFunctionUseVarContext)
		}
	}

	return tst
}

func (s *LambdaFunctionUseVarsContext) LambdaFunctionUseVar(i int) ILambdaFunctionUseVarContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILambdaFunctionUseVarContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILambdaFunctionUseVarContext)
}

func (s *LambdaFunctionUseVarsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdaFunctionUseVarsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LambdaFunctionUseVarsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterLambdaFunctionUseVars(s)
	}
}

func (s *LambdaFunctionUseVarsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitLambdaFunctionUseVars(s)
	}
}

func (p *PhpParser) LambdaFunctionUseVars() (localctx ILambdaFunctionUseVarsContext) {
	localctx = NewLambdaFunctionUseVarsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, PhpParserRULE_lambdaFunctionUseVars)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1297)
		p.Match(PhpParserUse)
	}
	{
		p.SetState(1298)
		p.Match(PhpParserOpenRoundBracket)
	}
	{
		p.SetState(1299)
		p.LambdaFunctionUseVar()
	}
	p.SetState(1304)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PhpParserComma {
		{
			p.SetState(1300)
			p.Match(PhpParserComma)
		}
		{
			p.SetState(1301)
			p.LambdaFunctionUseVar()
		}

		p.SetState(1306)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1307)
		p.Match(PhpParserCloseRoundBracket)
	}

	return localctx
}

// ILambdaFunctionUseVarContext is an interface to support dynamic dispatch.
type ILambdaFunctionUseVarContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLambdaFunctionUseVarContext differentiates from other interfaces.
	IsLambdaFunctionUseVarContext()
}

type LambdaFunctionUseVarContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLambdaFunctionUseVarContext() *LambdaFunctionUseVarContext {
	var p = new(LambdaFunctionUseVarContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_lambdaFunctionUseVar
	return p
}

func (*LambdaFunctionUseVarContext) IsLambdaFunctionUseVarContext() {}

func NewLambdaFunctionUseVarContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LambdaFunctionUseVarContext {
	var p = new(LambdaFunctionUseVarContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_lambdaFunctionUseVar

	return p
}

func (s *LambdaFunctionUseVarContext) GetParser() antlr.Parser { return s.parser }

func (s *LambdaFunctionUseVarContext) VarName() antlr.TerminalNode {
	return s.GetToken(PhpParserVarName, 0)
}

func (s *LambdaFunctionUseVarContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdaFunctionUseVarContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LambdaFunctionUseVarContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterLambdaFunctionUseVar(s)
	}
}

func (s *LambdaFunctionUseVarContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitLambdaFunctionUseVar(s)
	}
}

func (p *PhpParser) LambdaFunctionUseVar() (localctx ILambdaFunctionUseVarContext) {
	localctx = NewLambdaFunctionUseVarContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, PhpParserRULE_lambdaFunctionUseVar)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1310)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PhpParserAmpersand {
		{
			p.SetState(1309)
			p.Match(PhpParserAmpersand)
		}

	}
	{
		p.SetState(1312)
		p.Match(PhpParserVarName)
	}

	return localctx
}

// IQualifiedStaticTypeRefContext is an interface to support dynamic dispatch.
type IQualifiedStaticTypeRefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQualifiedStaticTypeRefContext differentiates from other interfaces.
	IsQualifiedStaticTypeRefContext()
}

type QualifiedStaticTypeRefContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifiedStaticTypeRefContext() *QualifiedStaticTypeRefContext {
	var p = new(QualifiedStaticTypeRefContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_qualifiedStaticTypeRef
	return p
}

func (*QualifiedStaticTypeRefContext) IsQualifiedStaticTypeRefContext() {}

func NewQualifiedStaticTypeRefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiedStaticTypeRefContext {
	var p = new(QualifiedStaticTypeRefContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_qualifiedStaticTypeRef

	return p
}

func (s *QualifiedStaticTypeRefContext) GetParser() antlr.Parser { return s.parser }

func (s *QualifiedStaticTypeRefContext) QualifiedNamespaceName() IQualifiedNamespaceNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNamespaceNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNamespaceNameContext)
}

func (s *QualifiedStaticTypeRefContext) GenericDynamicArgs() IGenericDynamicArgsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenericDynamicArgsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenericDynamicArgsContext)
}

func (s *QualifiedStaticTypeRefContext) Static() antlr.TerminalNode {
	return s.GetToken(PhpParserStatic, 0)
}

func (s *QualifiedStaticTypeRefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedStaticTypeRefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QualifiedStaticTypeRefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterQualifiedStaticTypeRef(s)
	}
}

func (s *QualifiedStaticTypeRefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitQualifiedStaticTypeRef(s)
	}
}

func (p *PhpParser) QualifiedStaticTypeRef() (localctx IQualifiedStaticTypeRefContext) {
	localctx = NewQualifiedStaticTypeRefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, PhpParserRULE_qualifiedStaticTypeRef)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1319)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 133, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1314)
			p.QualifiedNamespaceName()
		}
		p.SetState(1316)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PhpParserLgeneric {
			{
				p.SetState(1315)
				p.GenericDynamicArgs()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1318)
			p.Match(PhpParserStatic)
		}

	}

	return localctx
}

// ITypeRefContext is an interface to support dynamic dispatch.
type ITypeRefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeRefContext differentiates from other interfaces.
	IsTypeRefContext()
}

type TypeRefContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeRefContext() *TypeRefContext {
	var p = new(TypeRefContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_typeRef
	return p
}

func (*TypeRefContext) IsTypeRefContext() {}

func NewTypeRefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeRefContext {
	var p = new(TypeRefContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_typeRef

	return p
}

func (s *TypeRefContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeRefContext) QualifiedNamespaceName() IQualifiedNamespaceNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNamespaceNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNamespaceNameContext)
}

func (s *TypeRefContext) IndirectTypeRef() IIndirectTypeRefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIndirectTypeRefContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIndirectTypeRefContext)
}

func (s *TypeRefContext) GenericDynamicArgs() IGenericDynamicArgsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenericDynamicArgsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenericDynamicArgsContext)
}

func (s *TypeRefContext) PrimitiveType() IPrimitiveTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimitiveTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimitiveTypeContext)
}

func (s *TypeRefContext) Static() antlr.TerminalNode {
	return s.GetToken(PhpParserStatic, 0)
}

func (s *TypeRefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeRefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeRefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterTypeRef(s)
	}
}

func (s *TypeRefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitTypeRef(s)
	}
}

func (p *PhpParser) TypeRef() (localctx ITypeRefContext) {
	localctx = NewTypeRefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, PhpParserRULE_typeRef)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1330)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 136, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1323)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 134, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1321)
				p.QualifiedNamespaceName()
			}

		case 2:
			{
				p.SetState(1322)
				p.IndirectTypeRef()
			}

		}
		p.SetState(1326)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 135, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1325)
				p.GenericDynamicArgs()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1328)
			p.PrimitiveType()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1329)
			p.Match(PhpParserStatic)
		}

	}

	return localctx
}

// IIndirectTypeRefContext is an interface to support dynamic dispatch.
type IIndirectTypeRefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIndirectTypeRefContext differentiates from other interfaces.
	IsIndirectTypeRefContext()
}

type IndirectTypeRefContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndirectTypeRefContext() *IndirectTypeRefContext {
	var p = new(IndirectTypeRefContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_indirectTypeRef
	return p
}

func (*IndirectTypeRefContext) IsIndirectTypeRefContext() {}

func NewIndirectTypeRefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndirectTypeRefContext {
	var p = new(IndirectTypeRefContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_indirectTypeRef

	return p
}

func (s *IndirectTypeRefContext) GetParser() antlr.Parser { return s.parser }

func (s *IndirectTypeRefContext) ChainBase() IChainBaseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IChainBaseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IChainBaseContext)
}

func (s *IndirectTypeRefContext) AllKeyedFieldName() []IKeyedFieldNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IKeyedFieldNameContext)(nil)).Elem())
	var tst = make([]IKeyedFieldNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IKeyedFieldNameContext)
		}
	}

	return tst
}

func (s *IndirectTypeRefContext) KeyedFieldName(i int) IKeyedFieldNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IKeyedFieldNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IKeyedFieldNameContext)
}

func (s *IndirectTypeRefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndirectTypeRefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndirectTypeRefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterIndirectTypeRef(s)
	}
}

func (s *IndirectTypeRefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitIndirectTypeRef(s)
	}
}

func (p *PhpParser) IndirectTypeRef() (localctx IIndirectTypeRefContext) {
	localctx = NewIndirectTypeRefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, PhpParserRULE_indirectTypeRef)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1332)
		p.ChainBase()
	}
	p.SetState(1337)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 137, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1333)
				p.Match(PhpParserObjectOperator)
			}
			{
				p.SetState(1334)
				p.KeyedFieldName()
			}

		}
		p.SetState(1339)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 137, p.GetParserRuleContext())
	}

	return localctx
}

// IQualifiedNamespaceNameContext is an interface to support dynamic dispatch.
type IQualifiedNamespaceNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQualifiedNamespaceNameContext differentiates from other interfaces.
	IsQualifiedNamespaceNameContext()
}

type QualifiedNamespaceNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifiedNamespaceNameContext() *QualifiedNamespaceNameContext {
	var p = new(QualifiedNamespaceNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_qualifiedNamespaceName
	return p
}

func (*QualifiedNamespaceNameContext) IsQualifiedNamespaceNameContext() {}

func NewQualifiedNamespaceNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiedNamespaceNameContext {
	var p = new(QualifiedNamespaceNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_qualifiedNamespaceName

	return p
}

func (s *QualifiedNamespaceNameContext) GetParser() antlr.Parser { return s.parser }

func (s *QualifiedNamespaceNameContext) NamespaceNameList() INamespaceNameListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INamespaceNameListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INamespaceNameListContext)
}

func (s *QualifiedNamespaceNameContext) Namespace() antlr.TerminalNode {
	return s.GetToken(PhpParserNamespace, 0)
}

func (s *QualifiedNamespaceNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedNamespaceNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QualifiedNamespaceNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterQualifiedNamespaceName(s)
	}
}

func (s *QualifiedNamespaceNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitQualifiedNamespaceName(s)
	}
}

func (p *PhpParser) QualifiedNamespaceName() (localctx IQualifiedNamespaceNameContext) {
	localctx = NewQualifiedNamespaceNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, PhpParserRULE_qualifiedNamespaceName)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1341)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 138, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1340)
			p.Match(PhpParserNamespace)
		}

	}
	p.SetState(1344)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PhpParserNamespaceSeparator {
		{
			p.SetState(1343)
			p.Match(PhpParserNamespaceSeparator)
		}

	}
	{
		p.SetState(1346)
		p.NamespaceNameList()
	}

	return localctx
}

// INamespaceNameListContext is an interface to support dynamic dispatch.
type INamespaceNameListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNamespaceNameListContext differentiates from other interfaces.
	IsNamespaceNameListContext()
}

type NamespaceNameListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamespaceNameListContext() *NamespaceNameListContext {
	var p = new(NamespaceNameListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_namespaceNameList
	return p
}

func (*NamespaceNameListContext) IsNamespaceNameListContext() {}

func NewNamespaceNameListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamespaceNameListContext {
	var p = new(NamespaceNameListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_namespaceNameList

	return p
}

func (s *NamespaceNameListContext) GetParser() antlr.Parser { return s.parser }

func (s *NamespaceNameListContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *NamespaceNameListContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *NamespaceNameListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamespaceNameListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamespaceNameListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterNamespaceNameList(s)
	}
}

func (s *NamespaceNameListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitNamespaceNameList(s)
	}
}

func (p *PhpParser) NamespaceNameList() (localctx INamespaceNameListContext) {
	localctx = NewNamespaceNameListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, PhpParserRULE_namespaceNameList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1348)
		p.Identifier()
	}
	p.SetState(1353)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 140, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1349)
				p.Match(PhpParserNamespaceSeparator)
			}
			{
				p.SetState(1350)
				p.Identifier()
			}

		}
		p.SetState(1355)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 140, p.GetParserRuleContext())
	}

	return localctx
}

// IQualifiedNamespaceNameListContext is an interface to support dynamic dispatch.
type IQualifiedNamespaceNameListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQualifiedNamespaceNameListContext differentiates from other interfaces.
	IsQualifiedNamespaceNameListContext()
}

type QualifiedNamespaceNameListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifiedNamespaceNameListContext() *QualifiedNamespaceNameListContext {
	var p = new(QualifiedNamespaceNameListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_qualifiedNamespaceNameList
	return p
}

func (*QualifiedNamespaceNameListContext) IsQualifiedNamespaceNameListContext() {}

func NewQualifiedNamespaceNameListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiedNamespaceNameListContext {
	var p = new(QualifiedNamespaceNameListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_qualifiedNamespaceNameList

	return p
}

func (s *QualifiedNamespaceNameListContext) GetParser() antlr.Parser { return s.parser }

func (s *QualifiedNamespaceNameListContext) AllQualifiedNamespaceName() []IQualifiedNamespaceNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IQualifiedNamespaceNameContext)(nil)).Elem())
	var tst = make([]IQualifiedNamespaceNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IQualifiedNamespaceNameContext)
		}
	}

	return tst
}

func (s *QualifiedNamespaceNameListContext) QualifiedNamespaceName(i int) IQualifiedNamespaceNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNamespaceNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNamespaceNameContext)
}

func (s *QualifiedNamespaceNameListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedNamespaceNameListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QualifiedNamespaceNameListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterQualifiedNamespaceNameList(s)
	}
}

func (s *QualifiedNamespaceNameListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitQualifiedNamespaceNameList(s)
	}
}

func (p *PhpParser) QualifiedNamespaceNameList() (localctx IQualifiedNamespaceNameListContext) {
	localctx = NewQualifiedNamespaceNameListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, PhpParserRULE_qualifiedNamespaceNameList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1356)
		p.QualifiedNamespaceName()
	}
	p.SetState(1361)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PhpParserComma {
		{
			p.SetState(1357)
			p.Match(PhpParserComma)
		}
		{
			p.SetState(1358)
			p.QualifiedNamespaceName()
		}

		p.SetState(1363)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IArgumentsContext is an interface to support dynamic dispatch.
type IArgumentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArgumentsContext differentiates from other interfaces.
	IsArgumentsContext()
}

type ArgumentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentsContext() *ArgumentsContext {
	var p = new(ArgumentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_arguments
	return p
}

func (*ArgumentsContext) IsArgumentsContext() {}

func NewArgumentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentsContext {
	var p = new(ArgumentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_arguments

	return p
}

func (s *ArgumentsContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentsContext) AllActualArgument() []IActualArgumentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IActualArgumentContext)(nil)).Elem())
	var tst = make([]IActualArgumentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IActualArgumentContext)
		}
	}

	return tst
}

func (s *ArgumentsContext) ActualArgument(i int) IActualArgumentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IActualArgumentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IActualArgumentContext)
}

func (s *ArgumentsContext) YieldExpression() IYieldExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IYieldExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IYieldExpressionContext)
}

func (s *ArgumentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterArguments(s)
	}
}

func (s *ArgumentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitArguments(s)
	}
}

func (p *PhpParser) Arguments() (localctx IArgumentsContext) {
	localctx = NewArgumentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, PhpParserRULE_arguments)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1364)
		p.Match(PhpParserOpenRoundBracket)
	}
	p.SetState(1374)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 143, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1365)
			p.ActualArgument()
		}
		p.SetState(1370)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == PhpParserComma {
			{
				p.SetState(1366)
				p.Match(PhpParserComma)
			}
			{
				p.SetState(1367)
				p.ActualArgument()
			}

			p.SetState(1372)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 143, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(1373)
			p.YieldExpression()
		}

	}
	{
		p.SetState(1376)
		p.Match(PhpParserCloseRoundBracket)
	}

	return localctx
}

// IActualArgumentContext is an interface to support dynamic dispatch.
type IActualArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsActualArgumentContext differentiates from other interfaces.
	IsActualArgumentContext()
}

type ActualArgumentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyActualArgumentContext() *ActualArgumentContext {
	var p = new(ActualArgumentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_actualArgument
	return p
}

func (*ActualArgumentContext) IsActualArgumentContext() {}

func NewActualArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ActualArgumentContext {
	var p = new(ActualArgumentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_actualArgument

	return p
}

func (s *ActualArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *ActualArgumentContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ActualArgumentContext) Chain() IChainContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IChainContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IChainContext)
}

func (s *ActualArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ActualArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ActualArgumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterActualArgument(s)
	}
}

func (s *ActualArgumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitActualArgument(s)
	}
}

func (p *PhpParser) ActualArgument() (localctx IActualArgumentContext) {
	localctx = NewActualArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, PhpParserRULE_actualArgument)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1384)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PhpParserAbstract, PhpParserArray, PhpParserAs, PhpParserBinaryCast, PhpParserBoolType, PhpParserBooleanConstant, PhpParserBreak, PhpParserCallable, PhpParserCase, PhpParserCatch, PhpParserClass, PhpParserClone, PhpParserConst, PhpParserContinue, PhpParserDeclare, PhpParserDefault, PhpParserDo, PhpParserDoubleCast, PhpParserDoubleType, PhpParserEcho, PhpParserElse, PhpParserElseIf, PhpParserEmpty, PhpParserEndDeclare, PhpParserEndFor, PhpParserEndForeach, PhpParserEndIf, PhpParserEndSwitch, PhpParserEndWhile, PhpParserEval, PhpParserExit, PhpParserExtends, PhpParserFinal, PhpParserFinally, PhpParserFloatCast, PhpParserFor, PhpParserForeach, PhpParserFunction, PhpParserGlobal, PhpParserGoto, PhpParserIf, PhpParserImplements, PhpParserImport, PhpParserInclude, PhpParserIncludeOnce, PhpParserInstanceOf, PhpParserInsteadOf, PhpParserInt8Cast, PhpParserInt16Cast, PhpParserInt64Type, PhpParserIntType, PhpParserInterface, PhpParserIsSet, PhpParserList, PhpParserLogicalAnd, PhpParserLogicalOr, PhpParserLogicalXor, PhpParserNamespace, PhpParserNew, PhpParserNull, PhpParserObjectType, PhpParserParent_, PhpParserPartial, PhpParserPrint, PhpParserPrivate, PhpParserProtected, PhpParserPublic, PhpParserRequire, PhpParserRequireOnce, PhpParserResource, PhpParserReturn, PhpParserStatic, PhpParserStringType, PhpParserSwitch, PhpParserThrow, PhpParserTrait, PhpParserTry, PhpParserTypeof, PhpParserUintCast, PhpParserUnicodeCast, PhpParserUnset, PhpParserUse, PhpParserVar, PhpParserWhile, PhpParserYield, PhpParserGet, PhpParserSet, PhpParserCall, PhpParserCallStatic, PhpParserConstructor, PhpParserDestruct, PhpParserWakeup, PhpParserSleep, PhpParserAutoload, PhpParserIsSet__, PhpParserUnset__, PhpParserToString__, PhpParserInvoke, PhpParserSetState, PhpParserClone__, PhpParserDebugInfo, PhpParserNamespace__, PhpParserClass__, PhpParserTraic__, PhpParserFunction__, PhpParserMethod__, PhpParserLine__, PhpParserFile__, PhpParserDir__, PhpParserInc, PhpParserDec, PhpParserNamespaceSeparator, PhpParserEllipsis, PhpParserBang, PhpParserPlus, PhpParserMinus, PhpParserTilde, PhpParserSuppressWarnings, PhpParserDollar, PhpParserOpenRoundBracket, PhpParserOpenSquareBracket, PhpParserVarName, PhpParserLabel, PhpParserOctal, PhpParserDecimal, PhpParserReal, PhpParserHex, PhpParserBinary, PhpParserBackQuoteString, PhpParserSingleQuoteString, PhpParserDoubleQuote, PhpParserStartNowDoc, PhpParserStartHereDoc:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1379)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == PhpParserEllipsis {
			{
				p.SetState(1378)
				p.Match(PhpParserEllipsis)
			}

		}
		{
			p.SetState(1381)
			p.expression(0)
		}

	case PhpParserAmpersand:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1382)
			p.Match(PhpParserAmpersand)
		}
		{
			p.SetState(1383)
			p.Chain()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IConstantInititalizerContext is an interface to support dynamic dispatch.
type IConstantInititalizerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstantInititalizerContext differentiates from other interfaces.
	IsConstantInititalizerContext()
}

type ConstantInititalizerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstantInititalizerContext() *ConstantInititalizerContext {
	var p = new(ConstantInititalizerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_constantInititalizer
	return p
}

func (*ConstantInititalizerContext) IsConstantInititalizerContext() {}

func NewConstantInititalizerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstantInititalizerContext {
	var p = new(ConstantInititalizerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_constantInititalizer

	return p
}

func (s *ConstantInititalizerContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstantInititalizerContext) Constant() IConstantContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstantContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *ConstantInititalizerContext) Str() IStrContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStrContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStrContext)
}

func (s *ConstantInititalizerContext) Array() antlr.TerminalNode {
	return s.GetToken(PhpParserArray, 0)
}

func (s *ConstantInititalizerContext) ConstantArrayItemList() IConstantArrayItemListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstantArrayItemListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstantArrayItemListContext)
}

func (s *ConstantInititalizerContext) ConstantInititalizer() IConstantInititalizerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstantInititalizerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstantInititalizerContext)
}

func (s *ConstantInititalizerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstantInititalizerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstantInititalizerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterConstantInititalizer(s)
	}
}

func (s *ConstantInititalizerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitConstantInititalizer(s)
	}
}

func (p *PhpParser) ConstantInititalizer() (localctx IConstantInititalizerContext) {
	localctx = NewConstantInititalizerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, PhpParserRULE_constantInititalizer)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1407)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 150, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1386)
			p.Constant()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1387)
			p.Str()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1388)
			p.Match(PhpParserArray)
		}
		{
			p.SetState(1389)
			p.Match(PhpParserOpenRoundBracket)
		}
		p.SetState(1394)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la-43)&-(0x1f+1)) == 0 && ((1<<uint((_la-43)))&((1<<(PhpParserAbstract-43))|(1<<(PhpParserArray-43))|(1<<(PhpParserAs-43))|(1<<(PhpParserBinaryCast-43))|(1<<(PhpParserBoolType-43))|(1<<(PhpParserBooleanConstant-43))|(1<<(PhpParserBreak-43))|(1<<(PhpParserCallable-43))|(1<<(PhpParserCase-43))|(1<<(PhpParserCatch-43))|(1<<(PhpParserClass-43))|(1<<(PhpParserClone-43))|(1<<(PhpParserConst-43))|(1<<(PhpParserContinue-43))|(1<<(PhpParserDeclare-43))|(1<<(PhpParserDefault-43))|(1<<(PhpParserDo-43))|(1<<(PhpParserDoubleCast-43))|(1<<(PhpParserDoubleType-43))|(1<<(PhpParserEcho-43))|(1<<(PhpParserElse-43))|(1<<(PhpParserElseIf-43))|(1<<(PhpParserEmpty-43))|(1<<(PhpParserEndDeclare-43))|(1<<(PhpParserEndFor-43))|(1<<(PhpParserEndForeach-43))|(1<<(PhpParserEndIf-43))|(1<<(PhpParserEndSwitch-43))|(1<<(PhpParserEndWhile-43))|(1<<(PhpParserEval-43))|(1<<(PhpParserExit-43))|(1<<(PhpParserExtends-43)))) != 0) || (((_la-75)&-(0x1f+1)) == 0 && ((1<<uint((_la-75)))&((1<<(PhpParserFinal-75))|(1<<(PhpParserFinally-75))|(1<<(PhpParserFloatCast-75))|(1<<(PhpParserFor-75))|(1<<(PhpParserForeach-75))|(1<<(PhpParserFunction-75))|(1<<(PhpParserGlobal-75))|(1<<(PhpParserGoto-75))|(1<<(PhpParserIf-75))|(1<<(PhpParserImplements-75))|(1<<(PhpParserImport-75))|(1<<(PhpParserInclude-75))|(1<<(PhpParserIncludeOnce-75))|(1<<(PhpParserInstanceOf-75))|(1<<(PhpParserInsteadOf-75))|(1<<(PhpParserInt8Cast-75))|(1<<(PhpParserInt16Cast-75))|(1<<(PhpParserInt64Type-75))|(1<<(PhpParserIntType-75))|(1<<(PhpParserInterface-75))|(1<<(PhpParserIsSet-75))|(1<<(PhpParserList-75))|(1<<(PhpParserLogicalAnd-75))|(1<<(PhpParserLogicalOr-75))|(1<<(PhpParserLogicalXor-75))|(1<<(PhpParserNamespace-75))|(1<<(PhpParserNew-75))|(1<<(PhpParserNull-75))|(1<<(PhpParserObjectType-75))|(1<<(PhpParserParent_-75))|(1<<(PhpParserPartial-75))|(1<<(PhpParserPrint-75)))) != 0) || (((_la-107)&-(0x1f+1)) == 0 && ((1<<uint((_la-107)))&((1<<(PhpParserPrivate-107))|(1<<(PhpParserProtected-107))|(1<<(PhpParserPublic-107))|(1<<(PhpParserRequire-107))|(1<<(PhpParserRequireOnce-107))|(1<<(PhpParserResource-107))|(1<<(PhpParserReturn-107))|(1<<(PhpParserStatic-107))|(1<<(PhpParserStringType-107))|(1<<(PhpParserSwitch-107))|(1<<(PhpParserThrow-107))|(1<<(PhpParserTrait-107))|(1<<(PhpParserTry-107))|(1<<(PhpParserTypeof-107))|(1<<(PhpParserUintCast-107))|(1<<(PhpParserUnicodeCast-107))|(1<<(PhpParserUnset-107))|(1<<(PhpParserUse-107))|(1<<(PhpParserVar-107))|(1<<(PhpParserWhile-107))|(1<<(PhpParserYield-107))|(1<<(PhpParserGet-107))|(1<<(PhpParserSet-107))|(1<<(PhpParserCall-107))|(1<<(PhpParserCallStatic-107))|(1<<(PhpParserConstructor-107))|(1<<(PhpParserDestruct-107))|(1<<(PhpParserWakeup-107))|(1<<(PhpParserSleep-107))|(1<<(PhpParserAutoload-107))|(1<<(PhpParserIsSet__-107))|(1<<(PhpParserUnset__-107)))) != 0) || (((_la-139)&-(0x1f+1)) == 0 && ((1<<uint((_la-139)))&((1<<(PhpParserToString__-139))|(1<<(PhpParserInvoke-139))|(1<<(PhpParserSetState-139))|(1<<(PhpParserClone__-139))|(1<<(PhpParserDebugInfo-139))|(1<<(PhpParserNamespace__-139))|(1<<(PhpParserClass__-139))|(1<<(PhpParserTraic__-139))|(1<<(PhpParserFunction__-139))|(1<<(PhpParserMethod__-139))|(1<<(PhpParserLine__-139))|(1<<(PhpParserFile__-139))|(1<<(PhpParserDir__-139)))) != 0) || (((_la-182)&-(0x1f+1)) == 0 && ((1<<uint((_la-182)))&((1<<(PhpParserNamespaceSeparator-182))|(1<<(PhpParserPlus-182))|(1<<(PhpParserMinus-182))|(1<<(PhpParserDollar-182))|(1<<(PhpParserOpenSquareBracket-182))|(1<<(PhpParserVarName-182))|(1<<(PhpParserLabel-182)))) != 0) || (((_la-214)&-(0x1f+1)) == 0 && ((1<<uint((_la-214)))&((1<<(PhpParserOctal-214))|(1<<(PhpParserDecimal-214))|(1<<(PhpParserReal-214))|(1<<(PhpParserHex-214))|(1<<(PhpParserBinary-214))|(1<<(PhpParserSingleQuoteString-214))|(1<<(PhpParserDoubleQuote-214))|(1<<(PhpParserStartNowDoc-214))|(1<<(PhpParserStartHereDoc-214)))) != 0) {
			{
				p.SetState(1390)
				p.ConstantArrayItemList()
			}
			p.SetState(1392)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == PhpParserComma {
				{
					p.SetState(1391)
					p.Match(PhpParserComma)
				}

			}

		}
		{
			p.SetState(1396)
			p.Match(PhpParserCloseRoundBracket)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1397)
			p.Match(PhpParserOpenSquareBracket)
		}
		p.SetState(1402)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la-43)&-(0x1f+1)) == 0 && ((1<<uint((_la-43)))&((1<<(PhpParserAbstract-43))|(1<<(PhpParserArray-43))|(1<<(PhpParserAs-43))|(1<<(PhpParserBinaryCast-43))|(1<<(PhpParserBoolType-43))|(1<<(PhpParserBooleanConstant-43))|(1<<(PhpParserBreak-43))|(1<<(PhpParserCallable-43))|(1<<(PhpParserCase-43))|(1<<(PhpParserCatch-43))|(1<<(PhpParserClass-43))|(1<<(PhpParserClone-43))|(1<<(PhpParserConst-43))|(1<<(PhpParserContinue-43))|(1<<(PhpParserDeclare-43))|(1<<(PhpParserDefault-43))|(1<<(PhpParserDo-43))|(1<<(PhpParserDoubleCast-43))|(1<<(PhpParserDoubleType-43))|(1<<(PhpParserEcho-43))|(1<<(PhpParserElse-43))|(1<<(PhpParserElseIf-43))|(1<<(PhpParserEmpty-43))|(1<<(PhpParserEndDeclare-43))|(1<<(PhpParserEndFor-43))|(1<<(PhpParserEndForeach-43))|(1<<(PhpParserEndIf-43))|(1<<(PhpParserEndSwitch-43))|(1<<(PhpParserEndWhile-43))|(1<<(PhpParserEval-43))|(1<<(PhpParserExit-43))|(1<<(PhpParserExtends-43)))) != 0) || (((_la-75)&-(0x1f+1)) == 0 && ((1<<uint((_la-75)))&((1<<(PhpParserFinal-75))|(1<<(PhpParserFinally-75))|(1<<(PhpParserFloatCast-75))|(1<<(PhpParserFor-75))|(1<<(PhpParserForeach-75))|(1<<(PhpParserFunction-75))|(1<<(PhpParserGlobal-75))|(1<<(PhpParserGoto-75))|(1<<(PhpParserIf-75))|(1<<(PhpParserImplements-75))|(1<<(PhpParserImport-75))|(1<<(PhpParserInclude-75))|(1<<(PhpParserIncludeOnce-75))|(1<<(PhpParserInstanceOf-75))|(1<<(PhpParserInsteadOf-75))|(1<<(PhpParserInt8Cast-75))|(1<<(PhpParserInt16Cast-75))|(1<<(PhpParserInt64Type-75))|(1<<(PhpParserIntType-75))|(1<<(PhpParserInterface-75))|(1<<(PhpParserIsSet-75))|(1<<(PhpParserList-75))|(1<<(PhpParserLogicalAnd-75))|(1<<(PhpParserLogicalOr-75))|(1<<(PhpParserLogicalXor-75))|(1<<(PhpParserNamespace-75))|(1<<(PhpParserNew-75))|(1<<(PhpParserNull-75))|(1<<(PhpParserObjectType-75))|(1<<(PhpParserParent_-75))|(1<<(PhpParserPartial-75))|(1<<(PhpParserPrint-75)))) != 0) || (((_la-107)&-(0x1f+1)) == 0 && ((1<<uint((_la-107)))&((1<<(PhpParserPrivate-107))|(1<<(PhpParserProtected-107))|(1<<(PhpParserPublic-107))|(1<<(PhpParserRequire-107))|(1<<(PhpParserRequireOnce-107))|(1<<(PhpParserResource-107))|(1<<(PhpParserReturn-107))|(1<<(PhpParserStatic-107))|(1<<(PhpParserStringType-107))|(1<<(PhpParserSwitch-107))|(1<<(PhpParserThrow-107))|(1<<(PhpParserTrait-107))|(1<<(PhpParserTry-107))|(1<<(PhpParserTypeof-107))|(1<<(PhpParserUintCast-107))|(1<<(PhpParserUnicodeCast-107))|(1<<(PhpParserUnset-107))|(1<<(PhpParserUse-107))|(1<<(PhpParserVar-107))|(1<<(PhpParserWhile-107))|(1<<(PhpParserYield-107))|(1<<(PhpParserGet-107))|(1<<(PhpParserSet-107))|(1<<(PhpParserCall-107))|(1<<(PhpParserCallStatic-107))|(1<<(PhpParserConstructor-107))|(1<<(PhpParserDestruct-107))|(1<<(PhpParserWakeup-107))|(1<<(PhpParserSleep-107))|(1<<(PhpParserAutoload-107))|(1<<(PhpParserIsSet__-107))|(1<<(PhpParserUnset__-107)))) != 0) || (((_la-139)&-(0x1f+1)) == 0 && ((1<<uint((_la-139)))&((1<<(PhpParserToString__-139))|(1<<(PhpParserInvoke-139))|(1<<(PhpParserSetState-139))|(1<<(PhpParserClone__-139))|(1<<(PhpParserDebugInfo-139))|(1<<(PhpParserNamespace__-139))|(1<<(PhpParserClass__-139))|(1<<(PhpParserTraic__-139))|(1<<(PhpParserFunction__-139))|(1<<(PhpParserMethod__-139))|(1<<(PhpParserLine__-139))|(1<<(PhpParserFile__-139))|(1<<(PhpParserDir__-139)))) != 0) || (((_la-182)&-(0x1f+1)) == 0 && ((1<<uint((_la-182)))&((1<<(PhpParserNamespaceSeparator-182))|(1<<(PhpParserPlus-182))|(1<<(PhpParserMinus-182))|(1<<(PhpParserDollar-182))|(1<<(PhpParserOpenSquareBracket-182))|(1<<(PhpParserVarName-182))|(1<<(PhpParserLabel-182)))) != 0) || (((_la-214)&-(0x1f+1)) == 0 && ((1<<uint((_la-214)))&((1<<(PhpParserOctal-214))|(1<<(PhpParserDecimal-214))|(1<<(PhpParserReal-214))|(1<<(PhpParserHex-214))|(1<<(PhpParserBinary-214))|(1<<(PhpParserSingleQuoteString-214))|(1<<(PhpParserDoubleQuote-214))|(1<<(PhpParserStartNowDoc-214))|(1<<(PhpParserStartHereDoc-214)))) != 0) {
			{
				p.SetState(1398)
				p.ConstantArrayItemList()
			}
			p.SetState(1400)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == PhpParserComma {
				{
					p.SetState(1399)
					p.Match(PhpParserComma)
				}

			}

		}
		{
			p.SetState(1404)
			p.Match(PhpParserCloseSquareBracket)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1405)
			_la = p.GetTokenStream().LA(1)

			if !(_la == PhpParserPlus || _la == PhpParserMinus) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1406)
			p.ConstantInititalizer()
		}

	}

	return localctx
}

// IConstantArrayItemListContext is an interface to support dynamic dispatch.
type IConstantArrayItemListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstantArrayItemListContext differentiates from other interfaces.
	IsConstantArrayItemListContext()
}

type ConstantArrayItemListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstantArrayItemListContext() *ConstantArrayItemListContext {
	var p = new(ConstantArrayItemListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_constantArrayItemList
	return p
}

func (*ConstantArrayItemListContext) IsConstantArrayItemListContext() {}

func NewConstantArrayItemListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstantArrayItemListContext {
	var p = new(ConstantArrayItemListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_constantArrayItemList

	return p
}

func (s *ConstantArrayItemListContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstantArrayItemListContext) AllConstantArrayItem() []IConstantArrayItemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConstantArrayItemContext)(nil)).Elem())
	var tst = make([]IConstantArrayItemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConstantArrayItemContext)
		}
	}

	return tst
}

func (s *ConstantArrayItemListContext) ConstantArrayItem(i int) IConstantArrayItemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstantArrayItemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConstantArrayItemContext)
}

func (s *ConstantArrayItemListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstantArrayItemListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstantArrayItemListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterConstantArrayItemList(s)
	}
}

func (s *ConstantArrayItemListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitConstantArrayItemList(s)
	}
}

func (p *PhpParser) ConstantArrayItemList() (localctx IConstantArrayItemListContext) {
	localctx = NewConstantArrayItemListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, PhpParserRULE_constantArrayItemList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1409)
		p.ConstantArrayItem()
	}
	p.SetState(1414)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 151, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1410)
				p.Match(PhpParserComma)
			}
			{
				p.SetState(1411)
				p.ConstantArrayItem()
			}

		}
		p.SetState(1416)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 151, p.GetParserRuleContext())
	}

	return localctx
}

// IConstantArrayItemContext is an interface to support dynamic dispatch.
type IConstantArrayItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstantArrayItemContext differentiates from other interfaces.
	IsConstantArrayItemContext()
}

type ConstantArrayItemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstantArrayItemContext() *ConstantArrayItemContext {
	var p = new(ConstantArrayItemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_constantArrayItem
	return p
}

func (*ConstantArrayItemContext) IsConstantArrayItemContext() {}

func NewConstantArrayItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstantArrayItemContext {
	var p = new(ConstantArrayItemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_constantArrayItem

	return p
}

func (s *ConstantArrayItemContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstantArrayItemContext) AllConstantInititalizer() []IConstantInititalizerContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConstantInititalizerContext)(nil)).Elem())
	var tst = make([]IConstantInititalizerContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConstantInititalizerContext)
		}
	}

	return tst
}

func (s *ConstantArrayItemContext) ConstantInititalizer(i int) IConstantInititalizerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstantInititalizerContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConstantInititalizerContext)
}

func (s *ConstantArrayItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstantArrayItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstantArrayItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterConstantArrayItem(s)
	}
}

func (s *ConstantArrayItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitConstantArrayItem(s)
	}
}

func (p *PhpParser) ConstantArrayItem() (localctx IConstantArrayItemContext) {
	localctx = NewConstantArrayItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, PhpParserRULE_constantArrayItem)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1417)
		p.ConstantInititalizer()
	}
	p.SetState(1420)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PhpParserDoubleArrow {
		{
			p.SetState(1418)
			p.Match(PhpParserDoubleArrow)
		}
		{
			p.SetState(1419)
			p.ConstantInititalizer()
		}

	}

	return localctx
}

// IConstantContext is an interface to support dynamic dispatch.
type IConstantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstantContext differentiates from other interfaces.
	IsConstantContext()
}

type ConstantContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstantContext() *ConstantContext {
	var p = new(ConstantContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_constant
	return p
}

func (*ConstantContext) IsConstantContext() {}

func NewConstantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstantContext {
	var p = new(ConstantContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_constant

	return p
}

func (s *ConstantContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstantContext) Null() antlr.TerminalNode {
	return s.GetToken(PhpParserNull, 0)
}

func (s *ConstantContext) LiteralConstant() ILiteralConstantContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralConstantContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralConstantContext)
}

func (s *ConstantContext) MagicConstant() IMagicConstantContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMagicConstantContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMagicConstantContext)
}

func (s *ConstantContext) ClassConstant() IClassConstantContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassConstantContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassConstantContext)
}

func (s *ConstantContext) QualifiedNamespaceName() IQualifiedNamespaceNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNamespaceNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNamespaceNameContext)
}

func (s *ConstantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterConstant(s)
	}
}

func (s *ConstantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitConstant(s)
	}
}

func (p *PhpParser) Constant() (localctx IConstantContext) {
	localctx = NewConstantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, PhpParserRULE_constant)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1427)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 153, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1422)
			p.Match(PhpParserNull)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1423)
			p.LiteralConstant()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1424)
			p.MagicConstant()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1425)
			p.ClassConstant()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1426)
			p.QualifiedNamespaceName()
		}

	}

	return localctx
}

// ILiteralConstantContext is an interface to support dynamic dispatch.
type ILiteralConstantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLiteralConstantContext differentiates from other interfaces.
	IsLiteralConstantContext()
}

type LiteralConstantContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralConstantContext() *LiteralConstantContext {
	var p = new(LiteralConstantContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_literalConstant
	return p
}

func (*LiteralConstantContext) IsLiteralConstantContext() {}

func NewLiteralConstantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralConstantContext {
	var p = new(LiteralConstantContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_literalConstant

	return p
}

func (s *LiteralConstantContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralConstantContext) Real() antlr.TerminalNode {
	return s.GetToken(PhpParserReal, 0)
}

func (s *LiteralConstantContext) BooleanConstant() antlr.TerminalNode {
	return s.GetToken(PhpParserBooleanConstant, 0)
}

func (s *LiteralConstantContext) NumericConstant() INumericConstantContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumericConstantContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumericConstantContext)
}

func (s *LiteralConstantContext) StringConstant() IStringConstantContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStringConstantContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStringConstantContext)
}

func (s *LiteralConstantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralConstantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LiteralConstantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterLiteralConstant(s)
	}
}

func (s *LiteralConstantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitLiteralConstant(s)
	}
}

func (p *PhpParser) LiteralConstant() (localctx ILiteralConstantContext) {
	localctx = NewLiteralConstantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, PhpParserRULE_literalConstant)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1433)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PhpParserReal:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1429)
			p.Match(PhpParserReal)
		}

	case PhpParserBooleanConstant:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1430)
			p.Match(PhpParserBooleanConstant)
		}

	case PhpParserOctal, PhpParserDecimal, PhpParserHex, PhpParserBinary:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1431)
			p.NumericConstant()
		}

	case PhpParserLabel:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1432)
			p.StringConstant()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// INumericConstantContext is an interface to support dynamic dispatch.
type INumericConstantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNumericConstantContext differentiates from other interfaces.
	IsNumericConstantContext()
}

type NumericConstantContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumericConstantContext() *NumericConstantContext {
	var p = new(NumericConstantContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_numericConstant
	return p
}

func (*NumericConstantContext) IsNumericConstantContext() {}

func NewNumericConstantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumericConstantContext {
	var p = new(NumericConstantContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_numericConstant

	return p
}

func (s *NumericConstantContext) GetParser() antlr.Parser { return s.parser }

func (s *NumericConstantContext) Octal() antlr.TerminalNode {
	return s.GetToken(PhpParserOctal, 0)
}

func (s *NumericConstantContext) Decimal() antlr.TerminalNode {
	return s.GetToken(PhpParserDecimal, 0)
}

func (s *NumericConstantContext) Hex() antlr.TerminalNode {
	return s.GetToken(PhpParserHex, 0)
}

func (s *NumericConstantContext) Binary() antlr.TerminalNode {
	return s.GetToken(PhpParserBinary, 0)
}

func (s *NumericConstantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumericConstantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NumericConstantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterNumericConstant(s)
	}
}

func (s *NumericConstantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitNumericConstant(s)
	}
}

func (p *PhpParser) NumericConstant() (localctx INumericConstantContext) {
	localctx = NewNumericConstantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, PhpParserRULE_numericConstant)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1435)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-214)&-(0x1f+1)) == 0 && ((1<<uint((_la-214)))&((1<<(PhpParserOctal-214))|(1<<(PhpParserDecimal-214))|(1<<(PhpParserHex-214))|(1<<(PhpParserBinary-214)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IClassConstantContext is an interface to support dynamic dispatch.
type IClassConstantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassConstantContext differentiates from other interfaces.
	IsClassConstantContext()
}

type ClassConstantContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassConstantContext() *ClassConstantContext {
	var p = new(ClassConstantContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_classConstant
	return p
}

func (*ClassConstantContext) IsClassConstantContext() {}

func NewClassConstantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassConstantContext {
	var p = new(ClassConstantContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_classConstant

	return p
}

func (s *ClassConstantContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassConstantContext) Class() antlr.TerminalNode {
	return s.GetToken(PhpParserClass, 0)
}

func (s *ClassConstantContext) Parent_() antlr.TerminalNode {
	return s.GetToken(PhpParserParent_, 0)
}

func (s *ClassConstantContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ClassConstantContext) Constructor() antlr.TerminalNode {
	return s.GetToken(PhpParserConstructor, 0)
}

func (s *ClassConstantContext) Get() antlr.TerminalNode {
	return s.GetToken(PhpParserGet, 0)
}

func (s *ClassConstantContext) Set() antlr.TerminalNode {
	return s.GetToken(PhpParserSet, 0)
}

func (s *ClassConstantContext) QualifiedStaticTypeRef() IQualifiedStaticTypeRefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedStaticTypeRefContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedStaticTypeRefContext)
}

func (s *ClassConstantContext) KeyedVariable() IKeyedVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IKeyedVariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IKeyedVariableContext)
}

func (s *ClassConstantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassConstantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassConstantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterClassConstant(s)
	}
}

func (s *ClassConstantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitClassConstant(s)
	}
}

func (p *PhpParser) ClassConstant() (localctx IClassConstantContext) {
	localctx = NewClassConstantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, PhpParserRULE_classConstant)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1452)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 157, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1437)
			_la = p.GetTokenStream().LA(1)

			if !(_la == PhpParserClass || _la == PhpParserParent_) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1438)
			p.Match(PhpParserDoubleColon)
		}
		p.SetState(1443)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 155, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1439)
				p.Identifier()
			}

		case 2:
			{
				p.SetState(1440)
				p.Match(PhpParserConstructor)
			}

		case 3:
			{
				p.SetState(1441)
				p.Match(PhpParserGet)
			}

		case 4:
			{
				p.SetState(1442)
				p.Match(PhpParserSet)
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1447)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case PhpParserAbstract, PhpParserArray, PhpParserAs, PhpParserBinaryCast, PhpParserBoolType, PhpParserBooleanConstant, PhpParserBreak, PhpParserCallable, PhpParserCase, PhpParserCatch, PhpParserClass, PhpParserClone, PhpParserConst, PhpParserContinue, PhpParserDeclare, PhpParserDefault, PhpParserDo, PhpParserDoubleCast, PhpParserDoubleType, PhpParserEcho, PhpParserElse, PhpParserElseIf, PhpParserEmpty, PhpParserEndDeclare, PhpParserEndFor, PhpParserEndForeach, PhpParserEndIf, PhpParserEndSwitch, PhpParserEndWhile, PhpParserEval, PhpParserExit, PhpParserExtends, PhpParserFinal, PhpParserFinally, PhpParserFloatCast, PhpParserFor, PhpParserForeach, PhpParserFunction, PhpParserGlobal, PhpParserGoto, PhpParserIf, PhpParserImplements, PhpParserImport, PhpParserInclude, PhpParserIncludeOnce, PhpParserInstanceOf, PhpParserInsteadOf, PhpParserInt8Cast, PhpParserInt16Cast, PhpParserInt64Type, PhpParserIntType, PhpParserInterface, PhpParserIsSet, PhpParserList, PhpParserLogicalAnd, PhpParserLogicalOr, PhpParserLogicalXor, PhpParserNamespace, PhpParserNew, PhpParserNull, PhpParserObjectType, PhpParserParent_, PhpParserPartial, PhpParserPrint, PhpParserPrivate, PhpParserProtected, PhpParserPublic, PhpParserRequire, PhpParserRequireOnce, PhpParserResource, PhpParserReturn, PhpParserStatic, PhpParserStringType, PhpParserSwitch, PhpParserThrow, PhpParserTrait, PhpParserTry, PhpParserTypeof, PhpParserUintCast, PhpParserUnicodeCast, PhpParserUnset, PhpParserUse, PhpParserVar, PhpParserWhile, PhpParserYield, PhpParserGet, PhpParserSet, PhpParserCall, PhpParserCallStatic, PhpParserConstructor, PhpParserDestruct, PhpParserWakeup, PhpParserSleep, PhpParserAutoload, PhpParserIsSet__, PhpParserUnset__, PhpParserToString__, PhpParserInvoke, PhpParserSetState, PhpParserClone__, PhpParserDebugInfo, PhpParserNamespace__, PhpParserClass__, PhpParserTraic__, PhpParserFunction__, PhpParserMethod__, PhpParserLine__, PhpParserFile__, PhpParserDir__, PhpParserNamespaceSeparator, PhpParserLabel:
			{
				p.SetState(1445)
				p.QualifiedStaticTypeRef()
			}

		case PhpParserDollar, PhpParserVarName:
			{
				p.SetState(1446)
				p.KeyedVariable()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		{
			p.SetState(1449)
			p.Match(PhpParserDoubleColon)
		}
		{
			p.SetState(1450)
			p.Identifier()
		}

	}

	return localctx
}

// IStringConstantContext is an interface to support dynamic dispatch.
type IStringConstantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStringConstantContext differentiates from other interfaces.
	IsStringConstantContext()
}

type StringConstantContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringConstantContext() *StringConstantContext {
	var p = new(StringConstantContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_stringConstant
	return p
}

func (*StringConstantContext) IsStringConstantContext() {}

func NewStringConstantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringConstantContext {
	var p = new(StringConstantContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_stringConstant

	return p
}

func (s *StringConstantContext) GetParser() antlr.Parser { return s.parser }

func (s *StringConstantContext) Label() antlr.TerminalNode {
	return s.GetToken(PhpParserLabel, 0)
}

func (s *StringConstantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringConstantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringConstantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterStringConstant(s)
	}
}

func (s *StringConstantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitStringConstant(s)
	}
}

func (p *PhpParser) StringConstant() (localctx IStringConstantContext) {
	localctx = NewStringConstantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, PhpParserRULE_stringConstant)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1454)
		p.Match(PhpParserLabel)
	}

	return localctx
}

// IStrContext is an interface to support dynamic dispatch.
type IStrContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStrContext differentiates from other interfaces.
	IsStrContext()
}

type StrContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStrContext() *StrContext {
	var p = new(StrContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_str
	return p
}

func (*StrContext) IsStrContext() {}

func NewStrContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StrContext {
	var p = new(StrContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_str

	return p
}

func (s *StrContext) GetParser() antlr.Parser { return s.parser }

func (s *StrContext) StartHereDoc() antlr.TerminalNode {
	return s.GetToken(PhpParserStartHereDoc, 0)
}

func (s *StrContext) AllHereDocText() []antlr.TerminalNode {
	return s.GetTokens(PhpParserHereDocText)
}

func (s *StrContext) HereDocText(i int) antlr.TerminalNode {
	return s.GetToken(PhpParserHereDocText, i)
}

func (s *StrContext) StartNowDoc() antlr.TerminalNode {
	return s.GetToken(PhpParserStartNowDoc, 0)
}

func (s *StrContext) SingleQuoteString() antlr.TerminalNode {
	return s.GetToken(PhpParserSingleQuoteString, 0)
}

func (s *StrContext) AllDoubleQuote() []antlr.TerminalNode {
	return s.GetTokens(PhpParserDoubleQuote)
}

func (s *StrContext) DoubleQuote(i int) antlr.TerminalNode {
	return s.GetToken(PhpParserDoubleQuote, i)
}

func (s *StrContext) AllInterpolatedStringPart() []IInterpolatedStringPartContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInterpolatedStringPartContext)(nil)).Elem())
	var tst = make([]IInterpolatedStringPartContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInterpolatedStringPartContext)
		}
	}

	return tst
}

func (s *StrContext) InterpolatedStringPart(i int) IInterpolatedStringPartContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterpolatedStringPartContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInterpolatedStringPartContext)
}

func (s *StrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StrContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StrContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterStr(s)
	}
}

func (s *StrContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitStr(s)
	}
}

func (p *PhpParser) Str() (localctx IStrContext) {
	localctx = NewStrContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, PhpParserRULE_str)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(1477)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PhpParserStartHereDoc:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1456)
			p.Match(PhpParserStartHereDoc)
		}
		p.SetState(1458)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(1457)
					p.Match(PhpParserHereDocText)
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(1460)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 158, p.GetParserRuleContext())
		}

	case PhpParserStartNowDoc:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1462)
			p.Match(PhpParserStartNowDoc)
		}
		p.SetState(1464)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(1463)
					p.Match(PhpParserHereDocText)
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(1466)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 159, p.GetParserRuleContext())
		}

	case PhpParserSingleQuoteString:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1468)
			p.Match(PhpParserSingleQuoteString)
		}

	case PhpParserDoubleQuote:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1469)
			p.Match(PhpParserDoubleQuote)
		}
		p.SetState(1473)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for (((_la-43)&-(0x1f+1)) == 0 && ((1<<uint((_la-43)))&((1<<(PhpParserAbstract-43))|(1<<(PhpParserArray-43))|(1<<(PhpParserAs-43))|(1<<(PhpParserBinaryCast-43))|(1<<(PhpParserBoolType-43))|(1<<(PhpParserBooleanConstant-43))|(1<<(PhpParserBreak-43))|(1<<(PhpParserCallable-43))|(1<<(PhpParserCase-43))|(1<<(PhpParserCatch-43))|(1<<(PhpParserClass-43))|(1<<(PhpParserClone-43))|(1<<(PhpParserConst-43))|(1<<(PhpParserContinue-43))|(1<<(PhpParserDeclare-43))|(1<<(PhpParserDefault-43))|(1<<(PhpParserDo-43))|(1<<(PhpParserDoubleCast-43))|(1<<(PhpParserDoubleType-43))|(1<<(PhpParserEcho-43))|(1<<(PhpParserElse-43))|(1<<(PhpParserElseIf-43))|(1<<(PhpParserEmpty-43))|(1<<(PhpParserEndDeclare-43))|(1<<(PhpParserEndFor-43))|(1<<(PhpParserEndForeach-43))|(1<<(PhpParserEndIf-43))|(1<<(PhpParserEndSwitch-43))|(1<<(PhpParserEndWhile-43))|(1<<(PhpParserEval-43))|(1<<(PhpParserExit-43))|(1<<(PhpParserExtends-43)))) != 0) || (((_la-75)&-(0x1f+1)) == 0 && ((1<<uint((_la-75)))&((1<<(PhpParserFinal-75))|(1<<(PhpParserFinally-75))|(1<<(PhpParserFloatCast-75))|(1<<(PhpParserFor-75))|(1<<(PhpParserForeach-75))|(1<<(PhpParserFunction-75))|(1<<(PhpParserGlobal-75))|(1<<(PhpParserGoto-75))|(1<<(PhpParserIf-75))|(1<<(PhpParserImplements-75))|(1<<(PhpParserImport-75))|(1<<(PhpParserInclude-75))|(1<<(PhpParserIncludeOnce-75))|(1<<(PhpParserInstanceOf-75))|(1<<(PhpParserInsteadOf-75))|(1<<(PhpParserInt8Cast-75))|(1<<(PhpParserInt16Cast-75))|(1<<(PhpParserInt64Type-75))|(1<<(PhpParserIntType-75))|(1<<(PhpParserInterface-75))|(1<<(PhpParserIsSet-75))|(1<<(PhpParserList-75))|(1<<(PhpParserLogicalAnd-75))|(1<<(PhpParserLogicalOr-75))|(1<<(PhpParserLogicalXor-75))|(1<<(PhpParserNamespace-75))|(1<<(PhpParserNew-75))|(1<<(PhpParserNull-75))|(1<<(PhpParserObjectType-75))|(1<<(PhpParserParent_-75))|(1<<(PhpParserPartial-75))|(1<<(PhpParserPrint-75)))) != 0) || (((_la-107)&-(0x1f+1)) == 0 && ((1<<uint((_la-107)))&((1<<(PhpParserPrivate-107))|(1<<(PhpParserProtected-107))|(1<<(PhpParserPublic-107))|(1<<(PhpParserRequire-107))|(1<<(PhpParserRequireOnce-107))|(1<<(PhpParserResource-107))|(1<<(PhpParserReturn-107))|(1<<(PhpParserStatic-107))|(1<<(PhpParserStringType-107))|(1<<(PhpParserSwitch-107))|(1<<(PhpParserThrow-107))|(1<<(PhpParserTrait-107))|(1<<(PhpParserTry-107))|(1<<(PhpParserTypeof-107))|(1<<(PhpParserUintCast-107))|(1<<(PhpParserUnicodeCast-107))|(1<<(PhpParserUnset-107))|(1<<(PhpParserUse-107))|(1<<(PhpParserVar-107))|(1<<(PhpParserWhile-107))|(1<<(PhpParserYield-107))|(1<<(PhpParserGet-107))|(1<<(PhpParserSet-107))|(1<<(PhpParserCall-107))|(1<<(PhpParserCallStatic-107))|(1<<(PhpParserConstructor-107))|(1<<(PhpParserDestruct-107))|(1<<(PhpParserWakeup-107))|(1<<(PhpParserSleep-107))|(1<<(PhpParserAutoload-107))|(1<<(PhpParserIsSet__-107))|(1<<(PhpParserUnset__-107)))) != 0) || (((_la-139)&-(0x1f+1)) == 0 && ((1<<uint((_la-139)))&((1<<(PhpParserToString__-139))|(1<<(PhpParserInvoke-139))|(1<<(PhpParserSetState-139))|(1<<(PhpParserClone__-139))|(1<<(PhpParserDebugInfo-139))|(1<<(PhpParserNamespace__-139))|(1<<(PhpParserClass__-139))|(1<<(PhpParserTraic__-139))|(1<<(PhpParserFunction__-139))|(1<<(PhpParserMethod__-139))|(1<<(PhpParserLine__-139))|(1<<(PhpParserFile__-139))|(1<<(PhpParserDir__-139)))) != 0) || (((_la-182)&-(0x1f+1)) == 0 && ((1<<uint((_la-182)))&((1<<(PhpParserNamespaceSeparator-182))|(1<<(PhpParserDollar-182))|(1<<(PhpParserOpenRoundBracket-182))|(1<<(PhpParserVarName-182))|(1<<(PhpParserLabel-182)))) != 0) || _la == PhpParserStringPart {
			{
				p.SetState(1470)
				p.InterpolatedStringPart()
			}

			p.SetState(1475)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1476)
			p.Match(PhpParserDoubleQuote)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IInterpolatedStringPartContext is an interface to support dynamic dispatch.
type IInterpolatedStringPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInterpolatedStringPartContext differentiates from other interfaces.
	IsInterpolatedStringPartContext()
}

type InterpolatedStringPartContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterpolatedStringPartContext() *InterpolatedStringPartContext {
	var p = new(InterpolatedStringPartContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_interpolatedStringPart
	return p
}

func (*InterpolatedStringPartContext) IsInterpolatedStringPartContext() {}

func NewInterpolatedStringPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterpolatedStringPartContext {
	var p = new(InterpolatedStringPartContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_interpolatedStringPart

	return p
}

func (s *InterpolatedStringPartContext) GetParser() antlr.Parser { return s.parser }

func (s *InterpolatedStringPartContext) StringPart() antlr.TerminalNode {
	return s.GetToken(PhpParserStringPart, 0)
}

func (s *InterpolatedStringPartContext) Chain() IChainContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IChainContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IChainContext)
}

func (s *InterpolatedStringPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterpolatedStringPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterpolatedStringPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterInterpolatedStringPart(s)
	}
}

func (s *InterpolatedStringPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitInterpolatedStringPart(s)
	}
}

func (p *PhpParser) InterpolatedStringPart() (localctx IInterpolatedStringPartContext) {
	localctx = NewInterpolatedStringPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, PhpParserRULE_interpolatedStringPart)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1481)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PhpParserStringPart:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1479)
			p.Match(PhpParserStringPart)
		}

	case PhpParserAbstract, PhpParserArray, PhpParserAs, PhpParserBinaryCast, PhpParserBoolType, PhpParserBooleanConstant, PhpParserBreak, PhpParserCallable, PhpParserCase, PhpParserCatch, PhpParserClass, PhpParserClone, PhpParserConst, PhpParserContinue, PhpParserDeclare, PhpParserDefault, PhpParserDo, PhpParserDoubleCast, PhpParserDoubleType, PhpParserEcho, PhpParserElse, PhpParserElseIf, PhpParserEmpty, PhpParserEndDeclare, PhpParserEndFor, PhpParserEndForeach, PhpParserEndIf, PhpParserEndSwitch, PhpParserEndWhile, PhpParserEval, PhpParserExit, PhpParserExtends, PhpParserFinal, PhpParserFinally, PhpParserFloatCast, PhpParserFor, PhpParserForeach, PhpParserFunction, PhpParserGlobal, PhpParserGoto, PhpParserIf, PhpParserImplements, PhpParserImport, PhpParserInclude, PhpParserIncludeOnce, PhpParserInstanceOf, PhpParserInsteadOf, PhpParserInt8Cast, PhpParserInt16Cast, PhpParserInt64Type, PhpParserIntType, PhpParserInterface, PhpParserIsSet, PhpParserList, PhpParserLogicalAnd, PhpParserLogicalOr, PhpParserLogicalXor, PhpParserNamespace, PhpParserNew, PhpParserNull, PhpParserObjectType, PhpParserParent_, PhpParserPartial, PhpParserPrint, PhpParserPrivate, PhpParserProtected, PhpParserPublic, PhpParserRequire, PhpParserRequireOnce, PhpParserResource, PhpParserReturn, PhpParserStatic, PhpParserStringType, PhpParserSwitch, PhpParserThrow, PhpParserTrait, PhpParserTry, PhpParserTypeof, PhpParserUintCast, PhpParserUnicodeCast, PhpParserUnset, PhpParserUse, PhpParserVar, PhpParserWhile, PhpParserYield, PhpParserGet, PhpParserSet, PhpParserCall, PhpParserCallStatic, PhpParserConstructor, PhpParserDestruct, PhpParserWakeup, PhpParserSleep, PhpParserAutoload, PhpParserIsSet__, PhpParserUnset__, PhpParserToString__, PhpParserInvoke, PhpParserSetState, PhpParserClone__, PhpParserDebugInfo, PhpParserNamespace__, PhpParserClass__, PhpParserTraic__, PhpParserFunction__, PhpParserMethod__, PhpParserLine__, PhpParserFile__, PhpParserDir__, PhpParserNamespaceSeparator, PhpParserDollar, PhpParserOpenRoundBracket, PhpParserVarName, PhpParserLabel:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1480)
			p.Chain()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IChainListContext is an interface to support dynamic dispatch.
type IChainListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsChainListContext differentiates from other interfaces.
	IsChainListContext()
}

type ChainListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyChainListContext() *ChainListContext {
	var p = new(ChainListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_chainList
	return p
}

func (*ChainListContext) IsChainListContext() {}

func NewChainListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ChainListContext {
	var p = new(ChainListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_chainList

	return p
}

func (s *ChainListContext) GetParser() antlr.Parser { return s.parser }

func (s *ChainListContext) AllChain() []IChainContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IChainContext)(nil)).Elem())
	var tst = make([]IChainContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IChainContext)
		}
	}

	return tst
}

func (s *ChainListContext) Chain(i int) IChainContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IChainContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IChainContext)
}

func (s *ChainListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ChainListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ChainListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterChainList(s)
	}
}

func (s *ChainListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitChainList(s)
	}
}

func (p *PhpParser) ChainList() (localctx IChainListContext) {
	localctx = NewChainListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, PhpParserRULE_chainList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1483)
		p.Chain()
	}
	p.SetState(1488)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PhpParserComma {
		{
			p.SetState(1484)
			p.Match(PhpParserComma)
		}
		{
			p.SetState(1485)
			p.Chain()
		}

		p.SetState(1490)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IChainContext is an interface to support dynamic dispatch.
type IChainContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsChainContext differentiates from other interfaces.
	IsChainContext()
}

type ChainContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyChainContext() *ChainContext {
	var p = new(ChainContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_chain
	return p
}

func (*ChainContext) IsChainContext() {}

func NewChainContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ChainContext {
	var p = new(ChainContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_chain

	return p
}

func (s *ChainContext) GetParser() antlr.Parser { return s.parser }

func (s *ChainContext) ChainBase() IChainBaseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IChainBaseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IChainBaseContext)
}

func (s *ChainContext) FunctionCall() IFunctionCallContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionCallContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionCallContext)
}

func (s *ChainContext) NewExpr() INewExprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INewExprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INewExprContext)
}

func (s *ChainContext) AllMemberAccess() []IMemberAccessContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMemberAccessContext)(nil)).Elem())
	var tst = make([]IMemberAccessContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMemberAccessContext)
		}
	}

	return tst
}

func (s *ChainContext) MemberAccess(i int) IMemberAccessContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMemberAccessContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMemberAccessContext)
}

func (s *ChainContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ChainContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ChainContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterChain(s)
	}
}

func (s *ChainContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitChain(s)
	}
}

func (p *PhpParser) Chain() (localctx IChainContext) {
	localctx = NewChainContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, PhpParserRULE_chain)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1497)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 164, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1491)
			p.ChainBase()
		}

	case 2:
		{
			p.SetState(1492)
			p.FunctionCall()
		}

	case 3:
		{
			p.SetState(1493)
			p.Match(PhpParserOpenRoundBracket)
		}
		{
			p.SetState(1494)
			p.NewExpr()
		}
		{
			p.SetState(1495)
			p.Match(PhpParserCloseRoundBracket)
		}

	}
	p.SetState(1502)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 165, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1499)
				p.MemberAccess()
			}

		}
		p.SetState(1504)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 165, p.GetParserRuleContext())
	}

	return localctx
}

// IMemberAccessContext is an interface to support dynamic dispatch.
type IMemberAccessContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMemberAccessContext differentiates from other interfaces.
	IsMemberAccessContext()
}

type MemberAccessContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMemberAccessContext() *MemberAccessContext {
	var p = new(MemberAccessContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_memberAccess
	return p
}

func (*MemberAccessContext) IsMemberAccessContext() {}

func NewMemberAccessContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MemberAccessContext {
	var p = new(MemberAccessContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_memberAccess

	return p
}

func (s *MemberAccessContext) GetParser() antlr.Parser { return s.parser }

func (s *MemberAccessContext) KeyedFieldName() IKeyedFieldNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IKeyedFieldNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IKeyedFieldNameContext)
}

func (s *MemberAccessContext) ActualArguments() IActualArgumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IActualArgumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IActualArgumentsContext)
}

func (s *MemberAccessContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MemberAccessContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MemberAccessContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterMemberAccess(s)
	}
}

func (s *MemberAccessContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitMemberAccess(s)
	}
}

func (p *PhpParser) MemberAccess() (localctx IMemberAccessContext) {
	localctx = NewMemberAccessContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, PhpParserRULE_memberAccess)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1505)
		p.Match(PhpParserObjectOperator)
	}
	{
		p.SetState(1506)
		p.KeyedFieldName()
	}
	p.SetState(1508)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 166, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1507)
			p.ActualArguments()
		}

	}

	return localctx
}

// IFunctionCallContext is an interface to support dynamic dispatch.
type IFunctionCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionCallContext differentiates from other interfaces.
	IsFunctionCallContext()
}

type FunctionCallContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionCallContext() *FunctionCallContext {
	var p = new(FunctionCallContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_functionCall
	return p
}

func (*FunctionCallContext) IsFunctionCallContext() {}

func NewFunctionCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionCallContext {
	var p = new(FunctionCallContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_functionCall

	return p
}

func (s *FunctionCallContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionCallContext) FunctionCallName() IFunctionCallNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionCallNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionCallNameContext)
}

func (s *FunctionCallContext) ActualArguments() IActualArgumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IActualArgumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IActualArgumentsContext)
}

func (s *FunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterFunctionCall(s)
	}
}

func (s *FunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitFunctionCall(s)
	}
}

func (p *PhpParser) FunctionCall() (localctx IFunctionCallContext) {
	localctx = NewFunctionCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, PhpParserRULE_functionCall)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1510)
		p.FunctionCallName()
	}
	{
		p.SetState(1511)
		p.ActualArguments()
	}

	return localctx
}

// IFunctionCallNameContext is an interface to support dynamic dispatch.
type IFunctionCallNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionCallNameContext differentiates from other interfaces.
	IsFunctionCallNameContext()
}

type FunctionCallNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionCallNameContext() *FunctionCallNameContext {
	var p = new(FunctionCallNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_functionCallName
	return p
}

func (*FunctionCallNameContext) IsFunctionCallNameContext() {}

func NewFunctionCallNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionCallNameContext {
	var p = new(FunctionCallNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_functionCallName

	return p
}

func (s *FunctionCallNameContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionCallNameContext) QualifiedNamespaceName() IQualifiedNamespaceNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNamespaceNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNamespaceNameContext)
}

func (s *FunctionCallNameContext) ClassConstant() IClassConstantContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassConstantContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassConstantContext)
}

func (s *FunctionCallNameContext) ChainBase() IChainBaseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IChainBaseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IChainBaseContext)
}

func (s *FunctionCallNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionCallNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionCallNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterFunctionCallName(s)
	}
}

func (s *FunctionCallNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitFunctionCallName(s)
	}
}

func (p *PhpParser) FunctionCallName() (localctx IFunctionCallNameContext) {
	localctx = NewFunctionCallNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, PhpParserRULE_functionCallName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1516)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 167, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1513)
			p.QualifiedNamespaceName()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1514)
			p.ClassConstant()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1515)
			p.ChainBase()
		}

	}

	return localctx
}

// IActualArgumentsContext is an interface to support dynamic dispatch.
type IActualArgumentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsActualArgumentsContext differentiates from other interfaces.
	IsActualArgumentsContext()
}

type ActualArgumentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyActualArgumentsContext() *ActualArgumentsContext {
	var p = new(ActualArgumentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_actualArguments
	return p
}

func (*ActualArgumentsContext) IsActualArgumentsContext() {}

func NewActualArgumentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ActualArgumentsContext {
	var p = new(ActualArgumentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_actualArguments

	return p
}

func (s *ActualArgumentsContext) GetParser() antlr.Parser { return s.parser }

func (s *ActualArgumentsContext) Arguments() IArgumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArgumentsContext)
}

func (s *ActualArgumentsContext) GenericDynamicArgs() IGenericDynamicArgsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGenericDynamicArgsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGenericDynamicArgsContext)
}

func (s *ActualArgumentsContext) AllSquareCurlyExpression() []ISquareCurlyExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISquareCurlyExpressionContext)(nil)).Elem())
	var tst = make([]ISquareCurlyExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISquareCurlyExpressionContext)
		}
	}

	return tst
}

func (s *ActualArgumentsContext) SquareCurlyExpression(i int) ISquareCurlyExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISquareCurlyExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISquareCurlyExpressionContext)
}

func (s *ActualArgumentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ActualArgumentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ActualArgumentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterActualArguments(s)
	}
}

func (s *ActualArgumentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitActualArguments(s)
	}
}

func (p *PhpParser) ActualArguments() (localctx IActualArgumentsContext) {
	localctx = NewActualArgumentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 228, PhpParserRULE_actualArguments)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1519)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == PhpParserLgeneric {
		{
			p.SetState(1518)
			p.GenericDynamicArgs()
		}

	}
	{
		p.SetState(1521)
		p.Arguments()
	}
	p.SetState(1525)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 169, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1522)
				p.SquareCurlyExpression()
			}

		}
		p.SetState(1527)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 169, p.GetParserRuleContext())
	}

	return localctx
}

// IChainBaseContext is an interface to support dynamic dispatch.
type IChainBaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsChainBaseContext differentiates from other interfaces.
	IsChainBaseContext()
}

type ChainBaseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyChainBaseContext() *ChainBaseContext {
	var p = new(ChainBaseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_chainBase
	return p
}

func (*ChainBaseContext) IsChainBaseContext() {}

func NewChainBaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ChainBaseContext {
	var p = new(ChainBaseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_chainBase

	return p
}

func (s *ChainBaseContext) GetParser() antlr.Parser { return s.parser }

func (s *ChainBaseContext) AllKeyedVariable() []IKeyedVariableContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IKeyedVariableContext)(nil)).Elem())
	var tst = make([]IKeyedVariableContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IKeyedVariableContext)
		}
	}

	return tst
}

func (s *ChainBaseContext) KeyedVariable(i int) IKeyedVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IKeyedVariableContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IKeyedVariableContext)
}

func (s *ChainBaseContext) QualifiedStaticTypeRef() IQualifiedStaticTypeRefContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedStaticTypeRefContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedStaticTypeRefContext)
}

func (s *ChainBaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ChainBaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ChainBaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterChainBase(s)
	}
}

func (s *ChainBaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitChainBase(s)
	}
}

func (p *PhpParser) ChainBase() (localctx IChainBaseContext) {
	localctx = NewChainBaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 230, PhpParserRULE_chainBase)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1537)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PhpParserDollar, PhpParserVarName:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1528)
			p.KeyedVariable()
		}
		p.SetState(1531)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 170, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1529)
				p.Match(PhpParserDoubleColon)
			}
			{
				p.SetState(1530)
				p.KeyedVariable()
			}

		}

	case PhpParserAbstract, PhpParserArray, PhpParserAs, PhpParserBinaryCast, PhpParserBoolType, PhpParserBooleanConstant, PhpParserBreak, PhpParserCallable, PhpParserCase, PhpParserCatch, PhpParserClass, PhpParserClone, PhpParserConst, PhpParserContinue, PhpParserDeclare, PhpParserDefault, PhpParserDo, PhpParserDoubleCast, PhpParserDoubleType, PhpParserEcho, PhpParserElse, PhpParserElseIf, PhpParserEmpty, PhpParserEndDeclare, PhpParserEndFor, PhpParserEndForeach, PhpParserEndIf, PhpParserEndSwitch, PhpParserEndWhile, PhpParserEval, PhpParserExit, PhpParserExtends, PhpParserFinal, PhpParserFinally, PhpParserFloatCast, PhpParserFor, PhpParserForeach, PhpParserFunction, PhpParserGlobal, PhpParserGoto, PhpParserIf, PhpParserImplements, PhpParserImport, PhpParserInclude, PhpParserIncludeOnce, PhpParserInstanceOf, PhpParserInsteadOf, PhpParserInt8Cast, PhpParserInt16Cast, PhpParserInt64Type, PhpParserIntType, PhpParserInterface, PhpParserIsSet, PhpParserList, PhpParserLogicalAnd, PhpParserLogicalOr, PhpParserLogicalXor, PhpParserNamespace, PhpParserNew, PhpParserNull, PhpParserObjectType, PhpParserParent_, PhpParserPartial, PhpParserPrint, PhpParserPrivate, PhpParserProtected, PhpParserPublic, PhpParserRequire, PhpParserRequireOnce, PhpParserResource, PhpParserReturn, PhpParserStatic, PhpParserStringType, PhpParserSwitch, PhpParserThrow, PhpParserTrait, PhpParserTry, PhpParserTypeof, PhpParserUintCast, PhpParserUnicodeCast, PhpParserUnset, PhpParserUse, PhpParserVar, PhpParserWhile, PhpParserYield, PhpParserGet, PhpParserSet, PhpParserCall, PhpParserCallStatic, PhpParserConstructor, PhpParserDestruct, PhpParserWakeup, PhpParserSleep, PhpParserAutoload, PhpParserIsSet__, PhpParserUnset__, PhpParserToString__, PhpParserInvoke, PhpParserSetState, PhpParserClone__, PhpParserDebugInfo, PhpParserNamespace__, PhpParserClass__, PhpParserTraic__, PhpParserFunction__, PhpParserMethod__, PhpParserLine__, PhpParserFile__, PhpParserDir__, PhpParserNamespaceSeparator, PhpParserLabel:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1533)
			p.QualifiedStaticTypeRef()
		}
		{
			p.SetState(1534)
			p.Match(PhpParserDoubleColon)
		}
		{
			p.SetState(1535)
			p.KeyedVariable()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IKeyedFieldNameContext is an interface to support dynamic dispatch.
type IKeyedFieldNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsKeyedFieldNameContext differentiates from other interfaces.
	IsKeyedFieldNameContext()
}

type KeyedFieldNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeyedFieldNameContext() *KeyedFieldNameContext {
	var p = new(KeyedFieldNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_keyedFieldName
	return p
}

func (*KeyedFieldNameContext) IsKeyedFieldNameContext() {}

func NewKeyedFieldNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeyedFieldNameContext {
	var p = new(KeyedFieldNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_keyedFieldName

	return p
}

func (s *KeyedFieldNameContext) GetParser() antlr.Parser { return s.parser }

func (s *KeyedFieldNameContext) KeyedSimpleFieldName() IKeyedSimpleFieldNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IKeyedSimpleFieldNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IKeyedSimpleFieldNameContext)
}

func (s *KeyedFieldNameContext) KeyedVariable() IKeyedVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IKeyedVariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IKeyedVariableContext)
}

func (s *KeyedFieldNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeyedFieldNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KeyedFieldNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterKeyedFieldName(s)
	}
}

func (s *KeyedFieldNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitKeyedFieldName(s)
	}
}

func (p *PhpParser) KeyedFieldName() (localctx IKeyedFieldNameContext) {
	localctx = NewKeyedFieldNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 232, PhpParserRULE_keyedFieldName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1541)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PhpParserAbstract, PhpParserArray, PhpParserAs, PhpParserBinaryCast, PhpParserBoolType, PhpParserBooleanConstant, PhpParserBreak, PhpParserCallable, PhpParserCase, PhpParserCatch, PhpParserClass, PhpParserClone, PhpParserConst, PhpParserContinue, PhpParserDeclare, PhpParserDefault, PhpParserDo, PhpParserDoubleCast, PhpParserDoubleType, PhpParserEcho, PhpParserElse, PhpParserElseIf, PhpParserEmpty, PhpParserEndDeclare, PhpParserEndFor, PhpParserEndForeach, PhpParserEndIf, PhpParserEndSwitch, PhpParserEndWhile, PhpParserEval, PhpParserExit, PhpParserExtends, PhpParserFinal, PhpParserFinally, PhpParserFloatCast, PhpParserFor, PhpParserForeach, PhpParserFunction, PhpParserGlobal, PhpParserGoto, PhpParserIf, PhpParserImplements, PhpParserImport, PhpParserInclude, PhpParserIncludeOnce, PhpParserInstanceOf, PhpParserInsteadOf, PhpParserInt8Cast, PhpParserInt16Cast, PhpParserInt64Type, PhpParserIntType, PhpParserInterface, PhpParserIsSet, PhpParserList, PhpParserLogicalAnd, PhpParserLogicalOr, PhpParserLogicalXor, PhpParserNamespace, PhpParserNew, PhpParserNull, PhpParserObjectType, PhpParserParent_, PhpParserPartial, PhpParserPrint, PhpParserPrivate, PhpParserProtected, PhpParserPublic, PhpParserRequire, PhpParserRequireOnce, PhpParserResource, PhpParserReturn, PhpParserStatic, PhpParserStringType, PhpParserSwitch, PhpParserThrow, PhpParserTrait, PhpParserTry, PhpParserTypeof, PhpParserUintCast, PhpParserUnicodeCast, PhpParserUnset, PhpParserUse, PhpParserVar, PhpParserWhile, PhpParserYield, PhpParserGet, PhpParserSet, PhpParserCall, PhpParserCallStatic, PhpParserConstructor, PhpParserDestruct, PhpParserWakeup, PhpParserSleep, PhpParserAutoload, PhpParserIsSet__, PhpParserUnset__, PhpParserToString__, PhpParserInvoke, PhpParserSetState, PhpParserClone__, PhpParserDebugInfo, PhpParserNamespace__, PhpParserClass__, PhpParserTraic__, PhpParserFunction__, PhpParserMethod__, PhpParserLine__, PhpParserFile__, PhpParserDir__, PhpParserOpenCurlyBracket, PhpParserLabel:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1539)
			p.KeyedSimpleFieldName()
		}

	case PhpParserDollar, PhpParserVarName:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1540)
			p.KeyedVariable()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IKeyedSimpleFieldNameContext is an interface to support dynamic dispatch.
type IKeyedSimpleFieldNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsKeyedSimpleFieldNameContext differentiates from other interfaces.
	IsKeyedSimpleFieldNameContext()
}

type KeyedSimpleFieldNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeyedSimpleFieldNameContext() *KeyedSimpleFieldNameContext {
	var p = new(KeyedSimpleFieldNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_keyedSimpleFieldName
	return p
}

func (*KeyedSimpleFieldNameContext) IsKeyedSimpleFieldNameContext() {}

func NewKeyedSimpleFieldNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeyedSimpleFieldNameContext {
	var p = new(KeyedSimpleFieldNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_keyedSimpleFieldName

	return p
}

func (s *KeyedSimpleFieldNameContext) GetParser() antlr.Parser { return s.parser }

func (s *KeyedSimpleFieldNameContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *KeyedSimpleFieldNameContext) OpenCurlyBracket() antlr.TerminalNode {
	return s.GetToken(PhpParserOpenCurlyBracket, 0)
}

func (s *KeyedSimpleFieldNameContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *KeyedSimpleFieldNameContext) AllSquareCurlyExpression() []ISquareCurlyExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISquareCurlyExpressionContext)(nil)).Elem())
	var tst = make([]ISquareCurlyExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISquareCurlyExpressionContext)
		}
	}

	return tst
}

func (s *KeyedSimpleFieldNameContext) SquareCurlyExpression(i int) ISquareCurlyExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISquareCurlyExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISquareCurlyExpressionContext)
}

func (s *KeyedSimpleFieldNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeyedSimpleFieldNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KeyedSimpleFieldNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterKeyedSimpleFieldName(s)
	}
}

func (s *KeyedSimpleFieldNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitKeyedSimpleFieldName(s)
	}
}

func (p *PhpParser) KeyedSimpleFieldName() (localctx IKeyedSimpleFieldNameContext) {
	localctx = NewKeyedSimpleFieldNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 234, PhpParserRULE_keyedSimpleFieldName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1548)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PhpParserAbstract, PhpParserArray, PhpParserAs, PhpParserBinaryCast, PhpParserBoolType, PhpParserBooleanConstant, PhpParserBreak, PhpParserCallable, PhpParserCase, PhpParserCatch, PhpParserClass, PhpParserClone, PhpParserConst, PhpParserContinue, PhpParserDeclare, PhpParserDefault, PhpParserDo, PhpParserDoubleCast, PhpParserDoubleType, PhpParserEcho, PhpParserElse, PhpParserElseIf, PhpParserEmpty, PhpParserEndDeclare, PhpParserEndFor, PhpParserEndForeach, PhpParserEndIf, PhpParserEndSwitch, PhpParserEndWhile, PhpParserEval, PhpParserExit, PhpParserExtends, PhpParserFinal, PhpParserFinally, PhpParserFloatCast, PhpParserFor, PhpParserForeach, PhpParserFunction, PhpParserGlobal, PhpParserGoto, PhpParserIf, PhpParserImplements, PhpParserImport, PhpParserInclude, PhpParserIncludeOnce, PhpParserInstanceOf, PhpParserInsteadOf, PhpParserInt8Cast, PhpParserInt16Cast, PhpParserInt64Type, PhpParserIntType, PhpParserInterface, PhpParserIsSet, PhpParserList, PhpParserLogicalAnd, PhpParserLogicalOr, PhpParserLogicalXor, PhpParserNamespace, PhpParserNew, PhpParserNull, PhpParserObjectType, PhpParserParent_, PhpParserPartial, PhpParserPrint, PhpParserPrivate, PhpParserProtected, PhpParserPublic, PhpParserRequire, PhpParserRequireOnce, PhpParserResource, PhpParserReturn, PhpParserStatic, PhpParserStringType, PhpParserSwitch, PhpParserThrow, PhpParserTrait, PhpParserTry, PhpParserTypeof, PhpParserUintCast, PhpParserUnicodeCast, PhpParserUnset, PhpParserUse, PhpParserVar, PhpParserWhile, PhpParserYield, PhpParserGet, PhpParserSet, PhpParserCall, PhpParserCallStatic, PhpParserConstructor, PhpParserDestruct, PhpParserWakeup, PhpParserSleep, PhpParserAutoload, PhpParserIsSet__, PhpParserUnset__, PhpParserToString__, PhpParserInvoke, PhpParserSetState, PhpParserClone__, PhpParserDebugInfo, PhpParserNamespace__, PhpParserClass__, PhpParserTraic__, PhpParserFunction__, PhpParserMethod__, PhpParserLine__, PhpParserFile__, PhpParserDir__, PhpParserLabel:
		{
			p.SetState(1543)
			p.Identifier()
		}

	case PhpParserOpenCurlyBracket:
		{
			p.SetState(1544)
			p.Match(PhpParserOpenCurlyBracket)
		}
		{
			p.SetState(1545)
			p.expression(0)
		}
		{
			p.SetState(1546)
			p.Match(PhpParserCloseCurlyBracket)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(1553)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 174, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1550)
				p.SquareCurlyExpression()
			}

		}
		p.SetState(1555)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 174, p.GetParserRuleContext())
	}

	return localctx
}

// IKeyedVariableContext is an interface to support dynamic dispatch.
type IKeyedVariableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsKeyedVariableContext differentiates from other interfaces.
	IsKeyedVariableContext()
}

type KeyedVariableContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeyedVariableContext() *KeyedVariableContext {
	var p = new(KeyedVariableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_keyedVariable
	return p
}

func (*KeyedVariableContext) IsKeyedVariableContext() {}

func NewKeyedVariableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeyedVariableContext {
	var p = new(KeyedVariableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_keyedVariable

	return p
}

func (s *KeyedVariableContext) GetParser() antlr.Parser { return s.parser }

func (s *KeyedVariableContext) VarName() antlr.TerminalNode {
	return s.GetToken(PhpParserVarName, 0)
}

func (s *KeyedVariableContext) AllDollar() []antlr.TerminalNode {
	return s.GetTokens(PhpParserDollar)
}

func (s *KeyedVariableContext) Dollar(i int) antlr.TerminalNode {
	return s.GetToken(PhpParserDollar, i)
}

func (s *KeyedVariableContext) OpenCurlyBracket() antlr.TerminalNode {
	return s.GetToken(PhpParserOpenCurlyBracket, 0)
}

func (s *KeyedVariableContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *KeyedVariableContext) AllSquareCurlyExpression() []ISquareCurlyExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISquareCurlyExpressionContext)(nil)).Elem())
	var tst = make([]ISquareCurlyExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISquareCurlyExpressionContext)
		}
	}

	return tst
}

func (s *KeyedVariableContext) SquareCurlyExpression(i int) ISquareCurlyExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISquareCurlyExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISquareCurlyExpressionContext)
}

func (s *KeyedVariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeyedVariableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KeyedVariableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterKeyedVariable(s)
	}
}

func (s *KeyedVariableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitKeyedVariable(s)
	}
}

func (p *PhpParser) KeyedVariable() (localctx IKeyedVariableContext) {
	localctx = NewKeyedVariableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, PhpParserRULE_keyedVariable)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1559)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 175, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1556)
				p.Match(PhpParserDollar)
			}

		}
		p.SetState(1561)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 175, p.GetParserRuleContext())
	}
	p.SetState(1568)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PhpParserVarName:
		{
			p.SetState(1562)
			p.Match(PhpParserVarName)
		}

	case PhpParserDollar:
		{
			p.SetState(1563)
			p.Match(PhpParserDollar)
		}
		{
			p.SetState(1564)
			p.Match(PhpParserOpenCurlyBracket)
		}
		{
			p.SetState(1565)
			p.expression(0)
		}
		{
			p.SetState(1566)
			p.Match(PhpParserCloseCurlyBracket)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(1573)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 177, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1570)
				p.SquareCurlyExpression()
			}

		}
		p.SetState(1575)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 177, p.GetParserRuleContext())
	}

	return localctx
}

// ISquareCurlyExpressionContext is an interface to support dynamic dispatch.
type ISquareCurlyExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSquareCurlyExpressionContext differentiates from other interfaces.
	IsSquareCurlyExpressionContext()
}

type SquareCurlyExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySquareCurlyExpressionContext() *SquareCurlyExpressionContext {
	var p = new(SquareCurlyExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_squareCurlyExpression
	return p
}

func (*SquareCurlyExpressionContext) IsSquareCurlyExpressionContext() {}

func NewSquareCurlyExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SquareCurlyExpressionContext {
	var p = new(SquareCurlyExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_squareCurlyExpression

	return p
}

func (s *SquareCurlyExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *SquareCurlyExpressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SquareCurlyExpressionContext) OpenCurlyBracket() antlr.TerminalNode {
	return s.GetToken(PhpParserOpenCurlyBracket, 0)
}

func (s *SquareCurlyExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SquareCurlyExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SquareCurlyExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterSquareCurlyExpression(s)
	}
}

func (s *SquareCurlyExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitSquareCurlyExpression(s)
	}
}

func (p *PhpParser) SquareCurlyExpression() (localctx ISquareCurlyExpressionContext) {
	localctx = NewSquareCurlyExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 238, PhpParserRULE_squareCurlyExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1585)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case PhpParserOpenSquareBracket:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1576)
			p.Match(PhpParserOpenSquareBracket)
		}
		p.SetState(1578)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la-43)&-(0x1f+1)) == 0 && ((1<<uint((_la-43)))&((1<<(PhpParserAbstract-43))|(1<<(PhpParserArray-43))|(1<<(PhpParserAs-43))|(1<<(PhpParserBinaryCast-43))|(1<<(PhpParserBoolType-43))|(1<<(PhpParserBooleanConstant-43))|(1<<(PhpParserBreak-43))|(1<<(PhpParserCallable-43))|(1<<(PhpParserCase-43))|(1<<(PhpParserCatch-43))|(1<<(PhpParserClass-43))|(1<<(PhpParserClone-43))|(1<<(PhpParserConst-43))|(1<<(PhpParserContinue-43))|(1<<(PhpParserDeclare-43))|(1<<(PhpParserDefault-43))|(1<<(PhpParserDo-43))|(1<<(PhpParserDoubleCast-43))|(1<<(PhpParserDoubleType-43))|(1<<(PhpParserEcho-43))|(1<<(PhpParserElse-43))|(1<<(PhpParserElseIf-43))|(1<<(PhpParserEmpty-43))|(1<<(PhpParserEndDeclare-43))|(1<<(PhpParserEndFor-43))|(1<<(PhpParserEndForeach-43))|(1<<(PhpParserEndIf-43))|(1<<(PhpParserEndSwitch-43))|(1<<(PhpParserEndWhile-43))|(1<<(PhpParserEval-43))|(1<<(PhpParserExit-43))|(1<<(PhpParserExtends-43)))) != 0) || (((_la-75)&-(0x1f+1)) == 0 && ((1<<uint((_la-75)))&((1<<(PhpParserFinal-75))|(1<<(PhpParserFinally-75))|(1<<(PhpParserFloatCast-75))|(1<<(PhpParserFor-75))|(1<<(PhpParserForeach-75))|(1<<(PhpParserFunction-75))|(1<<(PhpParserGlobal-75))|(1<<(PhpParserGoto-75))|(1<<(PhpParserIf-75))|(1<<(PhpParserImplements-75))|(1<<(PhpParserImport-75))|(1<<(PhpParserInclude-75))|(1<<(PhpParserIncludeOnce-75))|(1<<(PhpParserInstanceOf-75))|(1<<(PhpParserInsteadOf-75))|(1<<(PhpParserInt8Cast-75))|(1<<(PhpParserInt16Cast-75))|(1<<(PhpParserInt64Type-75))|(1<<(PhpParserIntType-75))|(1<<(PhpParserInterface-75))|(1<<(PhpParserIsSet-75))|(1<<(PhpParserList-75))|(1<<(PhpParserLogicalAnd-75))|(1<<(PhpParserLogicalOr-75))|(1<<(PhpParserLogicalXor-75))|(1<<(PhpParserNamespace-75))|(1<<(PhpParserNew-75))|(1<<(PhpParserNull-75))|(1<<(PhpParserObjectType-75))|(1<<(PhpParserParent_-75))|(1<<(PhpParserPartial-75))|(1<<(PhpParserPrint-75)))) != 0) || (((_la-107)&-(0x1f+1)) == 0 && ((1<<uint((_la-107)))&((1<<(PhpParserPrivate-107))|(1<<(PhpParserProtected-107))|(1<<(PhpParserPublic-107))|(1<<(PhpParserRequire-107))|(1<<(PhpParserRequireOnce-107))|(1<<(PhpParserResource-107))|(1<<(PhpParserReturn-107))|(1<<(PhpParserStatic-107))|(1<<(PhpParserStringType-107))|(1<<(PhpParserSwitch-107))|(1<<(PhpParserThrow-107))|(1<<(PhpParserTrait-107))|(1<<(PhpParserTry-107))|(1<<(PhpParserTypeof-107))|(1<<(PhpParserUintCast-107))|(1<<(PhpParserUnicodeCast-107))|(1<<(PhpParserUnset-107))|(1<<(PhpParserUse-107))|(1<<(PhpParserVar-107))|(1<<(PhpParserWhile-107))|(1<<(PhpParserYield-107))|(1<<(PhpParserGet-107))|(1<<(PhpParserSet-107))|(1<<(PhpParserCall-107))|(1<<(PhpParserCallStatic-107))|(1<<(PhpParserConstructor-107))|(1<<(PhpParserDestruct-107))|(1<<(PhpParserWakeup-107))|(1<<(PhpParserSleep-107))|(1<<(PhpParserAutoload-107))|(1<<(PhpParserIsSet__-107))|(1<<(PhpParserUnset__-107)))) != 0) || (((_la-139)&-(0x1f+1)) == 0 && ((1<<uint((_la-139)))&((1<<(PhpParserToString__-139))|(1<<(PhpParserInvoke-139))|(1<<(PhpParserSetState-139))|(1<<(PhpParserClone__-139))|(1<<(PhpParserDebugInfo-139))|(1<<(PhpParserNamespace__-139))|(1<<(PhpParserClass__-139))|(1<<(PhpParserTraic__-139))|(1<<(PhpParserFunction__-139))|(1<<(PhpParserMethod__-139))|(1<<(PhpParserLine__-139))|(1<<(PhpParserFile__-139))|(1<<(PhpParserDir__-139))|(1<<(PhpParserInc-139))|(1<<(PhpParserDec-139)))) != 0) || (((_la-182)&-(0x1f+1)) == 0 && ((1<<uint((_la-182)))&((1<<(PhpParserNamespaceSeparator-182))|(1<<(PhpParserBang-182))|(1<<(PhpParserPlus-182))|(1<<(PhpParserMinus-182))|(1<<(PhpParserTilde-182))|(1<<(PhpParserSuppressWarnings-182))|(1<<(PhpParserDollar-182))|(1<<(PhpParserOpenRoundBracket-182))|(1<<(PhpParserOpenSquareBracket-182))|(1<<(PhpParserVarName-182))|(1<<(PhpParserLabel-182)))) != 0) || (((_la-214)&-(0x1f+1)) == 0 && ((1<<uint((_la-214)))&((1<<(PhpParserOctal-214))|(1<<(PhpParserDecimal-214))|(1<<(PhpParserReal-214))|(1<<(PhpParserHex-214))|(1<<(PhpParserBinary-214))|(1<<(PhpParserBackQuoteString-214))|(1<<(PhpParserSingleQuoteString-214))|(1<<(PhpParserDoubleQuote-214))|(1<<(PhpParserStartNowDoc-214))|(1<<(PhpParserStartHereDoc-214)))) != 0) {
			{
				p.SetState(1577)
				p.expression(0)
			}

		}
		{
			p.SetState(1580)
			p.Match(PhpParserCloseSquareBracket)
		}

	case PhpParserOpenCurlyBracket:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1581)
			p.Match(PhpParserOpenCurlyBracket)
		}
		{
			p.SetState(1582)
			p.expression(0)
		}
		{
			p.SetState(1583)
			p.Match(PhpParserCloseCurlyBracket)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAssignmentListContext is an interface to support dynamic dispatch.
type IAssignmentListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssignmentListContext differentiates from other interfaces.
	IsAssignmentListContext()
}

type AssignmentListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentListContext() *AssignmentListContext {
	var p = new(AssignmentListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_assignmentList
	return p
}

func (*AssignmentListContext) IsAssignmentListContext() {}

func NewAssignmentListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentListContext {
	var p = new(AssignmentListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_assignmentList

	return p
}

func (s *AssignmentListContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentListContext) AllAssignmentListElement() []IAssignmentListElementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAssignmentListElementContext)(nil)).Elem())
	var tst = make([]IAssignmentListElementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAssignmentListElementContext)
		}
	}

	return tst
}

func (s *AssignmentListContext) AssignmentListElement(i int) IAssignmentListElementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignmentListElementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAssignmentListElementContext)
}

func (s *AssignmentListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterAssignmentList(s)
	}
}

func (s *AssignmentListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitAssignmentList(s)
	}
}

func (p *PhpParser) AssignmentList() (localctx IAssignmentListContext) {
	localctx = NewAssignmentListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, PhpParserRULE_assignmentList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1588)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la-43)&-(0x1f+1)) == 0 && ((1<<uint((_la-43)))&((1<<(PhpParserAbstract-43))|(1<<(PhpParserArray-43))|(1<<(PhpParserAs-43))|(1<<(PhpParserBinaryCast-43))|(1<<(PhpParserBoolType-43))|(1<<(PhpParserBooleanConstant-43))|(1<<(PhpParserBreak-43))|(1<<(PhpParserCallable-43))|(1<<(PhpParserCase-43))|(1<<(PhpParserCatch-43))|(1<<(PhpParserClass-43))|(1<<(PhpParserClone-43))|(1<<(PhpParserConst-43))|(1<<(PhpParserContinue-43))|(1<<(PhpParserDeclare-43))|(1<<(PhpParserDefault-43))|(1<<(PhpParserDo-43))|(1<<(PhpParserDoubleCast-43))|(1<<(PhpParserDoubleType-43))|(1<<(PhpParserEcho-43))|(1<<(PhpParserElse-43))|(1<<(PhpParserElseIf-43))|(1<<(PhpParserEmpty-43))|(1<<(PhpParserEndDeclare-43))|(1<<(PhpParserEndFor-43))|(1<<(PhpParserEndForeach-43))|(1<<(PhpParserEndIf-43))|(1<<(PhpParserEndSwitch-43))|(1<<(PhpParserEndWhile-43))|(1<<(PhpParserEval-43))|(1<<(PhpParserExit-43))|(1<<(PhpParserExtends-43)))) != 0) || (((_la-75)&-(0x1f+1)) == 0 && ((1<<uint((_la-75)))&((1<<(PhpParserFinal-75))|(1<<(PhpParserFinally-75))|(1<<(PhpParserFloatCast-75))|(1<<(PhpParserFor-75))|(1<<(PhpParserForeach-75))|(1<<(PhpParserFunction-75))|(1<<(PhpParserGlobal-75))|(1<<(PhpParserGoto-75))|(1<<(PhpParserIf-75))|(1<<(PhpParserImplements-75))|(1<<(PhpParserImport-75))|(1<<(PhpParserInclude-75))|(1<<(PhpParserIncludeOnce-75))|(1<<(PhpParserInstanceOf-75))|(1<<(PhpParserInsteadOf-75))|(1<<(PhpParserInt8Cast-75))|(1<<(PhpParserInt16Cast-75))|(1<<(PhpParserInt64Type-75))|(1<<(PhpParserIntType-75))|(1<<(PhpParserInterface-75))|(1<<(PhpParserIsSet-75))|(1<<(PhpParserList-75))|(1<<(PhpParserLogicalAnd-75))|(1<<(PhpParserLogicalOr-75))|(1<<(PhpParserLogicalXor-75))|(1<<(PhpParserNamespace-75))|(1<<(PhpParserNew-75))|(1<<(PhpParserNull-75))|(1<<(PhpParserObjectType-75))|(1<<(PhpParserParent_-75))|(1<<(PhpParserPartial-75))|(1<<(PhpParserPrint-75)))) != 0) || (((_la-107)&-(0x1f+1)) == 0 && ((1<<uint((_la-107)))&((1<<(PhpParserPrivate-107))|(1<<(PhpParserProtected-107))|(1<<(PhpParserPublic-107))|(1<<(PhpParserRequire-107))|(1<<(PhpParserRequireOnce-107))|(1<<(PhpParserResource-107))|(1<<(PhpParserReturn-107))|(1<<(PhpParserStatic-107))|(1<<(PhpParserStringType-107))|(1<<(PhpParserSwitch-107))|(1<<(PhpParserThrow-107))|(1<<(PhpParserTrait-107))|(1<<(PhpParserTry-107))|(1<<(PhpParserTypeof-107))|(1<<(PhpParserUintCast-107))|(1<<(PhpParserUnicodeCast-107))|(1<<(PhpParserUnset-107))|(1<<(PhpParserUse-107))|(1<<(PhpParserVar-107))|(1<<(PhpParserWhile-107))|(1<<(PhpParserYield-107))|(1<<(PhpParserGet-107))|(1<<(PhpParserSet-107))|(1<<(PhpParserCall-107))|(1<<(PhpParserCallStatic-107))|(1<<(PhpParserConstructor-107))|(1<<(PhpParserDestruct-107))|(1<<(PhpParserWakeup-107))|(1<<(PhpParserSleep-107))|(1<<(PhpParserAutoload-107))|(1<<(PhpParserIsSet__-107))|(1<<(PhpParserUnset__-107)))) != 0) || (((_la-139)&-(0x1f+1)) == 0 && ((1<<uint((_la-139)))&((1<<(PhpParserToString__-139))|(1<<(PhpParserInvoke-139))|(1<<(PhpParserSetState-139))|(1<<(PhpParserClone__-139))|(1<<(PhpParserDebugInfo-139))|(1<<(PhpParserNamespace__-139))|(1<<(PhpParserClass__-139))|(1<<(PhpParserTraic__-139))|(1<<(PhpParserFunction__-139))|(1<<(PhpParserMethod__-139))|(1<<(PhpParserLine__-139))|(1<<(PhpParserFile__-139))|(1<<(PhpParserDir__-139)))) != 0) || (((_la-182)&-(0x1f+1)) == 0 && ((1<<uint((_la-182)))&((1<<(PhpParserNamespaceSeparator-182))|(1<<(PhpParserDollar-182))|(1<<(PhpParserOpenRoundBracket-182))|(1<<(PhpParserVarName-182))|(1<<(PhpParserLabel-182)))) != 0) {
		{
			p.SetState(1587)
			p.AssignmentListElement()
		}

	}
	p.SetState(1596)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == PhpParserComma {
		{
			p.SetState(1590)
			p.Match(PhpParserComma)
		}
		p.SetState(1592)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la-43)&-(0x1f+1)) == 0 && ((1<<uint((_la-43)))&((1<<(PhpParserAbstract-43))|(1<<(PhpParserArray-43))|(1<<(PhpParserAs-43))|(1<<(PhpParserBinaryCast-43))|(1<<(PhpParserBoolType-43))|(1<<(PhpParserBooleanConstant-43))|(1<<(PhpParserBreak-43))|(1<<(PhpParserCallable-43))|(1<<(PhpParserCase-43))|(1<<(PhpParserCatch-43))|(1<<(PhpParserClass-43))|(1<<(PhpParserClone-43))|(1<<(PhpParserConst-43))|(1<<(PhpParserContinue-43))|(1<<(PhpParserDeclare-43))|(1<<(PhpParserDefault-43))|(1<<(PhpParserDo-43))|(1<<(PhpParserDoubleCast-43))|(1<<(PhpParserDoubleType-43))|(1<<(PhpParserEcho-43))|(1<<(PhpParserElse-43))|(1<<(PhpParserElseIf-43))|(1<<(PhpParserEmpty-43))|(1<<(PhpParserEndDeclare-43))|(1<<(PhpParserEndFor-43))|(1<<(PhpParserEndForeach-43))|(1<<(PhpParserEndIf-43))|(1<<(PhpParserEndSwitch-43))|(1<<(PhpParserEndWhile-43))|(1<<(PhpParserEval-43))|(1<<(PhpParserExit-43))|(1<<(PhpParserExtends-43)))) != 0) || (((_la-75)&-(0x1f+1)) == 0 && ((1<<uint((_la-75)))&((1<<(PhpParserFinal-75))|(1<<(PhpParserFinally-75))|(1<<(PhpParserFloatCast-75))|(1<<(PhpParserFor-75))|(1<<(PhpParserForeach-75))|(1<<(PhpParserFunction-75))|(1<<(PhpParserGlobal-75))|(1<<(PhpParserGoto-75))|(1<<(PhpParserIf-75))|(1<<(PhpParserImplements-75))|(1<<(PhpParserImport-75))|(1<<(PhpParserInclude-75))|(1<<(PhpParserIncludeOnce-75))|(1<<(PhpParserInstanceOf-75))|(1<<(PhpParserInsteadOf-75))|(1<<(PhpParserInt8Cast-75))|(1<<(PhpParserInt16Cast-75))|(1<<(PhpParserInt64Type-75))|(1<<(PhpParserIntType-75))|(1<<(PhpParserInterface-75))|(1<<(PhpParserIsSet-75))|(1<<(PhpParserList-75))|(1<<(PhpParserLogicalAnd-75))|(1<<(PhpParserLogicalOr-75))|(1<<(PhpParserLogicalXor-75))|(1<<(PhpParserNamespace-75))|(1<<(PhpParserNew-75))|(1<<(PhpParserNull-75))|(1<<(PhpParserObjectType-75))|(1<<(PhpParserParent_-75))|(1<<(PhpParserPartial-75))|(1<<(PhpParserPrint-75)))) != 0) || (((_la-107)&-(0x1f+1)) == 0 && ((1<<uint((_la-107)))&((1<<(PhpParserPrivate-107))|(1<<(PhpParserProtected-107))|(1<<(PhpParserPublic-107))|(1<<(PhpParserRequire-107))|(1<<(PhpParserRequireOnce-107))|(1<<(PhpParserResource-107))|(1<<(PhpParserReturn-107))|(1<<(PhpParserStatic-107))|(1<<(PhpParserStringType-107))|(1<<(PhpParserSwitch-107))|(1<<(PhpParserThrow-107))|(1<<(PhpParserTrait-107))|(1<<(PhpParserTry-107))|(1<<(PhpParserTypeof-107))|(1<<(PhpParserUintCast-107))|(1<<(PhpParserUnicodeCast-107))|(1<<(PhpParserUnset-107))|(1<<(PhpParserUse-107))|(1<<(PhpParserVar-107))|(1<<(PhpParserWhile-107))|(1<<(PhpParserYield-107))|(1<<(PhpParserGet-107))|(1<<(PhpParserSet-107))|(1<<(PhpParserCall-107))|(1<<(PhpParserCallStatic-107))|(1<<(PhpParserConstructor-107))|(1<<(PhpParserDestruct-107))|(1<<(PhpParserWakeup-107))|(1<<(PhpParserSleep-107))|(1<<(PhpParserAutoload-107))|(1<<(PhpParserIsSet__-107))|(1<<(PhpParserUnset__-107)))) != 0) || (((_la-139)&-(0x1f+1)) == 0 && ((1<<uint((_la-139)))&((1<<(PhpParserToString__-139))|(1<<(PhpParserInvoke-139))|(1<<(PhpParserSetState-139))|(1<<(PhpParserClone__-139))|(1<<(PhpParserDebugInfo-139))|(1<<(PhpParserNamespace__-139))|(1<<(PhpParserClass__-139))|(1<<(PhpParserTraic__-139))|(1<<(PhpParserFunction__-139))|(1<<(PhpParserMethod__-139))|(1<<(PhpParserLine__-139))|(1<<(PhpParserFile__-139))|(1<<(PhpParserDir__-139)))) != 0) || (((_la-182)&-(0x1f+1)) == 0 && ((1<<uint((_la-182)))&((1<<(PhpParserNamespaceSeparator-182))|(1<<(PhpParserDollar-182))|(1<<(PhpParserOpenRoundBracket-182))|(1<<(PhpParserVarName-182))|(1<<(PhpParserLabel-182)))) != 0) {
			{
				p.SetState(1591)
				p.AssignmentListElement()
			}

		}

		p.SetState(1598)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IAssignmentListElementContext is an interface to support dynamic dispatch.
type IAssignmentListElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssignmentListElementContext differentiates from other interfaces.
	IsAssignmentListElementContext()
}

type AssignmentListElementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentListElementContext() *AssignmentListElementContext {
	var p = new(AssignmentListElementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_assignmentListElement
	return p
}

func (*AssignmentListElementContext) IsAssignmentListElementContext() {}

func NewAssignmentListElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentListElementContext {
	var p = new(AssignmentListElementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_assignmentListElement

	return p
}

func (s *AssignmentListElementContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentListElementContext) Chain() IChainContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IChainContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IChainContext)
}

func (s *AssignmentListElementContext) List() antlr.TerminalNode {
	return s.GetToken(PhpParserList, 0)
}

func (s *AssignmentListElementContext) AssignmentList() IAssignmentListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignmentListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignmentListContext)
}

func (s *AssignmentListElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentListElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentListElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterAssignmentListElement(s)
	}
}

func (s *AssignmentListElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitAssignmentListElement(s)
	}
}

func (p *PhpParser) AssignmentListElement() (localctx IAssignmentListElementContext) {
	localctx = NewAssignmentListElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, PhpParserRULE_assignmentListElement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1605)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 183, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1599)
			p.Chain()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1600)
			p.Match(PhpParserList)
		}
		{
			p.SetState(1601)
			p.Match(PhpParserOpenRoundBracket)
		}
		{
			p.SetState(1602)
			p.AssignmentList()
		}
		{
			p.SetState(1603)
			p.Match(PhpParserCloseRoundBracket)
		}

	}

	return localctx
}

// IModifierContext is an interface to support dynamic dispatch.
type IModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModifierContext differentiates from other interfaces.
	IsModifierContext()
}

type ModifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModifierContext() *ModifierContext {
	var p = new(ModifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_modifier
	return p
}

func (*ModifierContext) IsModifierContext() {}

func NewModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModifierContext {
	var p = new(ModifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_modifier

	return p
}

func (s *ModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ModifierContext) Abstract() antlr.TerminalNode {
	return s.GetToken(PhpParserAbstract, 0)
}

func (s *ModifierContext) Final() antlr.TerminalNode {
	return s.GetToken(PhpParserFinal, 0)
}

func (s *ModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterModifier(s)
	}
}

func (s *ModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitModifier(s)
	}
}

func (p *PhpParser) Modifier() (localctx IModifierContext) {
	localctx = NewModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 244, PhpParserRULE_modifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1607)
		_la = p.GetTokenStream().LA(1)

		if !(_la == PhpParserAbstract || _la == PhpParserFinal) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IIdentifierContext is an interface to support dynamic dispatch.
type IIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIdentifierContext differentiates from other interfaces.
	IsIdentifierContext()
}

type IdentifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierContext() *IdentifierContext {
	var p = new(IdentifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_identifier
	return p
}

func (*IdentifierContext) IsIdentifierContext() {}

func NewIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierContext {
	var p = new(IdentifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_identifier

	return p
}

func (s *IdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierContext) Label() antlr.TerminalNode {
	return s.GetToken(PhpParserLabel, 0)
}

func (s *IdentifierContext) Abstract() antlr.TerminalNode {
	return s.GetToken(PhpParserAbstract, 0)
}

func (s *IdentifierContext) Array() antlr.TerminalNode {
	return s.GetToken(PhpParserArray, 0)
}

func (s *IdentifierContext) As() antlr.TerminalNode {
	return s.GetToken(PhpParserAs, 0)
}

func (s *IdentifierContext) BinaryCast() antlr.TerminalNode {
	return s.GetToken(PhpParserBinaryCast, 0)
}

func (s *IdentifierContext) BoolType() antlr.TerminalNode {
	return s.GetToken(PhpParserBoolType, 0)
}

func (s *IdentifierContext) BooleanConstant() antlr.TerminalNode {
	return s.GetToken(PhpParserBooleanConstant, 0)
}

func (s *IdentifierContext) Break() antlr.TerminalNode {
	return s.GetToken(PhpParserBreak, 0)
}

func (s *IdentifierContext) Callable() antlr.TerminalNode {
	return s.GetToken(PhpParserCallable, 0)
}

func (s *IdentifierContext) Case() antlr.TerminalNode {
	return s.GetToken(PhpParserCase, 0)
}

func (s *IdentifierContext) Catch() antlr.TerminalNode {
	return s.GetToken(PhpParserCatch, 0)
}

func (s *IdentifierContext) Class() antlr.TerminalNode {
	return s.GetToken(PhpParserClass, 0)
}

func (s *IdentifierContext) Clone() antlr.TerminalNode {
	return s.GetToken(PhpParserClone, 0)
}

func (s *IdentifierContext) Const() antlr.TerminalNode {
	return s.GetToken(PhpParserConst, 0)
}

func (s *IdentifierContext) Continue() antlr.TerminalNode {
	return s.GetToken(PhpParserContinue, 0)
}

func (s *IdentifierContext) Declare() antlr.TerminalNode {
	return s.GetToken(PhpParserDeclare, 0)
}

func (s *IdentifierContext) Default() antlr.TerminalNode {
	return s.GetToken(PhpParserDefault, 0)
}

func (s *IdentifierContext) Do() antlr.TerminalNode {
	return s.GetToken(PhpParserDo, 0)
}

func (s *IdentifierContext) DoubleCast() antlr.TerminalNode {
	return s.GetToken(PhpParserDoubleCast, 0)
}

func (s *IdentifierContext) DoubleType() antlr.TerminalNode {
	return s.GetToken(PhpParserDoubleType, 0)
}

func (s *IdentifierContext) Echo() antlr.TerminalNode {
	return s.GetToken(PhpParserEcho, 0)
}

func (s *IdentifierContext) Else() antlr.TerminalNode {
	return s.GetToken(PhpParserElse, 0)
}

func (s *IdentifierContext) ElseIf() antlr.TerminalNode {
	return s.GetToken(PhpParserElseIf, 0)
}

func (s *IdentifierContext) Empty() antlr.TerminalNode {
	return s.GetToken(PhpParserEmpty, 0)
}

func (s *IdentifierContext) EndDeclare() antlr.TerminalNode {
	return s.GetToken(PhpParserEndDeclare, 0)
}

func (s *IdentifierContext) EndFor() antlr.TerminalNode {
	return s.GetToken(PhpParserEndFor, 0)
}

func (s *IdentifierContext) EndForeach() antlr.TerminalNode {
	return s.GetToken(PhpParserEndForeach, 0)
}

func (s *IdentifierContext) EndIf() antlr.TerminalNode {
	return s.GetToken(PhpParserEndIf, 0)
}

func (s *IdentifierContext) EndSwitch() antlr.TerminalNode {
	return s.GetToken(PhpParserEndSwitch, 0)
}

func (s *IdentifierContext) EndWhile() antlr.TerminalNode {
	return s.GetToken(PhpParserEndWhile, 0)
}

func (s *IdentifierContext) Eval() antlr.TerminalNode {
	return s.GetToken(PhpParserEval, 0)
}

func (s *IdentifierContext) Exit() antlr.TerminalNode {
	return s.GetToken(PhpParserExit, 0)
}

func (s *IdentifierContext) Extends() antlr.TerminalNode {
	return s.GetToken(PhpParserExtends, 0)
}

func (s *IdentifierContext) Final() antlr.TerminalNode {
	return s.GetToken(PhpParserFinal, 0)
}

func (s *IdentifierContext) Finally() antlr.TerminalNode {
	return s.GetToken(PhpParserFinally, 0)
}

func (s *IdentifierContext) FloatCast() antlr.TerminalNode {
	return s.GetToken(PhpParserFloatCast, 0)
}

func (s *IdentifierContext) For() antlr.TerminalNode {
	return s.GetToken(PhpParserFor, 0)
}

func (s *IdentifierContext) Foreach() antlr.TerminalNode {
	return s.GetToken(PhpParserForeach, 0)
}

func (s *IdentifierContext) Function() antlr.TerminalNode {
	return s.GetToken(PhpParserFunction, 0)
}

func (s *IdentifierContext) Global() antlr.TerminalNode {
	return s.GetToken(PhpParserGlobal, 0)
}

func (s *IdentifierContext) Goto() antlr.TerminalNode {
	return s.GetToken(PhpParserGoto, 0)
}

func (s *IdentifierContext) If() antlr.TerminalNode {
	return s.GetToken(PhpParserIf, 0)
}

func (s *IdentifierContext) Implements() antlr.TerminalNode {
	return s.GetToken(PhpParserImplements, 0)
}

func (s *IdentifierContext) Import() antlr.TerminalNode {
	return s.GetToken(PhpParserImport, 0)
}

func (s *IdentifierContext) Include() antlr.TerminalNode {
	return s.GetToken(PhpParserInclude, 0)
}

func (s *IdentifierContext) IncludeOnce() antlr.TerminalNode {
	return s.GetToken(PhpParserIncludeOnce, 0)
}

func (s *IdentifierContext) InstanceOf() antlr.TerminalNode {
	return s.GetToken(PhpParserInstanceOf, 0)
}

func (s *IdentifierContext) InsteadOf() antlr.TerminalNode {
	return s.GetToken(PhpParserInsteadOf, 0)
}

func (s *IdentifierContext) Int16Cast() antlr.TerminalNode {
	return s.GetToken(PhpParserInt16Cast, 0)
}

func (s *IdentifierContext) Int64Type() antlr.TerminalNode {
	return s.GetToken(PhpParserInt64Type, 0)
}

func (s *IdentifierContext) Int8Cast() antlr.TerminalNode {
	return s.GetToken(PhpParserInt8Cast, 0)
}

func (s *IdentifierContext) Interface() antlr.TerminalNode {
	return s.GetToken(PhpParserInterface, 0)
}

func (s *IdentifierContext) IntType() antlr.TerminalNode {
	return s.GetToken(PhpParserIntType, 0)
}

func (s *IdentifierContext) IsSet() antlr.TerminalNode {
	return s.GetToken(PhpParserIsSet, 0)
}

func (s *IdentifierContext) List() antlr.TerminalNode {
	return s.GetToken(PhpParserList, 0)
}

func (s *IdentifierContext) LogicalAnd() antlr.TerminalNode {
	return s.GetToken(PhpParserLogicalAnd, 0)
}

func (s *IdentifierContext) LogicalOr() antlr.TerminalNode {
	return s.GetToken(PhpParserLogicalOr, 0)
}

func (s *IdentifierContext) LogicalXor() antlr.TerminalNode {
	return s.GetToken(PhpParserLogicalXor, 0)
}

func (s *IdentifierContext) Namespace() antlr.TerminalNode {
	return s.GetToken(PhpParserNamespace, 0)
}

func (s *IdentifierContext) New() antlr.TerminalNode {
	return s.GetToken(PhpParserNew, 0)
}

func (s *IdentifierContext) Null() antlr.TerminalNode {
	return s.GetToken(PhpParserNull, 0)
}

func (s *IdentifierContext) ObjectType() antlr.TerminalNode {
	return s.GetToken(PhpParserObjectType, 0)
}

func (s *IdentifierContext) Parent_() antlr.TerminalNode {
	return s.GetToken(PhpParserParent_, 0)
}

func (s *IdentifierContext) Partial() antlr.TerminalNode {
	return s.GetToken(PhpParserPartial, 0)
}

func (s *IdentifierContext) Print() antlr.TerminalNode {
	return s.GetToken(PhpParserPrint, 0)
}

func (s *IdentifierContext) Private() antlr.TerminalNode {
	return s.GetToken(PhpParserPrivate, 0)
}

func (s *IdentifierContext) Protected() antlr.TerminalNode {
	return s.GetToken(PhpParserProtected, 0)
}

func (s *IdentifierContext) Public() antlr.TerminalNode {
	return s.GetToken(PhpParserPublic, 0)
}

func (s *IdentifierContext) Require() antlr.TerminalNode {
	return s.GetToken(PhpParserRequire, 0)
}

func (s *IdentifierContext) RequireOnce() antlr.TerminalNode {
	return s.GetToken(PhpParserRequireOnce, 0)
}

func (s *IdentifierContext) Resource() antlr.TerminalNode {
	return s.GetToken(PhpParserResource, 0)
}

func (s *IdentifierContext) Return() antlr.TerminalNode {
	return s.GetToken(PhpParserReturn, 0)
}

func (s *IdentifierContext) Static() antlr.TerminalNode {
	return s.GetToken(PhpParserStatic, 0)
}

func (s *IdentifierContext) StringType() antlr.TerminalNode {
	return s.GetToken(PhpParserStringType, 0)
}

func (s *IdentifierContext) Switch() antlr.TerminalNode {
	return s.GetToken(PhpParserSwitch, 0)
}

func (s *IdentifierContext) Throw() antlr.TerminalNode {
	return s.GetToken(PhpParserThrow, 0)
}

func (s *IdentifierContext) Trait() antlr.TerminalNode {
	return s.GetToken(PhpParserTrait, 0)
}

func (s *IdentifierContext) Try() antlr.TerminalNode {
	return s.GetToken(PhpParserTry, 0)
}

func (s *IdentifierContext) Typeof() antlr.TerminalNode {
	return s.GetToken(PhpParserTypeof, 0)
}

func (s *IdentifierContext) UintCast() antlr.TerminalNode {
	return s.GetToken(PhpParserUintCast, 0)
}

func (s *IdentifierContext) UnicodeCast() antlr.TerminalNode {
	return s.GetToken(PhpParserUnicodeCast, 0)
}

func (s *IdentifierContext) Unset() antlr.TerminalNode {
	return s.GetToken(PhpParserUnset, 0)
}

func (s *IdentifierContext) Use() antlr.TerminalNode {
	return s.GetToken(PhpParserUse, 0)
}

func (s *IdentifierContext) Var() antlr.TerminalNode {
	return s.GetToken(PhpParserVar, 0)
}

func (s *IdentifierContext) While() antlr.TerminalNode {
	return s.GetToken(PhpParserWhile, 0)
}

func (s *IdentifierContext) Yield() antlr.TerminalNode {
	return s.GetToken(PhpParserYield, 0)
}

func (s *IdentifierContext) Get() antlr.TerminalNode {
	return s.GetToken(PhpParserGet, 0)
}

func (s *IdentifierContext) Set() antlr.TerminalNode {
	return s.GetToken(PhpParserSet, 0)
}

func (s *IdentifierContext) Call() antlr.TerminalNode {
	return s.GetToken(PhpParserCall, 0)
}

func (s *IdentifierContext) CallStatic() antlr.TerminalNode {
	return s.GetToken(PhpParserCallStatic, 0)
}

func (s *IdentifierContext) Constructor() antlr.TerminalNode {
	return s.GetToken(PhpParserConstructor, 0)
}

func (s *IdentifierContext) Destruct() antlr.TerminalNode {
	return s.GetToken(PhpParserDestruct, 0)
}

func (s *IdentifierContext) Wakeup() antlr.TerminalNode {
	return s.GetToken(PhpParserWakeup, 0)
}

func (s *IdentifierContext) Sleep() antlr.TerminalNode {
	return s.GetToken(PhpParserSleep, 0)
}

func (s *IdentifierContext) Autoload() antlr.TerminalNode {
	return s.GetToken(PhpParserAutoload, 0)
}

func (s *IdentifierContext) IsSet__() antlr.TerminalNode {
	return s.GetToken(PhpParserIsSet__, 0)
}

func (s *IdentifierContext) Unset__() antlr.TerminalNode {
	return s.GetToken(PhpParserUnset__, 0)
}

func (s *IdentifierContext) ToString__() antlr.TerminalNode {
	return s.GetToken(PhpParserToString__, 0)
}

func (s *IdentifierContext) Invoke() antlr.TerminalNode {
	return s.GetToken(PhpParserInvoke, 0)
}

func (s *IdentifierContext) SetState() antlr.TerminalNode {
	return s.GetToken(PhpParserSetState, 0)
}

func (s *IdentifierContext) Clone__() antlr.TerminalNode {
	return s.GetToken(PhpParserClone__, 0)
}

func (s *IdentifierContext) DebugInfo() antlr.TerminalNode {
	return s.GetToken(PhpParserDebugInfo, 0)
}

func (s *IdentifierContext) Namespace__() antlr.TerminalNode {
	return s.GetToken(PhpParserNamespace__, 0)
}

func (s *IdentifierContext) Class__() antlr.TerminalNode {
	return s.GetToken(PhpParserClass__, 0)
}

func (s *IdentifierContext) Traic__() antlr.TerminalNode {
	return s.GetToken(PhpParserTraic__, 0)
}

func (s *IdentifierContext) Function__() antlr.TerminalNode {
	return s.GetToken(PhpParserFunction__, 0)
}

func (s *IdentifierContext) Method__() antlr.TerminalNode {
	return s.GetToken(PhpParserMethod__, 0)
}

func (s *IdentifierContext) Line__() antlr.TerminalNode {
	return s.GetToken(PhpParserLine__, 0)
}

func (s *IdentifierContext) File__() antlr.TerminalNode {
	return s.GetToken(PhpParserFile__, 0)
}

func (s *IdentifierContext) Dir__() antlr.TerminalNode {
	return s.GetToken(PhpParserDir__, 0)
}

func (s *IdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterIdentifier(s)
	}
}

func (s *IdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitIdentifier(s)
	}
}

func (p *PhpParser) Identifier() (localctx IIdentifierContext) {
	localctx = NewIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 246, PhpParserRULE_identifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1609)
		_la = p.GetTokenStream().LA(1)

		if !((((_la-43)&-(0x1f+1)) == 0 && ((1<<uint((_la-43)))&((1<<(PhpParserAbstract-43))|(1<<(PhpParserArray-43))|(1<<(PhpParserAs-43))|(1<<(PhpParserBinaryCast-43))|(1<<(PhpParserBoolType-43))|(1<<(PhpParserBooleanConstant-43))|(1<<(PhpParserBreak-43))|(1<<(PhpParserCallable-43))|(1<<(PhpParserCase-43))|(1<<(PhpParserCatch-43))|(1<<(PhpParserClass-43))|(1<<(PhpParserClone-43))|(1<<(PhpParserConst-43))|(1<<(PhpParserContinue-43))|(1<<(PhpParserDeclare-43))|(1<<(PhpParserDefault-43))|(1<<(PhpParserDo-43))|(1<<(PhpParserDoubleCast-43))|(1<<(PhpParserDoubleType-43))|(1<<(PhpParserEcho-43))|(1<<(PhpParserElse-43))|(1<<(PhpParserElseIf-43))|(1<<(PhpParserEmpty-43))|(1<<(PhpParserEndDeclare-43))|(1<<(PhpParserEndFor-43))|(1<<(PhpParserEndForeach-43))|(1<<(PhpParserEndIf-43))|(1<<(PhpParserEndSwitch-43))|(1<<(PhpParserEndWhile-43))|(1<<(PhpParserEval-43))|(1<<(PhpParserExit-43))|(1<<(PhpParserExtends-43)))) != 0) || (((_la-75)&-(0x1f+1)) == 0 && ((1<<uint((_la-75)))&((1<<(PhpParserFinal-75))|(1<<(PhpParserFinally-75))|(1<<(PhpParserFloatCast-75))|(1<<(PhpParserFor-75))|(1<<(PhpParserForeach-75))|(1<<(PhpParserFunction-75))|(1<<(PhpParserGlobal-75))|(1<<(PhpParserGoto-75))|(1<<(PhpParserIf-75))|(1<<(PhpParserImplements-75))|(1<<(PhpParserImport-75))|(1<<(PhpParserInclude-75))|(1<<(PhpParserIncludeOnce-75))|(1<<(PhpParserInstanceOf-75))|(1<<(PhpParserInsteadOf-75))|(1<<(PhpParserInt8Cast-75))|(1<<(PhpParserInt16Cast-75))|(1<<(PhpParserInt64Type-75))|(1<<(PhpParserIntType-75))|(1<<(PhpParserInterface-75))|(1<<(PhpParserIsSet-75))|(1<<(PhpParserList-75))|(1<<(PhpParserLogicalAnd-75))|(1<<(PhpParserLogicalOr-75))|(1<<(PhpParserLogicalXor-75))|(1<<(PhpParserNamespace-75))|(1<<(PhpParserNew-75))|(1<<(PhpParserNull-75))|(1<<(PhpParserObjectType-75))|(1<<(PhpParserParent_-75))|(1<<(PhpParserPartial-75))|(1<<(PhpParserPrint-75)))) != 0) || (((_la-107)&-(0x1f+1)) == 0 && ((1<<uint((_la-107)))&((1<<(PhpParserPrivate-107))|(1<<(PhpParserProtected-107))|(1<<(PhpParserPublic-107))|(1<<(PhpParserRequire-107))|(1<<(PhpParserRequireOnce-107))|(1<<(PhpParserResource-107))|(1<<(PhpParserReturn-107))|(1<<(PhpParserStatic-107))|(1<<(PhpParserStringType-107))|(1<<(PhpParserSwitch-107))|(1<<(PhpParserThrow-107))|(1<<(PhpParserTrait-107))|(1<<(PhpParserTry-107))|(1<<(PhpParserTypeof-107))|(1<<(PhpParserUintCast-107))|(1<<(PhpParserUnicodeCast-107))|(1<<(PhpParserUnset-107))|(1<<(PhpParserUse-107))|(1<<(PhpParserVar-107))|(1<<(PhpParserWhile-107))|(1<<(PhpParserYield-107))|(1<<(PhpParserGet-107))|(1<<(PhpParserSet-107))|(1<<(PhpParserCall-107))|(1<<(PhpParserCallStatic-107))|(1<<(PhpParserConstructor-107))|(1<<(PhpParserDestruct-107))|(1<<(PhpParserWakeup-107))|(1<<(PhpParserSleep-107))|(1<<(PhpParserAutoload-107))|(1<<(PhpParserIsSet__-107))|(1<<(PhpParserUnset__-107)))) != 0) || (((_la-139)&-(0x1f+1)) == 0 && ((1<<uint((_la-139)))&((1<<(PhpParserToString__-139))|(1<<(PhpParserInvoke-139))|(1<<(PhpParserSetState-139))|(1<<(PhpParserClone__-139))|(1<<(PhpParserDebugInfo-139))|(1<<(PhpParserNamespace__-139))|(1<<(PhpParserClass__-139))|(1<<(PhpParserTraic__-139))|(1<<(PhpParserFunction__-139))|(1<<(PhpParserMethod__-139))|(1<<(PhpParserLine__-139))|(1<<(PhpParserFile__-139))|(1<<(PhpParserDir__-139)))) != 0) || _la == PhpParserLabel) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IMemberModifierContext is an interface to support dynamic dispatch.
type IMemberModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMemberModifierContext differentiates from other interfaces.
	IsMemberModifierContext()
}

type MemberModifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMemberModifierContext() *MemberModifierContext {
	var p = new(MemberModifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_memberModifier
	return p
}

func (*MemberModifierContext) IsMemberModifierContext() {}

func NewMemberModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MemberModifierContext {
	var p = new(MemberModifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_memberModifier

	return p
}

func (s *MemberModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *MemberModifierContext) Public() antlr.TerminalNode {
	return s.GetToken(PhpParserPublic, 0)
}

func (s *MemberModifierContext) Protected() antlr.TerminalNode {
	return s.GetToken(PhpParserProtected, 0)
}

func (s *MemberModifierContext) Private() antlr.TerminalNode {
	return s.GetToken(PhpParserPrivate, 0)
}

func (s *MemberModifierContext) Static() antlr.TerminalNode {
	return s.GetToken(PhpParserStatic, 0)
}

func (s *MemberModifierContext) Abstract() antlr.TerminalNode {
	return s.GetToken(PhpParserAbstract, 0)
}

func (s *MemberModifierContext) Final() antlr.TerminalNode {
	return s.GetToken(PhpParserFinal, 0)
}

func (s *MemberModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MemberModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MemberModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterMemberModifier(s)
	}
}

func (s *MemberModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitMemberModifier(s)
	}
}

func (p *PhpParser) MemberModifier() (localctx IMemberModifierContext) {
	localctx = NewMemberModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 248, PhpParserRULE_memberModifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1611)
		_la = p.GetTokenStream().LA(1)

		if !(_la == PhpParserAbstract || _la == PhpParserFinal || (((_la-107)&-(0x1f+1)) == 0 && ((1<<uint((_la-107)))&((1<<(PhpParserPrivate-107))|(1<<(PhpParserProtected-107))|(1<<(PhpParserPublic-107))|(1<<(PhpParserStatic-107)))) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IMagicConstantContext is an interface to support dynamic dispatch.
type IMagicConstantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMagicConstantContext differentiates from other interfaces.
	IsMagicConstantContext()
}

type MagicConstantContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMagicConstantContext() *MagicConstantContext {
	var p = new(MagicConstantContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_magicConstant
	return p
}

func (*MagicConstantContext) IsMagicConstantContext() {}

func NewMagicConstantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MagicConstantContext {
	var p = new(MagicConstantContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_magicConstant

	return p
}

func (s *MagicConstantContext) GetParser() antlr.Parser { return s.parser }

func (s *MagicConstantContext) Namespace__() antlr.TerminalNode {
	return s.GetToken(PhpParserNamespace__, 0)
}

func (s *MagicConstantContext) Class__() antlr.TerminalNode {
	return s.GetToken(PhpParserClass__, 0)
}

func (s *MagicConstantContext) Traic__() antlr.TerminalNode {
	return s.GetToken(PhpParserTraic__, 0)
}

func (s *MagicConstantContext) Function__() antlr.TerminalNode {
	return s.GetToken(PhpParserFunction__, 0)
}

func (s *MagicConstantContext) Method__() antlr.TerminalNode {
	return s.GetToken(PhpParserMethod__, 0)
}

func (s *MagicConstantContext) Line__() antlr.TerminalNode {
	return s.GetToken(PhpParserLine__, 0)
}

func (s *MagicConstantContext) File__() antlr.TerminalNode {
	return s.GetToken(PhpParserFile__, 0)
}

func (s *MagicConstantContext) Dir__() antlr.TerminalNode {
	return s.GetToken(PhpParserDir__, 0)
}

func (s *MagicConstantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MagicConstantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MagicConstantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterMagicConstant(s)
	}
}

func (s *MagicConstantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitMagicConstant(s)
	}
}

func (p *PhpParser) MagicConstant() (localctx IMagicConstantContext) {
	localctx = NewMagicConstantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 250, PhpParserRULE_magicConstant)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1613)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-144)&-(0x1f+1)) == 0 && ((1<<uint((_la-144)))&((1<<(PhpParserNamespace__-144))|(1<<(PhpParserClass__-144))|(1<<(PhpParserTraic__-144))|(1<<(PhpParserFunction__-144))|(1<<(PhpParserMethod__-144))|(1<<(PhpParserLine__-144))|(1<<(PhpParserFile__-144))|(1<<(PhpParserDir__-144)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IMagicMethodContext is an interface to support dynamic dispatch.
type IMagicMethodContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMagicMethodContext differentiates from other interfaces.
	IsMagicMethodContext()
}

type MagicMethodContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMagicMethodContext() *MagicMethodContext {
	var p = new(MagicMethodContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_magicMethod
	return p
}

func (*MagicMethodContext) IsMagicMethodContext() {}

func NewMagicMethodContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MagicMethodContext {
	var p = new(MagicMethodContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_magicMethod

	return p
}

func (s *MagicMethodContext) GetParser() antlr.Parser { return s.parser }

func (s *MagicMethodContext) Get() antlr.TerminalNode {
	return s.GetToken(PhpParserGet, 0)
}

func (s *MagicMethodContext) Set() antlr.TerminalNode {
	return s.GetToken(PhpParserSet, 0)
}

func (s *MagicMethodContext) Call() antlr.TerminalNode {
	return s.GetToken(PhpParserCall, 0)
}

func (s *MagicMethodContext) CallStatic() antlr.TerminalNode {
	return s.GetToken(PhpParserCallStatic, 0)
}

func (s *MagicMethodContext) Constructor() antlr.TerminalNode {
	return s.GetToken(PhpParserConstructor, 0)
}

func (s *MagicMethodContext) Destruct() antlr.TerminalNode {
	return s.GetToken(PhpParserDestruct, 0)
}

func (s *MagicMethodContext) Wakeup() antlr.TerminalNode {
	return s.GetToken(PhpParserWakeup, 0)
}

func (s *MagicMethodContext) Sleep() antlr.TerminalNode {
	return s.GetToken(PhpParserSleep, 0)
}

func (s *MagicMethodContext) Autoload() antlr.TerminalNode {
	return s.GetToken(PhpParserAutoload, 0)
}

func (s *MagicMethodContext) IsSet__() antlr.TerminalNode {
	return s.GetToken(PhpParserIsSet__, 0)
}

func (s *MagicMethodContext) Unset__() antlr.TerminalNode {
	return s.GetToken(PhpParserUnset__, 0)
}

func (s *MagicMethodContext) ToString__() antlr.TerminalNode {
	return s.GetToken(PhpParserToString__, 0)
}

func (s *MagicMethodContext) Invoke() antlr.TerminalNode {
	return s.GetToken(PhpParserInvoke, 0)
}

func (s *MagicMethodContext) SetState() antlr.TerminalNode {
	return s.GetToken(PhpParserSetState, 0)
}

func (s *MagicMethodContext) Clone__() antlr.TerminalNode {
	return s.GetToken(PhpParserClone__, 0)
}

func (s *MagicMethodContext) DebugInfo() antlr.TerminalNode {
	return s.GetToken(PhpParserDebugInfo, 0)
}

func (s *MagicMethodContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MagicMethodContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MagicMethodContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterMagicMethod(s)
	}
}

func (s *MagicMethodContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitMagicMethod(s)
	}
}

func (p *PhpParser) MagicMethod() (localctx IMagicMethodContext) {
	localctx = NewMagicMethodContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 252, PhpParserRULE_magicMethod)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1615)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-128)&-(0x1f+1)) == 0 && ((1<<uint((_la-128)))&((1<<(PhpParserGet-128))|(1<<(PhpParserSet-128))|(1<<(PhpParserCall-128))|(1<<(PhpParserCallStatic-128))|(1<<(PhpParserConstructor-128))|(1<<(PhpParserDestruct-128))|(1<<(PhpParserWakeup-128))|(1<<(PhpParserSleep-128))|(1<<(PhpParserAutoload-128))|(1<<(PhpParserIsSet__-128))|(1<<(PhpParserUnset__-128))|(1<<(PhpParserToString__-128))|(1<<(PhpParserInvoke-128))|(1<<(PhpParserSetState-128))|(1<<(PhpParserClone__-128))|(1<<(PhpParserDebugInfo-128)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IPrimitiveTypeContext is an interface to support dynamic dispatch.
type IPrimitiveTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrimitiveTypeContext differentiates from other interfaces.
	IsPrimitiveTypeContext()
}

type PrimitiveTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimitiveTypeContext() *PrimitiveTypeContext {
	var p = new(PrimitiveTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_primitiveType
	return p
}

func (*PrimitiveTypeContext) IsPrimitiveTypeContext() {}

func NewPrimitiveTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimitiveTypeContext {
	var p = new(PrimitiveTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_primitiveType

	return p
}

func (s *PrimitiveTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimitiveTypeContext) BoolType() antlr.TerminalNode {
	return s.GetToken(PhpParserBoolType, 0)
}

func (s *PrimitiveTypeContext) IntType() antlr.TerminalNode {
	return s.GetToken(PhpParserIntType, 0)
}

func (s *PrimitiveTypeContext) Int64Type() antlr.TerminalNode {
	return s.GetToken(PhpParserInt64Type, 0)
}

func (s *PrimitiveTypeContext) DoubleType() antlr.TerminalNode {
	return s.GetToken(PhpParserDoubleType, 0)
}

func (s *PrimitiveTypeContext) StringType() antlr.TerminalNode {
	return s.GetToken(PhpParserStringType, 0)
}

func (s *PrimitiveTypeContext) Resource() antlr.TerminalNode {
	return s.GetToken(PhpParserResource, 0)
}

func (s *PrimitiveTypeContext) ObjectType() antlr.TerminalNode {
	return s.GetToken(PhpParserObjectType, 0)
}

func (s *PrimitiveTypeContext) Array() antlr.TerminalNode {
	return s.GetToken(PhpParserArray, 0)
}

func (s *PrimitiveTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimitiveTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimitiveTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterPrimitiveType(s)
	}
}

func (s *PrimitiveTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitPrimitiveType(s)
	}
}

func (p *PhpParser) PrimitiveType() (localctx IPrimitiveTypeContext) {
	localctx = NewPrimitiveTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 254, PhpParserRULE_primitiveType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1617)
		_la = p.GetTokenStream().LA(1)

		if !((((_la-44)&-(0x1f+1)) == 0 && ((1<<uint((_la-44)))&((1<<(PhpParserArray-44))|(1<<(PhpParserBoolType-44))|(1<<(PhpParserDoubleType-44)))) != 0) || (((_la-92)&-(0x1f+1)) == 0 && ((1<<uint((_la-92)))&((1<<(PhpParserInt64Type-92))|(1<<(PhpParserIntType-92))|(1<<(PhpParserObjectType-92))|(1<<(PhpParserResource-92))|(1<<(PhpParserStringType-92)))) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ICastOperationContext is an interface to support dynamic dispatch.
type ICastOperationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCastOperationContext differentiates from other interfaces.
	IsCastOperationContext()
}

type CastOperationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCastOperationContext() *CastOperationContext {
	var p = new(CastOperationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = PhpParserRULE_castOperation
	return p
}

func (*CastOperationContext) IsCastOperationContext() {}

func NewCastOperationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CastOperationContext {
	var p = new(CastOperationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = PhpParserRULE_castOperation

	return p
}

func (s *CastOperationContext) GetParser() antlr.Parser { return s.parser }

func (s *CastOperationContext) BoolType() antlr.TerminalNode {
	return s.GetToken(PhpParserBoolType, 0)
}

func (s *CastOperationContext) Int8Cast() antlr.TerminalNode {
	return s.GetToken(PhpParserInt8Cast, 0)
}

func (s *CastOperationContext) Int16Cast() antlr.TerminalNode {
	return s.GetToken(PhpParserInt16Cast, 0)
}

func (s *CastOperationContext) IntType() antlr.TerminalNode {
	return s.GetToken(PhpParserIntType, 0)
}

func (s *CastOperationContext) Int64Type() antlr.TerminalNode {
	return s.GetToken(PhpParserInt64Type, 0)
}

func (s *CastOperationContext) UintCast() antlr.TerminalNode {
	return s.GetToken(PhpParserUintCast, 0)
}

func (s *CastOperationContext) DoubleCast() antlr.TerminalNode {
	return s.GetToken(PhpParserDoubleCast, 0)
}

func (s *CastOperationContext) DoubleType() antlr.TerminalNode {
	return s.GetToken(PhpParserDoubleType, 0)
}

func (s *CastOperationContext) FloatCast() antlr.TerminalNode {
	return s.GetToken(PhpParserFloatCast, 0)
}

func (s *CastOperationContext) StringType() antlr.TerminalNode {
	return s.GetToken(PhpParserStringType, 0)
}

func (s *CastOperationContext) BinaryCast() antlr.TerminalNode {
	return s.GetToken(PhpParserBinaryCast, 0)
}

func (s *CastOperationContext) UnicodeCast() antlr.TerminalNode {
	return s.GetToken(PhpParserUnicodeCast, 0)
}

func (s *CastOperationContext) Array() antlr.TerminalNode {
	return s.GetToken(PhpParserArray, 0)
}

func (s *CastOperationContext) ObjectType() antlr.TerminalNode {
	return s.GetToken(PhpParserObjectType, 0)
}

func (s *CastOperationContext) Resource() antlr.TerminalNode {
	return s.GetToken(PhpParserResource, 0)
}

func (s *CastOperationContext) Unset() antlr.TerminalNode {
	return s.GetToken(PhpParserUnset, 0)
}

func (s *CastOperationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CastOperationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CastOperationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.EnterCastOperation(s)
	}
}

func (s *CastOperationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PhpParserListener); ok {
		listenerT.ExitCastOperation(s)
	}
}

func (p *PhpParser) CastOperation() (localctx ICastOperationContext) {
	localctx = NewCastOperationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 256, PhpParserRULE_castOperation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1619)
		_la = p.GetTokenStream().LA(1)

		if !((((_la-44)&-(0x1f+1)) == 0 && ((1<<uint((_la-44)))&((1<<(PhpParserArray-44))|(1<<(PhpParserBinaryCast-44))|(1<<(PhpParserBoolType-44))|(1<<(PhpParserDoubleCast-44))|(1<<(PhpParserDoubleType-44)))) != 0) || (((_la-77)&-(0x1f+1)) == 0 && ((1<<uint((_la-77)))&((1<<(PhpParserFloatCast-77))|(1<<(PhpParserInt8Cast-77))|(1<<(PhpParserInt16Cast-77))|(1<<(PhpParserInt64Type-77))|(1<<(PhpParserIntType-77))|(1<<(PhpParserObjectType-77)))) != 0) || (((_la-112)&-(0x1f+1)) == 0 && ((1<<uint((_la-112)))&((1<<(PhpParserResource-112))|(1<<(PhpParserStringType-112))|(1<<(PhpParserUintCast-112))|(1<<(PhpParserUnicodeCast-112))|(1<<(PhpParserUnset-112)))) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

func (p *PhpParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 83:
		var t *ExpressionContext = nil
		if localctx != nil {
			t = localctx.(*ExpressionContext)
		}
		return p.Expression_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *PhpParser) Expression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 18)

	case 1:
		return p.Precpred(p.GetParserRuleContext(), 16)

	case 2:
		return p.Precpred(p.GetParserRuleContext(), 15)

	case 3:
		return p.Precpred(p.GetParserRuleContext(), 14)

	case 4:
		return p.Precpred(p.GetParserRuleContext(), 13)

	case 5:
		return p.Precpred(p.GetParserRuleContext(), 12)

	case 6:
		return p.Precpred(p.GetParserRuleContext(), 11)

	case 7:
		return p.Precpred(p.GetParserRuleContext(), 10)

	case 8:
		return p.Precpred(p.GetParserRuleContext(), 9)

	case 9:
		return p.Precpred(p.GetParserRuleContext(), 8)

	case 10:
		return p.Precpred(p.GetParserRuleContext(), 7)

	case 11:
		return p.Precpred(p.GetParserRuleContext(), 6)

	case 12:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 13:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 14:
		return p.Precpred(p.GetParserRuleContext(), 1)

	case 15:
		return p.Precpred(p.GetParserRuleContext(), 17)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
